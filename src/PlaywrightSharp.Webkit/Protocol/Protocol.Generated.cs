//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Text.Json;
using System.Text.Json.Serialization;

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

namespace PlaywrightSharp.Webkit.Protocol.Animation
{
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum AnimationState
{
[System.Runtime.Serialization.EnumMember(Value = "ready")]Ready,
[System.Runtime.Serialization.EnumMember(Value = "delayed")]Delayed,
[System.Runtime.Serialization.EnumMember(Value = "active")]Active,
[System.Runtime.Serialization.EnumMember(Value = "canceled")]Canceled,
[System.Runtime.Serialization.EnumMember(Value = "done")]Done}
/// <summary>
/// 
/// </summary>
internal partial class TrackingUpdate
{
/// <summary>
/// 
/// </summary>
public string TrackingAnimationId { get; set; }
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public AnimationState AnimationState { get; set; }
/// <summary>
/// 
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Equal to the corresponding `animation-name` CSS property. Should not be provided if `transitionProperty` is also provided.
/// </summary>
public string AnimationName { get; set; }
/// <summary>
/// Equal to the corresponding `transition-property` CSS property. Should not be provided if `animationName` is also provided.
/// </summary>
public string TransitionProperty { get; set; }}
/// <summary>
/// Start tracking animations. This will produce a `trackingStart` event.
/// </summary>
/// <remarks>
/// Will send the command <c>Animation.startTracking</c>
/// </remarks>
internal partial class AnimationStartTrackingRequest : IWebkitRequest<AnimationStartTrackingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Animation.startTracking";
}
/// <summary>
/// Response from <see cref="AnimationStartTrackingRequest"/>
/// </summary>
internal partial class AnimationStartTrackingResponse: IWebkitResponse
{
}
/// <summary>
/// Stop tracking animations. This will produce a `trackingComplete` event.
/// </summary>
/// <remarks>
/// Will send the command <c>Animation.stopTracking</c>
/// </remarks>
internal partial class AnimationStopTrackingRequest : IWebkitRequest<AnimationStopTrackingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Animation.stopTracking";
}
/// <summary>
/// Response from <see cref="AnimationStopTrackingRequest"/>
/// </summary>
internal partial class AnimationStopTrackingResponse: IWebkitResponse
{
}
/// <summary>
/// Dispatched after `startTracking` command.
/// </summary>
/// <remarks>
/// Matches on the event <c>Animation.trackingStart</c>
/// </remarks>
internal partial class AnimationTrackingStartWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Animation.trackingStart";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }}
/// <summary>
/// Fired for each phase of Web Animation.
/// </summary>
/// <remarks>
/// Matches on the event <c>Animation.trackingUpdate</c>
/// </remarks>
internal partial class AnimationTrackingUpdateWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Animation.trackingUpdate";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// 
/// </summary>
public TrackingUpdate Event { get; set; }}
/// <summary>
/// Dispatched after `stopTracking` command.
/// </summary>
/// <remarks>
/// Matches on the event <c>Animation.trackingComplete</c>
/// </remarks>
internal partial class AnimationTrackingCompleteWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Animation.trackingComplete";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.ApplicationCache
{
/// <summary>
/// Detailed application cache resource information.
/// </summary>
internal partial class ApplicationCacheResource
{
/// <summary>
/// Resource url.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Resource size.
/// </summary>
public int? Size { get; set; }
/// <summary>
/// Resource type.
/// </summary>
public string Type { get; set; }}
/// <summary>
/// Detailed application cache information.
/// </summary>
internal partial class ApplicationCache
{
/// <summary>
/// Manifest URL.
/// </summary>
public string ManifestURL { get; set; }
/// <summary>
/// Application cache size.
/// </summary>
public double? Size { get; set; }
/// <summary>
/// Application cache creation time.
/// </summary>
public double? CreationTime { get; set; }
/// <summary>
/// Application cache update time.
/// </summary>
public double? UpdateTime { get; set; }
/// <summary>
/// Application cache resources.
/// </summary>
public ApplicationCacheResource[] Resources { get; set; }}
/// <summary>
/// Frame identifier - manifest URL pair.
/// </summary>
internal partial class FrameWithManifest
{
/// <summary>
/// Frame identifier.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Manifest URL.
/// </summary>
public string ManifestURL { get; set; }
/// <summary>
/// Application cache status.
/// </summary>
public int? Status { get; set; }}
/// <summary>
/// Returns array of frame identifiers with manifest urls for each frame containing a document associated with some application cache.
/// </summary>
/// <remarks>
/// Will send the command <c>ApplicationCache.getFramesWithManifests</c>
/// </remarks>
internal partial class ApplicationCacheGetFramesWithManifestsRequest : IWebkitRequest<ApplicationCacheGetFramesWithManifestsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ApplicationCache.getFramesWithManifests";
}
/// <summary>
/// Response from <see cref="ApplicationCacheGetFramesWithManifestsRequest"/>
/// </summary>
internal partial class ApplicationCacheGetFramesWithManifestsResponse: IWebkitResponse
{
/// <summary>
/// Array of frame identifiers with manifest urls for each frame containing a document associated with some application cache.
/// </summary>
public FrameWithManifest[] FrameIds { get; set; }}
/// <summary>
/// Enables application cache domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>ApplicationCache.enable</c>
/// </remarks>
internal partial class ApplicationCacheEnableRequest : IWebkitRequest<ApplicationCacheEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ApplicationCache.enable";
}
/// <summary>
/// Response from <see cref="ApplicationCacheEnableRequest"/>
/// </summary>
internal partial class ApplicationCacheEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disable application cache domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>ApplicationCache.disable</c>
/// </remarks>
internal partial class ApplicationCacheDisableRequest : IWebkitRequest<ApplicationCacheDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ApplicationCache.disable";
}
/// <summary>
/// Response from <see cref="ApplicationCacheDisableRequest"/>
/// </summary>
internal partial class ApplicationCacheDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Returns manifest URL for document in the given frame.
/// </summary>
/// <remarks>
/// Will send the command <c>ApplicationCache.getManifestForFrame</c>
/// </remarks>
internal partial class ApplicationCacheGetManifestForFrameRequest : IWebkitRequest<ApplicationCacheGetManifestForFrameResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ApplicationCache.getManifestForFrame";
/// <summary>
/// Identifier of the frame containing document whose manifest is retrieved.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Response from <see cref="ApplicationCacheGetManifestForFrameRequest"/>
/// </summary>
internal partial class ApplicationCacheGetManifestForFrameResponse: IWebkitResponse
{
/// <summary>
/// Manifest URL for document in the given frame.
/// </summary>
public string ManifestURL { get; set; }}
/// <summary>
/// Returns relevant application cache data for the document in given frame.
/// </summary>
/// <remarks>
/// Will send the command <c>ApplicationCache.getApplicationCacheForFrame</c>
/// </remarks>
internal partial class ApplicationCacheGetApplicationCacheForFrameRequest : IWebkitRequest<ApplicationCacheGetApplicationCacheForFrameResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ApplicationCache.getApplicationCacheForFrame";
/// <summary>
/// Identifier of the frame containing document whose application cache is retrieved.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Response from <see cref="ApplicationCacheGetApplicationCacheForFrameRequest"/>
/// </summary>
internal partial class ApplicationCacheGetApplicationCacheForFrameResponse: IWebkitResponse
{
/// <summary>
/// Relevant application cache data for the document in given frame.
/// </summary>
public ApplicationCache ApplicationCache { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>ApplicationCache.applicationCacheStatusUpdated</c>
/// </remarks>
internal partial class ApplicationCacheApplicationCacheStatusUpdatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "ApplicationCache.applicationCacheStatusUpdated";
/// <summary>
/// Identifier of the frame containing document whose application cache updated status.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Manifest URL.
/// </summary>
public string ManifestURL { get; set; }
/// <summary>
/// Updated application cache status.
/// </summary>
public int? Status { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>ApplicationCache.networkStateUpdated</c>
/// </remarks>
internal partial class ApplicationCacheNetworkStateUpdatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "ApplicationCache.networkStateUpdated";
/// <summary>
/// 
/// </summary>
public bool? IsNowOnline { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Audit
{
/// <summary>
/// Creates the `WebInspectorAudit` object that is passed to run. Must call teardown before calling setup more than once.
/// </summary>
/// <remarks>
/// Will send the command <c>Audit.setup</c>
/// </remarks>
internal partial class AuditSetupRequest : IWebkitRequest<AuditSetupResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Audit.setup";
/// <summary>
/// Specifies in which isolated context to run the test. Each content script lives in an isolated context and this parameter may be used to specify one of those contexts. If the parameter is omitted or 0 the evaluation will be performed in the context of the inspected page.
/// </summary>
public int? ContextId { get; set; }}
/// <summary>
/// Response from <see cref="AuditSetupRequest"/>
/// </summary>
internal partial class AuditSetupResponse: IWebkitResponse
{
}
/// <summary>
/// Parses and evaluates the given test string and sends back the result. Returned values are saved to the "audit" object group. Call setup before and teardown after if the `WebInspectorAudit` object should be passed into the test.
/// </summary>
/// <remarks>
/// Will send the command <c>Audit.run</c>
/// </remarks>
internal partial class AuditRunRequest : IWebkitRequest<AuditRunResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Audit.run";
/// <summary>
/// Test string to parse and evaluate.
/// </summary>
public string Test { get; set; }
/// <summary>
/// Specifies in which isolated context to run the test. Each content script lives in an isolated context and this parameter may be used to specify one of those contexts. If the parameter is omitted or 0 the evaluation will be performed in the context of the inspected page.
/// </summary>
public int? ContextId { get; set; }}
/// <summary>
/// Response from <see cref="AuditRunRequest"/>
/// </summary>
internal partial class AuditRunResponse: IWebkitResponse
{
/// <summary>
/// Evaluation result.
/// </summary>
public Runtime.RemoteObject Result { get; set; }
/// <summary>
/// True if the result was thrown during the evaluation.
/// </summary>
public bool? WasThrown { get; set; }}
/// <summary>
/// Destroys the `WebInspectorAudit` object that is passed to run. Must call setup before calling teardown.
/// </summary>
/// <remarks>
/// Will send the command <c>Audit.teardown</c>
/// </remarks>
internal partial class AuditTeardownRequest : IWebkitRequest<AuditTeardownResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Audit.teardown";
}
/// <summary>
/// Response from <see cref="AuditTeardownRequest"/>
/// </summary>
internal partial class AuditTeardownResponse: IWebkitResponse
{
}
}
namespace PlaywrightSharp.Webkit.Protocol.Browser
{
/// <summary>
/// Tab info object
/// </summary>
internal partial class PageProxyInfo
{
/// <summary>
/// 
/// </summary>
public string PageProxyId { get; set; }
/// <summary>
/// Unique identifier of the context.
/// </summary>
public string BrowserContextId { get; set; }
/// <summary>
/// Unique identifier of the opening page. Only set for pages created by window.open().
/// </summary>
public string OpenerId { get; set; }}
/// <summary>
/// Same-Site policy of a cookie.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum CookieSameSitePolicy
{
[System.Runtime.Serialization.EnumMember(Value = "None")]None,
[System.Runtime.Serialization.EnumMember(Value = "Lax")]Lax,
[System.Runtime.Serialization.EnumMember(Value = "Strict")]Strict}
/// <summary>
/// Cookie object
/// </summary>
internal partial class Cookie
{
/// <summary>
/// Cookie name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Cookie value.
/// </summary>
public string Value { get; set; }
/// <summary>
/// Cookie domain.
/// </summary>
public string Domain { get; set; }
/// <summary>
/// Cookie path.
/// </summary>
public string Path { get; set; }
/// <summary>
/// Cookie expires.
/// </summary>
public double? Expires { get; set; }
/// <summary>
/// True if cookie is http-only.
/// </summary>
public bool? HttpOnly { get; set; }
/// <summary>
/// True if cookie is secure.
/// </summary>
public bool? Secure { get; set; }
/// <summary>
/// True if cookie is session cookie.
/// </summary>
public bool? Session { get; set; }
/// <summary>
/// Cookie Same-Site policy.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public CookieSameSitePolicy SameSite { get; set; }}
/// <summary>
/// Cookie object
/// </summary>
internal partial class SetCookieParam
{
/// <summary>
/// Cookie name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Cookie value.
/// </summary>
public string Value { get; set; }
/// <summary>
/// Cookie domain.
/// </summary>
public string Domain { get; set; }
/// <summary>
/// Cookie path.
/// </summary>
public string Path { get; set; }
/// <summary>
/// Cookie expires.
/// </summary>
public double? Expires { get; set; }
/// <summary>
/// True if cookie is http-only.
/// </summary>
public bool? HttpOnly { get; set; }
/// <summary>
/// True if cookie is secure.
/// </summary>
public bool? Secure { get; set; }
/// <summary>
/// True if cookie is session cookie.
/// </summary>
public bool? Session { get; set; }
/// <summary>
/// Cookie Same-Site policy.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public CookieSameSitePolicy SameSite { get; set; }}
/// <summary>
/// Geolocation
/// </summary>
internal partial class Geolocation
{
/// <summary>
/// Mock latitude
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// Mock latitude
/// </summary>
public double? Latitude { get; set; }
/// <summary>
/// Mock longitude
/// </summary>
public double? Longitude { get; set; }
/// <summary>
/// Mock accuracy
/// </summary>
public double? Accuracy { get; set; }}
/// <summary>
/// Close browser.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.close</c>
/// </remarks>
internal partial class BrowserCloseRequest : IWebkitRequest<BrowserCloseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.close";
}
/// <summary>
/// Response from <see cref="BrowserCloseRequest"/>
/// </summary>
internal partial class BrowserCloseResponse: IWebkitResponse
{
}
/// <summary>
/// Creates new ephemeral browser context.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.createContext</c>
/// </remarks>
internal partial class BrowserCreateContextRequest : IWebkitRequest<BrowserCreateContextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.createContext";
}
/// <summary>
/// Response from <see cref="BrowserCreateContextRequest"/>
/// </summary>
internal partial class BrowserCreateContextResponse: IWebkitResponse
{
/// <summary>
/// Unique identifier of the context.
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// Deletes browser context previously created with createContect. The command will automatically close all pages that use the context.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.deleteContext</c>
/// </remarks>
internal partial class BrowserDeleteContextRequest : IWebkitRequest<BrowserDeleteContextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.deleteContext";
/// <summary>
/// Identifier of the context to delete.
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// Response from <see cref="BrowserDeleteContextRequest"/>
/// </summary>
internal partial class BrowserDeleteContextResponse: IWebkitResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.createPage</c>
/// </remarks>
internal partial class BrowserCreatePageRequest : IWebkitRequest<BrowserCreatePageResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.createPage";
/// <summary>
/// JSON Inspector Protocol message (command) to be dispatched on the backend.
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// Response from <see cref="BrowserCreatePageRequest"/>
/// </summary>
internal partial class BrowserCreatePageResponse: IWebkitResponse
{
/// <summary>
/// Unique identifier of the page proxy.
/// </summary>
public string PageProxyId { get; set; }}
/// <summary>
/// Navigates current page to the given URL.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.navigate</c>
/// </remarks>
internal partial class BrowserNavigateRequest : IWebkitRequest<BrowserNavigateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.navigate";
/// <summary>
/// URL to navigate the page to.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Unique identifier of the page proxy.
/// </summary>
public string PageProxyId { get; set; }
/// <summary>
/// Id of the frame to navigate.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Referrer URL.
/// </summary>
public string Referrer { get; set; }}
/// <summary>
/// Response from <see cref="BrowserNavigateRequest"/>
/// </summary>
internal partial class BrowserNavigateResponse: IWebkitResponse
{
/// <summary>
/// Identifier of the loader associated with the navigation.
/// </summary>
public string LoaderId { get; set; }}
/// <summary>
/// Change whether all certificate errors should be ignored.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.setIgnoreCertificateErrors</c>
/// </remarks>
internal partial class BrowserSetIgnoreCertificateErrorsRequest : IWebkitRequest<BrowserSetIgnoreCertificateErrorsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.setIgnoreCertificateErrors";
/// <summary>
/// Browser context id.
/// </summary>
public string BrowserContextId { get; set; }
/// <summary>
/// 
/// </summary>
public bool? Ignore { get; set; }}
/// <summary>
/// Response from <see cref="BrowserSetIgnoreCertificateErrorsRequest"/>
/// </summary>
internal partial class BrowserSetIgnoreCertificateErrorsResponse: IWebkitResponse
{
}
/// <summary>
/// Returns all cookies in the given browser context.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.getAllCookies</c>
/// </remarks>
internal partial class BrowserGetAllCookiesRequest : IWebkitRequest<BrowserGetAllCookiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.getAllCookies";
/// <summary>
/// Browser context id.
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// Response from <see cref="BrowserGetAllCookiesRequest"/>
/// </summary>
internal partial class BrowserGetAllCookiesResponse: IWebkitResponse
{
/// <summary>
/// Cookies.
/// </summary>
public Cookie[] Cookies { get; set; }}
/// <summary>
/// Sets cookies in the given browser context.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.setCookies</c>
/// </remarks>
internal partial class BrowserSetCookiesRequest : IWebkitRequest<BrowserSetCookiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.setCookies";
/// <summary>
/// Browser context id.
/// </summary>
public string BrowserContextId { get; set; }
/// <summary>
/// Cookies.
/// </summary>
public SetCookieParam[] Cookies { get; set; }}
/// <summary>
/// Response from <see cref="BrowserSetCookiesRequest"/>
/// </summary>
internal partial class BrowserSetCookiesResponse: IWebkitResponse
{
}
/// <summary>
/// Deletes cookies in the given browser context.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.deleteAllCookies</c>
/// </remarks>
internal partial class BrowserDeleteAllCookiesRequest : IWebkitRequest<BrowserDeleteAllCookiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.deleteAllCookies";
/// <summary>
/// Browser context id.
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// Response from <see cref="BrowserDeleteAllCookiesRequest"/>
/// </summary>
internal partial class BrowserDeleteAllCookiesResponse: IWebkitResponse
{
}
/// <summary>
/// Overrides the geolocation position or error.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.setGeolocationOverride</c>
/// </remarks>
internal partial class BrowserSetGeolocationOverrideRequest : IWebkitRequest<BrowserSetGeolocationOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.setGeolocationOverride";
/// <summary>
/// Browser context id.
/// </summary>
public string BrowserContextId { get; set; }
/// <summary>
/// Geolocation to set, if missing emulates position unavailable.
/// </summary>
public Geolocation Geolocation { get; set; }}
/// <summary>
/// Response from <see cref="BrowserSetGeolocationOverrideRequest"/>
/// </summary>
internal partial class BrowserSetGeolocationOverrideResponse: IWebkitResponse
{
}
/// <summary>
/// Overrides the permissions.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.grantPermissions</c>
/// </remarks>
internal partial class BrowserGrantPermissionsRequest : IWebkitRequest<BrowserGrantPermissionsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.grantPermissions";
/// <summary>
/// Browser context id.
/// </summary>
public string BrowserContextId { get; set; }
/// <summary>
/// 
/// </summary>
public string Origin { get; set; }
/// <summary>
/// 
/// </summary>
public string[] Permissions { get; set; }}
/// <summary>
/// Response from <see cref="BrowserGrantPermissionsRequest"/>
/// </summary>
internal partial class BrowserGrantPermissionsResponse: IWebkitResponse
{
}
/// <summary>
/// Clears permission overrides.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.resetPermissions</c>
/// </remarks>
internal partial class BrowserResetPermissionsRequest : IWebkitRequest<BrowserResetPermissionsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.resetPermissions";
/// <summary>
/// Browser context id.
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// Response from <see cref="BrowserResetPermissionsRequest"/>
/// </summary>
internal partial class BrowserResetPermissionsResponse: IWebkitResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Browser.pageProxyCreated</c>
/// </remarks>
internal partial class BrowserPageProxyCreatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Browser.pageProxyCreated";
/// <summary>
/// 
/// </summary>
public PageProxyInfo PageProxyInfo { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Browser.pageProxyDestroyed</c>
/// </remarks>
internal partial class BrowserPageProxyDestroyedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Browser.pageProxyDestroyed";
/// <summary>
/// 
/// </summary>
public string PageProxyId { get; set; }}
/// <summary>
/// Fired when provisional load fails.
/// </summary>
/// <remarks>
/// Matches on the event <c>Browser.provisionalLoadFailed</c>
/// </remarks>
internal partial class BrowserProvisionalLoadFailedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Browser.provisionalLoadFailed";
/// <summary>
/// Unique identifier of the page proxy.
/// </summary>
public string PageProxyId { get; set; }
/// <summary>
/// Identifier of the loader associated with the navigation.
/// </summary>
public string LoaderId { get; set; }
/// <summary>
/// Localized error string.
/// </summary>
public string Error { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Canvas
{
/// <summary>
/// The type of rendering context backing the canvas element.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum ContextType
{
[System.Runtime.Serialization.EnumMember(Value = "canvas-2d")]Canvas2D,
[System.Runtime.Serialization.EnumMember(Value = "bitmaprenderer")]Bitmaprenderer,
[System.Runtime.Serialization.EnumMember(Value = "webgl")]Webgl,
[System.Runtime.Serialization.EnumMember(Value = "webgl2")]Webgl2,
[System.Runtime.Serialization.EnumMember(Value = "webgpu")]Webgpu}
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum ProgramType
{
[System.Runtime.Serialization.EnumMember(Value = "compute")]Compute,
[System.Runtime.Serialization.EnumMember(Value = "render")]Render}
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum ShaderType
{
[System.Runtime.Serialization.EnumMember(Value = "compute")]Compute,
[System.Runtime.Serialization.EnumMember(Value = "fragment")]Fragment,
[System.Runtime.Serialization.EnumMember(Value = "vertex")]Vertex}
/// <summary>
/// Drawing surface attributes.
/// </summary>
internal partial class ContextAttributes
{
/// <summary>
/// WebGL, WebGL2, ImageBitmapRenderingContext
/// </summary>
public bool? Alpha { get; set; }
/// <summary>
/// WebGL, WebGL2
/// </summary>
public bool? Depth { get; set; }
/// <summary>
/// WebGL, WebGL2
/// </summary>
public bool? Stencil { get; set; }
/// <summary>
/// WebGL, WebGL2
/// </summary>
public bool? Antialias { get; set; }
/// <summary>
/// WebGL, WebGL2
/// </summary>
public bool? PremultipliedAlpha { get; set; }
/// <summary>
/// WebGL, WebGL2
/// </summary>
public bool? PreserveDrawingBuffer { get; set; }
/// <summary>
/// WebGL, WebGL2
/// </summary>
public bool? FailIfMajorPerformanceCaveat { get; set; }
/// <summary>
/// WebGL, WebGL2, WebGPU
/// </summary>
public string PowerPreference { get; set; }}
/// <summary>
/// Information about a canvas for which a rendering context has been created.
/// </summary>
internal partial class Canvas
{
/// <summary>
/// Canvas identifier.
/// </summary>
public string CanvasId { get; set; }
/// <summary>
/// The type of rendering context backing the canvas.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public ContextType ContextType { get; set; }
/// <summary>
/// The corresponding DOM node id.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// The CSS canvas identifier, for canvases created with &lt;code&gt;document.getCSSCanvasContext&lt;/code&gt;.
/// </summary>
public string CssCanvasName { get; set; }
/// <summary>
/// Context attributes for rendering contexts.
/// </summary>
public ContextAttributes ContextAttributes { get; set; }
/// <summary>
/// Memory usage of the canvas in bytes.
/// </summary>
public double? MemoryCost { get; set; }
/// <summary>
/// Backtrace that was captured when this canvas context was created.
/// </summary>
public Console.CallFrame[] Backtrace { get; set; }}
/// <summary>
/// Information about a WebGL/WebGL2 shader program or WebGPU shader pipeline.
/// </summary>
internal partial class ShaderProgram
{
/// <summary>
/// 
/// </summary>
public string ProgramId { get; set; }
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public ProgramType ProgramType { get; set; }
/// <summary>
/// 
/// </summary>
public string CanvasId { get; set; }
/// <summary>
/// Indicates whether the vertex and fragment shader modules are the same object for a render shader pipleine for a WebGPU device.
/// </summary>
public bool? SharesVertexFragmentShader { get; set; }}
/// <summary>
/// Enables Canvas domain events.
/// </summary>
/// <remarks>
/// Will send the command <c>Canvas.enable</c>
/// </remarks>
internal partial class CanvasEnableRequest : IWebkitRequest<CanvasEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Canvas.enable";
}
/// <summary>
/// Response from <see cref="CanvasEnableRequest"/>
/// </summary>
internal partial class CanvasEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables Canvas domain events.
/// </summary>
/// <remarks>
/// Will send the command <c>Canvas.disable</c>
/// </remarks>
internal partial class CanvasDisableRequest : IWebkitRequest<CanvasDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Canvas.disable";
}
/// <summary>
/// Response from <see cref="CanvasDisableRequest"/>
/// </summary>
internal partial class CanvasDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Gets the NodeId for the canvas node with the given CanvasId.
/// </summary>
/// <remarks>
/// Will send the command <c>Canvas.requestNode</c>
/// </remarks>
internal partial class CanvasRequestNodeRequest : IWebkitRequest<CanvasRequestNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Canvas.requestNode";
/// <summary>
/// Canvas identifier.
/// </summary>
public string CanvasId { get; set; }}
/// <summary>
/// Response from <see cref="CanvasRequestNodeRequest"/>
/// </summary>
internal partial class CanvasRequestNodeResponse: IWebkitResponse
{
/// <summary>
/// Node identifier for given canvas.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Gets the data for the canvas node with the given CanvasId.
/// </summary>
/// <remarks>
/// Will send the command <c>Canvas.requestContent</c>
/// </remarks>
internal partial class CanvasRequestContentRequest : IWebkitRequest<CanvasRequestContentResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Canvas.requestContent";
/// <summary>
/// Canvas identifier.
/// </summary>
public string CanvasId { get; set; }}
/// <summary>
/// Response from <see cref="CanvasRequestContentRequest"/>
/// </summary>
internal partial class CanvasRequestContentResponse: IWebkitResponse
{
/// <summary>
/// Base64-encoded data of the canvas' contents.
/// </summary>
public string Content { get; set; }}
/// <summary>
/// Gets all &lt;code&gt;-webkit-canvas&lt;/code&gt; nodes or active &lt;code&gt;HTMLCanvasElement&lt;/code&gt; for a &lt;code&gt;WebGPUDevice&lt;/code&gt;.
/// </summary>
/// <remarks>
/// Will send the command <c>Canvas.requestClientNodes</c>
/// </remarks>
internal partial class CanvasRequestClientNodesRequest : IWebkitRequest<CanvasRequestClientNodesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Canvas.requestClientNodes";
/// <summary>
/// 
/// </summary>
public string CanvasId { get; set; }}
/// <summary>
/// Response from <see cref="CanvasRequestClientNodesRequest"/>
/// </summary>
internal partial class CanvasRequestClientNodesResponse: IWebkitResponse
{
/// <summary>
/// 
/// </summary>
public int?[] ClientNodeIds { get; set; }}
/// <summary>
/// Resolves JavaScript canvas/device context object for given canvasId.
/// </summary>
/// <remarks>
/// Will send the command <c>Canvas.resolveContext</c>
/// </remarks>
internal partial class CanvasResolveContextRequest : IWebkitRequest<CanvasResolveContextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Canvas.resolveContext";
/// <summary>
/// Canvas identifier.
/// </summary>
public string CanvasId { get; set; }
/// <summary>
/// Symbolic group name that can be used to release multiple objects.
/// </summary>
public string ObjectGroup { get; set; }}
/// <summary>
/// Response from <see cref="CanvasResolveContextRequest"/>
/// </summary>
internal partial class CanvasResolveContextResponse: IWebkitResponse
{
/// <summary>
/// JavaScript object wrapper for given canvas context.
/// </summary>
public Runtime.RemoteObject Object { get; set; }}
/// <summary>
/// Tells the backend to record `count` frames whenever a new context is created.
/// </summary>
/// <remarks>
/// Will send the command <c>Canvas.setRecordingAutoCaptureFrameCount</c>
/// </remarks>
internal partial class CanvasSetRecordingAutoCaptureFrameCountRequest : IWebkitRequest<CanvasSetRecordingAutoCaptureFrameCountResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Canvas.setRecordingAutoCaptureFrameCount";
/// <summary>
/// Number of frames to record (0 means don't record anything).
/// </summary>
public int? Count { get; set; }}
/// <summary>
/// Response from <see cref="CanvasSetRecordingAutoCaptureFrameCountRequest"/>
/// </summary>
internal partial class CanvasSetRecordingAutoCaptureFrameCountResponse: IWebkitResponse
{
}
/// <summary>
/// Record the next frame, or up to the given number of bytes of data, for the given canvas.
/// </summary>
/// <remarks>
/// Will send the command <c>Canvas.startRecording</c>
/// </remarks>
internal partial class CanvasStartRecordingRequest : IWebkitRequest<CanvasStartRecordingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Canvas.startRecording";
/// <summary>
/// 
/// </summary>
public string CanvasId { get; set; }
/// <summary>
/// Number of frames to record (unlimited when not specified).
/// </summary>
public int? FrameCount { get; set; }
/// <summary>
/// Memory limit of recorded data (100MB when not specified).
/// </summary>
public int? MemoryLimit { get; set; }}
/// <summary>
/// Response from <see cref="CanvasStartRecordingRequest"/>
/// </summary>
internal partial class CanvasStartRecordingResponse: IWebkitResponse
{
}
/// <summary>
/// Stop recording the given canvas.
/// </summary>
/// <remarks>
/// Will send the command <c>Canvas.stopRecording</c>
/// </remarks>
internal partial class CanvasStopRecordingRequest : IWebkitRequest<CanvasStopRecordingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Canvas.stopRecording";
/// <summary>
/// 
/// </summary>
public string CanvasId { get; set; }}
/// <summary>
/// Response from <see cref="CanvasStopRecordingRequest"/>
/// </summary>
internal partial class CanvasStopRecordingResponse: IWebkitResponse
{
}
/// <summary>
/// Requests the source of the shader of the given type from the program with the given id.
/// </summary>
/// <remarks>
/// Will send the command <c>Canvas.requestShaderSource</c>
/// </remarks>
internal partial class CanvasRequestShaderSourceRequest : IWebkitRequest<CanvasRequestShaderSourceResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Canvas.requestShaderSource";
/// <summary>
/// 
/// </summary>
public string ProgramId { get; set; }
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public ShaderType ShaderType { get; set; }}
/// <summary>
/// Response from <see cref="CanvasRequestShaderSourceRequest"/>
/// </summary>
internal partial class CanvasRequestShaderSourceResponse: IWebkitResponse
{
/// <summary>
/// 
/// </summary>
public string Source { get; set; }}
/// <summary>
/// Compiles and links the shader with identifier and type with the given source code.
/// </summary>
/// <remarks>
/// Will send the command <c>Canvas.updateShader</c>
/// </remarks>
internal partial class CanvasUpdateShaderRequest : IWebkitRequest<CanvasUpdateShaderResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Canvas.updateShader";
/// <summary>
/// 
/// </summary>
public string ProgramId { get; set; }
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public ShaderType ShaderType { get; set; }
/// <summary>
/// 
/// </summary>
public string Source { get; set; }}
/// <summary>
/// Response from <see cref="CanvasUpdateShaderRequest"/>
/// </summary>
internal partial class CanvasUpdateShaderResponse: IWebkitResponse
{
}
/// <summary>
/// Enable/disable the visibility of the given shader program.
/// </summary>
/// <remarks>
/// Will send the command <c>Canvas.setShaderProgramDisabled</c>
/// </remarks>
internal partial class CanvasSetShaderProgramDisabledRequest : IWebkitRequest<CanvasSetShaderProgramDisabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Canvas.setShaderProgramDisabled";
/// <summary>
/// 
/// </summary>
public string ProgramId { get; set; }
/// <summary>
/// 
/// </summary>
public bool? Disabled { get; set; }}
/// <summary>
/// Response from <see cref="CanvasSetShaderProgramDisabledRequest"/>
/// </summary>
internal partial class CanvasSetShaderProgramDisabledResponse: IWebkitResponse
{
}
/// <summary>
/// Enable/disable highlighting of the given shader program.
/// </summary>
/// <remarks>
/// Will send the command <c>Canvas.setShaderProgramHighlighted</c>
/// </remarks>
internal partial class CanvasSetShaderProgramHighlightedRequest : IWebkitRequest<CanvasSetShaderProgramHighlightedResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Canvas.setShaderProgramHighlighted";
/// <summary>
/// 
/// </summary>
public string ProgramId { get; set; }
/// <summary>
/// 
/// </summary>
public bool? Highlighted { get; set; }}
/// <summary>
/// Response from <see cref="CanvasSetShaderProgramHighlightedRequest"/>
/// </summary>
internal partial class CanvasSetShaderProgramHighlightedResponse: IWebkitResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Canvas.canvasAdded</c>
/// </remarks>
internal partial class CanvasCanvasAddedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Canvas.canvasAdded";
/// <summary>
/// Canvas object.
/// </summary>
public Canvas Canvas { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Canvas.canvasRemoved</c>
/// </remarks>
internal partial class CanvasCanvasRemovedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Canvas.canvasRemoved";
/// <summary>
/// Removed canvas identifier.
/// </summary>
public string CanvasId { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Canvas.canvasMemoryChanged</c>
/// </remarks>
internal partial class CanvasCanvasMemoryChangedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Canvas.canvasMemoryChanged";
/// <summary>
/// Identifier of canvas that changed.
/// </summary>
public string CanvasId { get; set; }
/// <summary>
/// New memory cost value for the canvas in bytes.
/// </summary>
public double? MemoryCost { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Canvas.extensionEnabled</c>
/// </remarks>
internal partial class CanvasExtensionEnabledWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Canvas.extensionEnabled";
/// <summary>
/// 
/// </summary>
public string CanvasId { get; set; }
/// <summary>
/// Name of the extension that was enabled.
/// </summary>
public string Extension { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Canvas.clientNodesChanged</c>
/// </remarks>
internal partial class CanvasClientNodesChangedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Canvas.clientNodesChanged";
/// <summary>
/// Identifier of canvas that changed.
/// </summary>
public string CanvasId { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Canvas.recordingStarted</c>
/// </remarks>
internal partial class CanvasRecordingStartedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Canvas.recordingStarted";
/// <summary>
/// 
/// </summary>
public string CanvasId { get; set; }
/// <summary>
/// 
/// </summary>
public Recording.Initiator Initiator { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Canvas.recordingProgress</c>
/// </remarks>
internal partial class CanvasRecordingProgressWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Canvas.recordingProgress";
/// <summary>
/// 
/// </summary>
public string CanvasId { get; set; }
/// <summary>
/// 
/// </summary>
public Recording.Frame[] Frames { get; set; }
/// <summary>
/// Total memory size in bytes of all data recorded since the recording began.
/// </summary>
public int? BufferUsed { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Canvas.recordingFinished</c>
/// </remarks>
internal partial class CanvasRecordingFinishedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Canvas.recordingFinished";
/// <summary>
/// 
/// </summary>
public string CanvasId { get; set; }
/// <summary>
/// 
/// </summary>
public Recording.Recording Recording { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Canvas.programCreated</c>
/// </remarks>
internal partial class CanvasProgramCreatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Canvas.programCreated";
/// <summary>
/// 
/// </summary>
public ShaderProgram ShaderProgram { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Canvas.programDeleted</c>
/// </remarks>
internal partial class CanvasProgramDeletedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Canvas.programDeleted";
/// <summary>
/// 
/// </summary>
public string ProgramId { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Console
{
/// <summary>
/// Channels for different types of log messages.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum ChannelSource
{
[System.Runtime.Serialization.EnumMember(Value = "xml")]Xml,
[System.Runtime.Serialization.EnumMember(Value = "javascript")]Javascript,
[System.Runtime.Serialization.EnumMember(Value = "network")]Network,
[System.Runtime.Serialization.EnumMember(Value = "console-api")]ConsoleApi,
[System.Runtime.Serialization.EnumMember(Value = "storage")]Storage,
[System.Runtime.Serialization.EnumMember(Value = "appcache")]Appcache,
[System.Runtime.Serialization.EnumMember(Value = "rendering")]Rendering,
[System.Runtime.Serialization.EnumMember(Value = "css")]Css,
[System.Runtime.Serialization.EnumMember(Value = "security")]Security,
[System.Runtime.Serialization.EnumMember(Value = "content-blocker")]ContentBlocker,
[System.Runtime.Serialization.EnumMember(Value = "media")]Media,
[System.Runtime.Serialization.EnumMember(Value = "mediasource")]Mediasource,
[System.Runtime.Serialization.EnumMember(Value = "webrtc")]Webrtc,
[System.Runtime.Serialization.EnumMember(Value = "other")]Other}
/// <summary>
/// Level of logging.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum ChannelLevel
{
[System.Runtime.Serialization.EnumMember(Value = "off")]Off,
[System.Runtime.Serialization.EnumMember(Value = "basic")]Basic,
[System.Runtime.Serialization.EnumMember(Value = "verbose")]Verbose}
/// <summary>
/// Logging channel.
/// </summary>
internal partial class Channel
{
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public ChannelSource Source { get; set; }
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public ChannelLevel Level { get; set; }}
/// <summary>
/// Console message.
/// </summary>
internal partial class ConsoleMessage
{
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public ChannelSource Source { get; set; }
/// <summary>
/// Message severity.
/// </summary>
public string Level { get; set; }
/// <summary>
/// Message text.
/// </summary>
public string Text { get; set; }
/// <summary>
/// Console message type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// URL of the message origin.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Line number in the resource that generated this message.
/// </summary>
public int? Line { get; set; }
/// <summary>
/// Column number on the line in the resource that generated this message.
/// </summary>
public int? Column { get; set; }
/// <summary>
/// Repeat count for repeated messages.
/// </summary>
public int? RepeatCount { get; set; }
/// <summary>
/// Message parameters in case of the formatted message.
/// </summary>
public Runtime.RemoteObject[] Parameters { get; set; }
/// <summary>
/// JavaScript stack trace for assertions and error messages.
/// </summary>
public CallFrame[] StackTrace { get; set; }
/// <summary>
/// Identifier of the network request associated with this message.
/// </summary>
public string NetworkRequestId { get; set; }}
/// <summary>
/// Stack entry for console errors and assertions.
/// </summary>
internal partial class CallFrame
{
/// <summary>
/// JavaScript function name.
/// </summary>
public string FunctionName { get; set; }
/// <summary>
/// JavaScript script name or url.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Script identifier.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// JavaScript script line number.
/// </summary>
public int? LineNumber { get; set; }
/// <summary>
/// JavaScript script column number.
/// </summary>
public int? ColumnNumber { get; set; }}
/// <summary>
/// Call frames for async function calls, console assertions, and error messages.
/// </summary>
internal partial class StackTrace
{
/// <summary>
/// 
/// </summary>
public CallFrame[] CallFrames { get; set; }
/// <summary>
/// Whether the first item in &lt;code&gt;callFrames&lt;/code&gt; is the native function that scheduled the asynchronous operation (e.g. setTimeout).
/// </summary>
public bool? TopCallFrameIsBoundary { get; set; }
/// <summary>
/// Whether one or more frames have been truncated from the bottom of the stack.
/// </summary>
public bool? Truncated { get; set; }
/// <summary>
/// Parent StackTrace.
/// </summary>
public StackTrace ParentStackTrace { get; set; }}
/// <summary>
/// Enables console domain, sends the messages collected so far to the client by means of the &lt;code&gt;messageAdded&lt;/code&gt; notification.
/// </summary>
/// <remarks>
/// Will send the command <c>Console.enable</c>
/// </remarks>
internal partial class ConsoleEnableRequest : IWebkitRequest<ConsoleEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Console.enable";
}
/// <summary>
/// Response from <see cref="ConsoleEnableRequest"/>
/// </summary>
internal partial class ConsoleEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables console domain, prevents further console messages from being reported to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>Console.disable</c>
/// </remarks>
internal partial class ConsoleDisableRequest : IWebkitRequest<ConsoleDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Console.disable";
}
/// <summary>
/// Response from <see cref="ConsoleDisableRequest"/>
/// </summary>
internal partial class ConsoleDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Clears console messages collected in the browser.
/// </summary>
/// <remarks>
/// Will send the command <c>Console.clearMessages</c>
/// </remarks>
internal partial class ConsoleClearMessagesRequest : IWebkitRequest<ConsoleClearMessagesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Console.clearMessages";
}
/// <summary>
/// Response from <see cref="ConsoleClearMessagesRequest"/>
/// </summary>
internal partial class ConsoleClearMessagesResponse: IWebkitResponse
{
}
/// <summary>
/// List of the different message sources that are non-default logging channels.
/// </summary>
/// <remarks>
/// Will send the command <c>Console.getLoggingChannels</c>
/// </remarks>
internal partial class ConsoleGetLoggingChannelsRequest : IWebkitRequest<ConsoleGetLoggingChannelsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Console.getLoggingChannels";
}
/// <summary>
/// Response from <see cref="ConsoleGetLoggingChannelsRequest"/>
/// </summary>
internal partial class ConsoleGetLoggingChannelsResponse: IWebkitResponse
{
/// <summary>
/// Logging channels.
/// </summary>
public Channel[] Channels { get; set; }}
/// <summary>
/// Modify the level of a channel.
/// </summary>
/// <remarks>
/// Will send the command <c>Console.setLoggingChannelLevel</c>
/// </remarks>
internal partial class ConsoleSetLoggingChannelLevelRequest : IWebkitRequest<ConsoleSetLoggingChannelLevelResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Console.setLoggingChannelLevel";
/// <summary>
/// Logging channel to modify.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public ChannelSource Source { get; set; }
/// <summary>
/// New level.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public ChannelLevel Level { get; set; }}
/// <summary>
/// Response from <see cref="ConsoleSetLoggingChannelLevelRequest"/>
/// </summary>
internal partial class ConsoleSetLoggingChannelLevelResponse: IWebkitResponse
{
}
/// <summary>
/// Issued when new console message is added.
/// </summary>
/// <remarks>
/// Matches on the event <c>Console.messageAdded</c>
/// </remarks>
internal partial class ConsoleMessageAddedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Console.messageAdded";
/// <summary>
/// Console message that has been added.
/// </summary>
public ConsoleMessage Message { get; set; }}
/// <summary>
/// Issued when subsequent message(s) are equal to the previous one(s).
/// </summary>
/// <remarks>
/// Matches on the event <c>Console.messageRepeatCountUpdated</c>
/// </remarks>
internal partial class ConsoleMessageRepeatCountUpdatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Console.messageRepeatCountUpdated";
/// <summary>
/// New repeat count value.
/// </summary>
public int? Count { get; set; }}
/// <summary>
/// Issued when console is cleared. This happens either upon &lt;code&gt;clearMessages&lt;/code&gt; command or after page navigation.
/// </summary>
/// <remarks>
/// Matches on the event <c>Console.messagesCleared</c>
/// </remarks>
internal partial class ConsoleMessagesClearedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Console.messagesCleared";
}
/// <summary>
/// Issued from console.takeHeapSnapshot.
/// </summary>
/// <remarks>
/// Matches on the event <c>Console.heapSnapshot</c>
/// </remarks>
internal partial class ConsoleHeapSnapshotWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Console.heapSnapshot";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// Snapshot at the end of tracking.
/// </summary>
public string SnapshotData { get; set; }
/// <summary>
/// Optional title provided to console.takeHeapSnapshot.
/// </summary>
public string Title { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.CPUProfiler
{
/// <summary>
/// CPU usage for an individual thread.
/// </summary>
internal partial class ThreadInfo
{
/// <summary>
/// Some thread identification information.
/// </summary>
public string Name { get; set; }
/// <summary>
/// CPU usage for this thread. This should not exceed 100% for an individual thread.
/// </summary>
public double? Usage { get; set; }
/// <summary>
/// Type of thread. There should be a single main thread.
/// </summary>
public string Type { get; set; }
/// <summary>
/// A thread may be associated with a target, such as a Worker, in the process.
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class Event
{
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// Percent of total cpu usage. If there are multiple cores the usage may be greater than 100%.
/// </summary>
public double? Usage { get; set; }
/// <summary>
/// Per-thread CPU usage information. Does not include the main thread.
/// </summary>
public ThreadInfo[] Threads { get; set; }}
/// <summary>
/// Start tracking cpu usage.
/// </summary>
/// <remarks>
/// Will send the command <c>CPUProfiler.startTracking</c>
/// </remarks>
internal partial class CPUProfilerStartTrackingRequest : IWebkitRequest<CPUProfilerStartTrackingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CPUProfiler.startTracking";
}
/// <summary>
/// Response from <see cref="CPUProfilerStartTrackingRequest"/>
/// </summary>
internal partial class CPUProfilerStartTrackingResponse: IWebkitResponse
{
}
/// <summary>
/// Stop tracking cpu usage. This will produce a `trackingComplete` event.
/// </summary>
/// <remarks>
/// Will send the command <c>CPUProfiler.stopTracking</c>
/// </remarks>
internal partial class CPUProfilerStopTrackingRequest : IWebkitRequest<CPUProfilerStopTrackingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CPUProfiler.stopTracking";
}
/// <summary>
/// Response from <see cref="CPUProfilerStopTrackingRequest"/>
/// </summary>
internal partial class CPUProfilerStopTrackingResponse: IWebkitResponse
{
}
/// <summary>
/// Tracking started.
/// </summary>
/// <remarks>
/// Matches on the event <c>CPUProfiler.trackingStart</c>
/// </remarks>
internal partial class CPUProfilerTrackingStartWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "CPUProfiler.trackingStart";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }}
/// <summary>
/// Periodic tracking updates with event data.
/// </summary>
/// <remarks>
/// Matches on the event <c>CPUProfiler.trackingUpdate</c>
/// </remarks>
internal partial class CPUProfilerTrackingUpdateWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "CPUProfiler.trackingUpdate";
/// <summary>
/// 
/// </summary>
public Event Event { get; set; }}
/// <summary>
/// Tracking stopped.
/// </summary>
/// <remarks>
/// Matches on the event <c>CPUProfiler.trackingComplete</c>
/// </remarks>
internal partial class CPUProfilerTrackingCompleteWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "CPUProfiler.trackingComplete";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.CSS
{
/// <summary>
/// This object identifies a CSS style in a unique way.
/// </summary>
internal partial class CSSStyleId
{
/// <summary>
/// Enclosing stylesheet identifier.
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// The style ordinal within the stylesheet.
/// </summary>
public int? Ordinal { get; set; }}
/// <summary>
/// Stylesheet type: "user" for user stylesheets, "user-agent" for user-agent stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via inspector" rules), "regular" for regular stylesheets.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum StyleSheetOrigin
{
[System.Runtime.Serialization.EnumMember(Value = "user")]User,
[System.Runtime.Serialization.EnumMember(Value = "user-agent")]UserAgent,
[System.Runtime.Serialization.EnumMember(Value = "inspector")]Inspector,
[System.Runtime.Serialization.EnumMember(Value = "regular")]Regular}
/// <summary>
/// This object identifies a CSS rule in a unique way.
/// </summary>
internal partial class CSSRuleId
{
/// <summary>
/// Enclosing stylesheet identifier.
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// The rule ordinal within the stylesheet.
/// </summary>
public int? Ordinal { get; set; }}
/// <summary>
/// Pseudo-style identifier (see &lt;code&gt;enum PseudoId&lt;/code&gt; in &lt;code&gt;RenderStyleConstants.h&lt;/code&gt;).
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum PseudoId
{
[System.Runtime.Serialization.EnumMember(Value = "first-line")]FirstLine,
[System.Runtime.Serialization.EnumMember(Value = "first-letter")]FirstLetter,
[System.Runtime.Serialization.EnumMember(Value = "highlight")]Highlight,
[System.Runtime.Serialization.EnumMember(Value = "marker")]Marker,
[System.Runtime.Serialization.EnumMember(Value = "before")]Before,
[System.Runtime.Serialization.EnumMember(Value = "after")]After,
[System.Runtime.Serialization.EnumMember(Value = "selection")]Selection,
[System.Runtime.Serialization.EnumMember(Value = "scrollbar")]Scrollbar,
[System.Runtime.Serialization.EnumMember(Value = "scrollbar-thumb")]ScrollbarThumb,
[System.Runtime.Serialization.EnumMember(Value = "scrollbar-button")]ScrollbarButton,
[System.Runtime.Serialization.EnumMember(Value = "scrollbar-track")]ScrollbarTrack,
[System.Runtime.Serialization.EnumMember(Value = "scrollbar-track-piece")]ScrollbarTrackPiece,
[System.Runtime.Serialization.EnumMember(Value = "scrollbar-corner")]ScrollbarCorner,
[System.Runtime.Serialization.EnumMember(Value = "resizer")]Resizer}
/// <summary>
/// CSS rule collection for a single pseudo style.
/// </summary>
internal partial class PseudoIdMatches
{
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public PseudoId PseudoId { get; set; }
/// <summary>
/// Matches of CSS rules applicable to the pseudo style.
/// </summary>
public RuleMatch[] Matches { get; set; }}
/// <summary>
/// CSS rule collection for a single pseudo style.
/// </summary>
internal partial class InheritedStyleEntry
{
/// <summary>
/// The ancestor node's inline style, if any, in the style inheritance chain.
/// </summary>
public CSSStyle InlineStyle { get; set; }
/// <summary>
/// Matches of CSS rules matching the ancestor node in the style inheritance chain.
/// </summary>
public RuleMatch[] MatchedCSSRules { get; set; }}
/// <summary>
/// Match data for a CSS rule.
/// </summary>
internal partial class RuleMatch
{
/// <summary>
/// CSS rule in the match.
/// </summary>
public CSSRule Rule { get; set; }
/// <summary>
/// Matching selector indices in the rule's selectorList selectors (0-based).
/// </summary>
public int?[] MatchingSelectors { get; set; }}
/// <summary>
/// CSS selector.
/// </summary>
internal partial class CSSSelector
{
/// <summary>
/// Canonicalized selector text.
/// </summary>
public string Text { get; set; }
/// <summary>
/// Specificity (a, b, c) tuple. Included if the selector is sent in response to CSS.getMatchedStylesForNode which provides a context element.
/// </summary>
public int?[] Specificity { get; set; }
/// <summary>
/// Whether or not the specificity can be dynamic. Included if the selector is sent in response to CSS.getMatchedStylesForNode which provides a context element.
/// </summary>
public bool? Dynamic { get; set; }}
/// <summary>
/// Selector list data.
/// </summary>
internal partial class SelectorList
{
/// <summary>
/// Selectors in the list.
/// </summary>
public CSSSelector[] Selectors { get; set; }
/// <summary>
/// Rule selector text.
/// </summary>
public string Text { get; set; }
/// <summary>
/// Rule selector range in the underlying resource (if available).
/// </summary>
public SourceRange Range { get; set; }}
/// <summary>
/// CSS style information for a DOM style attribute.
/// </summary>
internal partial class CSSStyleAttribute
{
/// <summary>
/// DOM attribute name (e.g. "width").
/// </summary>
public string Name { get; set; }
/// <summary>
/// CSS style generated by the respective DOM attribute.
/// </summary>
public CSSStyle Style { get; set; }}
/// <summary>
/// CSS stylesheet meta-information.
/// </summary>
internal partial class CSSStyleSheetHeader
{
/// <summary>
/// The stylesheet identifier.
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// Owner frame identifier.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Stylesheet resource URL.
/// </summary>
public string SourceURL { get; set; }
/// <summary>
/// Stylesheet origin.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public StyleSheetOrigin Origin { get; set; }
/// <summary>
/// Stylesheet title.
/// </summary>
public string Title { get; set; }
/// <summary>
/// Denotes whether the stylesheet is disabled.
/// </summary>
public bool? Disabled { get; set; }
/// <summary>
/// Whether this stylesheet is a &lt;style&gt; tag created by the parser. This is not set for document.written &lt;style&gt; tags.
/// </summary>
public bool? IsInline { get; set; }
/// <summary>
/// Line offset of the stylesheet within the resource (zero based).
/// </summary>
public double? StartLine { get; set; }
/// <summary>
/// Column offset of the stylesheet within the resource (zero based).
/// </summary>
public double? StartColumn { get; set; }}
/// <summary>
/// CSS stylesheet contents.
/// </summary>
internal partial class CSSStyleSheetBody
{
/// <summary>
/// The stylesheet identifier.
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// Stylesheet resource URL.
/// </summary>
public CSSRule[] Rules { get; set; }
/// <summary>
/// Stylesheet resource contents (if available).
/// </summary>
public string Text { get; set; }}
/// <summary>
/// CSS rule representation.
/// </summary>
internal partial class CSSRule
{
/// <summary>
/// The CSS rule identifier (absent for user agent stylesheet and user-specified stylesheet rules).
/// </summary>
public CSSRuleId RuleId { get; set; }
/// <summary>
/// Rule selector data.
/// </summary>
public SelectorList SelectorList { get; set; }
/// <summary>
/// Parent stylesheet resource URL (for regular rules).
/// </summary>
public string SourceURL { get; set; }
/// <summary>
/// Line ordinal of the rule selector start character in the resource.
/// </summary>
public int? SourceLine { get; set; }
/// <summary>
/// Parent stylesheet's origin.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public StyleSheetOrigin Origin { get; set; }
/// <summary>
/// Associated style declaration.
/// </summary>
public CSSStyle Style { get; set; }
/// <summary>
/// Grouping list array (for rules involving @media/@supports). The array enumerates CSS groupings starting with the innermost one, going outwards.
/// </summary>
public Grouping[] Groupings { get; set; }}
/// <summary>
/// Text range within a resource.
/// </summary>
internal partial class SourceRange
{
/// <summary>
/// Start line of range.
/// </summary>
public int? StartLine { get; set; }
/// <summary>
/// Start column of range (inclusive).
/// </summary>
public int? StartColumn { get; set; }
/// <summary>
/// End line of range
/// </summary>
public int? EndLine { get; set; }
/// <summary>
/// End column of range (exclusive).
/// </summary>
public int? EndColumn { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class ShorthandEntry
{
/// <summary>
/// Shorthand name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Shorthand value.
/// </summary>
public string Value { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class CSSPropertyInfo
{
/// <summary>
/// Property name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Other names for this property.
/// </summary>
public string[] Aliases { get; set; }
/// <summary>
/// Longhand property names.
/// </summary>
public string[] Longhands { get; set; }
/// <summary>
/// Supported values for this property.
/// </summary>
public string[] Values { get; set; }
/// <summary>
/// Whether the property is able to be inherited.
/// </summary>
public bool? Inherited { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class CSSComputedStyleProperty
{
/// <summary>
/// Computed style property name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Computed style property value.
/// </summary>
public string Value { get; set; }}
/// <summary>
/// CSS style representation.
/// </summary>
internal partial class CSSStyle
{
/// <summary>
/// The CSS style identifier (absent for attribute styles).
/// </summary>
public CSSStyleId StyleId { get; set; }
/// <summary>
/// CSS properties in the style.
/// </summary>
public CSSProperty[] CssProperties { get; set; }
/// <summary>
/// Computed values for all shorthands found in the style.
/// </summary>
public ShorthandEntry[] ShorthandEntries { get; set; }
/// <summary>
/// Style declaration text (if available).
/// </summary>
public string CssText { get; set; }
/// <summary>
/// Style declaration range in the enclosing stylesheet (if available).
/// </summary>
public SourceRange Range { get; set; }
/// <summary>
/// The effective "width" property value from this style.
/// </summary>
public string Width { get; set; }
/// <summary>
/// The effective "height" property value from this style.
/// </summary>
public string Height { get; set; }}
/// <summary>
/// The property status: "active" if the property is effective in the style, "inactive" if the property is overridden by a same-named property in this style later on, "disabled" if the property is disabled by the user, "style" (implied if absent) if the property is reported by the browser rather than by the CSS source parser.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum CSSPropertyStatus
{
[System.Runtime.Serialization.EnumMember(Value = "active")]Active,
[System.Runtime.Serialization.EnumMember(Value = "inactive")]Inactive,
[System.Runtime.Serialization.EnumMember(Value = "disabled")]Disabled,
[System.Runtime.Serialization.EnumMember(Value = "style")]Style}
/// <summary>
/// CSS style effective visual dimensions and source offsets.
/// </summary>
internal partial class CSSProperty
{
/// <summary>
/// The property name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// The property value.
/// </summary>
public string Value { get; set; }
/// <summary>
/// The property priority (implies "" if absent).
/// </summary>
public string Priority { get; set; }
/// <summary>
/// Whether the property is implicit (implies &lt;code&gt;false&lt;/code&gt; if absent).
/// </summary>
public bool? Implicit { get; set; }
/// <summary>
/// The full property text as specified in the style.
/// </summary>
public string Text { get; set; }
/// <summary>
/// Whether the property is understood by the browser (implies &lt;code&gt;true&lt;/code&gt; if absent).
/// </summary>
public bool? ParsedOk { get; set; }
/// <summary>
/// Whether the property is active or disabled.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public CSSPropertyStatus Status { get; set; }
/// <summary>
/// The entire property range in the enclosing style declaration (if available).
/// </summary>
public SourceRange Range { get; set; }}
/// <summary>
/// CSS @media (as well as other users of media queries, like @import, &lt;style&gt;, &lt;link&gt;, etc.) and @supports descriptor.
/// </summary>
internal partial class Grouping
{
/// <summary>
/// Media query text.
/// </summary>
public string Text { get; set; }
/// <summary>
/// Source of the media query: "media-rule" if specified by a @media rule, "media-import-rule" if specified by an @import rule, "media-link-node" if specified by a "media" attribute in a linked style sheet's LINK tag, "media-style-node" if specified by a "media" attribute in an inline style sheet's STYLE tag, "supports-rule" if specified by an @supports rule, .
/// </summary>
public string Type { get; set; }
/// <summary>
/// URL of the document containing the CSS grouping.
/// </summary>
public string SourceURL { get; set; }}
/// <summary>
/// Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been enabled until the result of this command is received.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.enable</c>
/// </remarks>
internal partial class CSSEnableRequest : IWebkitRequest<CSSEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.enable";
}
/// <summary>
/// Response from <see cref="CSSEnableRequest"/>
/// </summary>
internal partial class CSSEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables the CSS agent for the given page.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.disable</c>
/// </remarks>
internal partial class CSSDisableRequest : IWebkitRequest<CSSDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.disable";
}
/// <summary>
/// Response from <see cref="CSSDisableRequest"/>
/// </summary>
internal partial class CSSDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Returns requested styles for a DOM node identified by &lt;code&gt;nodeId&lt;/code&gt;.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getMatchedStylesForNode</c>
/// </remarks>
internal partial class CSSGetMatchedStylesForNodeRequest : IWebkitRequest<CSSGetMatchedStylesForNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getMatchedStylesForNode";
/// <summary>
/// 
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Whether to include pseudo styles (default: true).
/// </summary>
public bool? IncludePseudo { get; set; }
/// <summary>
/// Whether to include inherited styles (default: true).
/// </summary>
public bool? IncludeInherited { get; set; }}
/// <summary>
/// Response from <see cref="CSSGetMatchedStylesForNodeRequest"/>
/// </summary>
internal partial class CSSGetMatchedStylesForNodeResponse: IWebkitResponse
{
/// <summary>
/// CSS rules matching this node, from all applicable stylesheets.
/// </summary>
public RuleMatch[] MatchedCSSRules { get; set; }
/// <summary>
/// Pseudo style matches for this node.
/// </summary>
public PseudoIdMatches[] PseudoElements { get; set; }
/// <summary>
/// A chain of inherited styles (from the immediate node parent up to the DOM tree root).
/// </summary>
public InheritedStyleEntry[] Inherited { get; set; }}
/// <summary>
/// Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM attributes) for a DOM node identified by &lt;code&gt;nodeId&lt;/code&gt;.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getInlineStylesForNode</c>
/// </remarks>
internal partial class CSSGetInlineStylesForNodeRequest : IWebkitRequest<CSSGetInlineStylesForNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getInlineStylesForNode";
/// <summary>
/// 
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Response from <see cref="CSSGetInlineStylesForNodeRequest"/>
/// </summary>
internal partial class CSSGetInlineStylesForNodeResponse: IWebkitResponse
{
/// <summary>
/// Inline style for the specified DOM node.
/// </summary>
public CSSStyle InlineStyle { get; set; }
/// <summary>
/// Attribute-defined element style (e.g. resulting from "width=20 height=100%").
/// </summary>
public CSSStyle AttributesStyle { get; set; }}
/// <summary>
/// Returns the computed style for a DOM node identified by &lt;code&gt;nodeId&lt;/code&gt;.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getComputedStyleForNode</c>
/// </remarks>
internal partial class CSSGetComputedStyleForNodeRequest : IWebkitRequest<CSSGetComputedStyleForNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getComputedStyleForNode";
/// <summary>
/// 
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Response from <see cref="CSSGetComputedStyleForNodeRequest"/>
/// </summary>
internal partial class CSSGetComputedStyleForNodeResponse: IWebkitResponse
{
/// <summary>
/// Computed style for the specified DOM node.
/// </summary>
public CSSComputedStyleProperty[] ComputedStyle { get; set; }}
/// <summary>
/// Returns metainfo entries for all known stylesheets.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getAllStyleSheets</c>
/// </remarks>
internal partial class CSSGetAllStyleSheetsRequest : IWebkitRequest<CSSGetAllStyleSheetsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getAllStyleSheets";
}
/// <summary>
/// Response from <see cref="CSSGetAllStyleSheetsRequest"/>
/// </summary>
internal partial class CSSGetAllStyleSheetsResponse: IWebkitResponse
{
/// <summary>
/// Descriptor entries for all available stylesheets.
/// </summary>
public CSSStyleSheetHeader[] Headers { get; set; }}
/// <summary>
/// Returns stylesheet data for the specified &lt;code&gt;styleSheetId&lt;/code&gt;.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getStyleSheet</c>
/// </remarks>
internal partial class CSSGetStyleSheetRequest : IWebkitRequest<CSSGetStyleSheetResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getStyleSheet";
/// <summary>
/// 
/// </summary>
public string StyleSheetId { get; set; }}
/// <summary>
/// Response from <see cref="CSSGetStyleSheetRequest"/>
/// </summary>
internal partial class CSSGetStyleSheetResponse: IWebkitResponse
{
/// <summary>
/// Stylesheet contents for the specified &lt;code&gt;styleSheetId&lt;/code&gt;.
/// </summary>
public CSSStyleSheetBody StyleSheet { get; set; }}
/// <summary>
/// Returns the current textual content and the URL for a stylesheet.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getStyleSheetText</c>
/// </remarks>
internal partial class CSSGetStyleSheetTextRequest : IWebkitRequest<CSSGetStyleSheetTextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getStyleSheetText";
/// <summary>
/// 
/// </summary>
public string StyleSheetId { get; set; }}
/// <summary>
/// Response from <see cref="CSSGetStyleSheetTextRequest"/>
/// </summary>
internal partial class CSSGetStyleSheetTextResponse: IWebkitResponse
{
/// <summary>
/// The stylesheet text.
/// </summary>
public string Text { get; set; }}
/// <summary>
/// Sets the new stylesheet text, thereby invalidating all existing &lt;code&gt;CSSStyleId&lt;/code&gt;'s and &lt;code&gt;CSSRuleId&lt;/code&gt;'s contained by this stylesheet.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.setStyleSheetText</c>
/// </remarks>
internal partial class CSSSetStyleSheetTextRequest : IWebkitRequest<CSSSetStyleSheetTextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.setStyleSheetText";
/// <summary>
/// 
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// 
/// </summary>
public string Text { get; set; }}
/// <summary>
/// Response from <see cref="CSSSetStyleSheetTextRequest"/>
/// </summary>
internal partial class CSSSetStyleSheetTextResponse: IWebkitResponse
{
}
/// <summary>
/// Sets the new &lt;code&gt;text&lt;/code&gt; for the respective style.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.setStyleText</c>
/// </remarks>
internal partial class CSSSetStyleTextRequest : IWebkitRequest<CSSSetStyleTextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.setStyleText";
/// <summary>
/// 
/// </summary>
public CSSStyleId StyleId { get; set; }
/// <summary>
/// 
/// </summary>
public string Text { get; set; }}
/// <summary>
/// Response from <see cref="CSSSetStyleTextRequest"/>
/// </summary>
internal partial class CSSSetStyleTextResponse: IWebkitResponse
{
/// <summary>
/// The resulting style after the text modification.
/// </summary>
public CSSStyle Style { get; set; }}
/// <summary>
/// Modifies the rule selector.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.setRuleSelector</c>
/// </remarks>
internal partial class CSSSetRuleSelectorRequest : IWebkitRequest<CSSSetRuleSelectorResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.setRuleSelector";
/// <summary>
/// 
/// </summary>
public CSSRuleId RuleId { get; set; }
/// <summary>
/// 
/// </summary>
public string Selector { get; set; }}
/// <summary>
/// Response from <see cref="CSSSetRuleSelectorRequest"/>
/// </summary>
internal partial class CSSSetRuleSelectorResponse: IWebkitResponse
{
/// <summary>
/// The resulting rule after the selector modification.
/// </summary>
public CSSRule Rule { get; set; }}
/// <summary>
/// Creates a new special "inspector" stylesheet in the frame with given &lt;code&gt;frameId&lt;/code&gt;.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.createStyleSheet</c>
/// </remarks>
internal partial class CSSCreateStyleSheetRequest : IWebkitRequest<CSSCreateStyleSheetResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.createStyleSheet";
/// <summary>
/// Identifier of the frame where the new "inspector" stylesheet should be created.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Response from <see cref="CSSCreateStyleSheetRequest"/>
/// </summary>
internal partial class CSSCreateStyleSheetResponse: IWebkitResponse
{
/// <summary>
/// Identifier of the created "inspector" stylesheet.
/// </summary>
public string StyleSheetId { get; set; }}
/// <summary>
/// Creates a new empty rule with the given &lt;code&gt;selector&lt;/code&gt; in a stylesheet with given &lt;code&gt;styleSheetId&lt;/code&gt;.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.addRule</c>
/// </remarks>
internal partial class CSSAddRuleRequest : IWebkitRequest<CSSAddRuleResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.addRule";
/// <summary>
/// 
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// 
/// </summary>
public string Selector { get; set; }}
/// <summary>
/// Response from <see cref="CSSAddRuleRequest"/>
/// </summary>
internal partial class CSSAddRuleResponse: IWebkitResponse
{
/// <summary>
/// The newly created rule.
/// </summary>
public CSSRule Rule { get; set; }}
/// <summary>
/// Returns all supported CSS property names.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getSupportedCSSProperties</c>
/// </remarks>
internal partial class CSSGetSupportedCSSPropertiesRequest : IWebkitRequest<CSSGetSupportedCSSPropertiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getSupportedCSSProperties";
}
/// <summary>
/// Response from <see cref="CSSGetSupportedCSSPropertiesRequest"/>
/// </summary>
internal partial class CSSGetSupportedCSSPropertiesResponse: IWebkitResponse
{
/// <summary>
/// Supported property metainfo.
/// </summary>
public CSSPropertyInfo[] CssProperties { get; set; }}
/// <summary>
/// Returns all supported system font family names.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getSupportedSystemFontFamilyNames</c>
/// </remarks>
internal partial class CSSGetSupportedSystemFontFamilyNamesRequest : IWebkitRequest<CSSGetSupportedSystemFontFamilyNamesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getSupportedSystemFontFamilyNames";
}
/// <summary>
/// Response from <see cref="CSSGetSupportedSystemFontFamilyNamesRequest"/>
/// </summary>
internal partial class CSSGetSupportedSystemFontFamilyNamesResponse: IWebkitResponse
{
/// <summary>
/// Supported system font families.
/// </summary>
public string[] FontFamilyNames { get; set; }}
/// <summary>
/// Ensures that the given node will have specified pseudo-classes whenever its style is computed by the browser.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.forcePseudoState</c>
/// </remarks>
internal partial class CSSForcePseudoStateRequest : IWebkitRequest<CSSForcePseudoStateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.forcePseudoState";
/// <summary>
/// The element id for which to force the pseudo state.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Element pseudo classes to force when computing the element's style.
/// </summary>
public string[] ForcedPseudoClasses { get; set; }}
/// <summary>
/// Response from <see cref="CSSForcePseudoStateRequest"/>
/// </summary>
internal partial class CSSForcePseudoStateResponse: IWebkitResponse
{
}
/// <summary>
/// Fires whenever a MediaQuery result changes (for example, after a browser window has been resized.) The current implementation considers only viewport-dependent media features.
/// </summary>
/// <remarks>
/// Matches on the event <c>CSS.mediaQueryResultChanged</c>
/// </remarks>
internal partial class CSSMediaQueryResultChangedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "CSS.mediaQueryResultChanged";
}
/// <summary>
/// Fired whenever a stylesheet is changed as a result of the client operation.
/// </summary>
/// <remarks>
/// Matches on the event <c>CSS.styleSheetChanged</c>
/// </remarks>
internal partial class CSSStyleSheetChangedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "CSS.styleSheetChanged";
/// <summary>
/// 
/// </summary>
public string StyleSheetId { get; set; }}
/// <summary>
/// Fired whenever an active document stylesheet is added.
/// </summary>
/// <remarks>
/// Matches on the event <c>CSS.styleSheetAdded</c>
/// </remarks>
internal partial class CSSStyleSheetAddedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "CSS.styleSheetAdded";
/// <summary>
/// Added stylesheet metainfo.
/// </summary>
public CSSStyleSheetHeader Header { get; set; }}
/// <summary>
/// Fired whenever an active document stylesheet is removed.
/// </summary>
/// <remarks>
/// Matches on the event <c>CSS.styleSheetRemoved</c>
/// </remarks>
internal partial class CSSStyleSheetRemovedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "CSS.styleSheetRemoved";
/// <summary>
/// Identifier of the removed stylesheet.
/// </summary>
public string StyleSheetId { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Database
{
/// <summary>
/// Database object.
/// </summary>
internal partial class Database
{
/// <summary>
/// Database ID.
/// </summary>
public string Id { get; set; }
/// <summary>
/// Database domain.
/// </summary>
public string Domain { get; set; }
/// <summary>
/// Database name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Database version.
/// </summary>
public string Version { get; set; }}
/// <summary>
/// Database error.
/// </summary>
internal partial class Error
{
/// <summary>
/// Error message.
/// </summary>
public string Message { get; set; }
/// <summary>
/// Error code.
/// </summary>
public int? Code { get; set; }}
/// <summary>
/// Enables database tracking, database events will now be delivered to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>Database.enable</c>
/// </remarks>
internal partial class DatabaseEnableRequest : IWebkitRequest<DatabaseEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Database.enable";
}
/// <summary>
/// Response from <see cref="DatabaseEnableRequest"/>
/// </summary>
internal partial class DatabaseEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables database tracking, prevents database events from being sent to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>Database.disable</c>
/// </remarks>
internal partial class DatabaseDisableRequest : IWebkitRequest<DatabaseDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Database.disable";
}
/// <summary>
/// Response from <see cref="DatabaseDisableRequest"/>
/// </summary>
internal partial class DatabaseDisableResponse: IWebkitResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Database.getDatabaseTableNames</c>
/// </remarks>
internal partial class DatabaseGetDatabaseTableNamesRequest : IWebkitRequest<DatabaseGetDatabaseTableNamesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Database.getDatabaseTableNames";
/// <summary>
/// 
/// </summary>
public string DatabaseId { get; set; }}
/// <summary>
/// Response from <see cref="DatabaseGetDatabaseTableNamesRequest"/>
/// </summary>
internal partial class DatabaseGetDatabaseTableNamesResponse: IWebkitResponse
{
/// <summary>
/// 
/// </summary>
public string[] TableNames { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Database.executeSQL</c>
/// </remarks>
internal partial class DatabaseExecuteSQLRequest : IWebkitRequest<DatabaseExecuteSQLResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Database.executeSQL";
/// <summary>
/// 
/// </summary>
public string DatabaseId { get; set; }
/// <summary>
/// 
/// </summary>
public string Query { get; set; }}
/// <summary>
/// Response from <see cref="DatabaseExecuteSQLRequest"/>
/// </summary>
internal partial class DatabaseExecuteSQLResponse: IWebkitResponse
{
/// <summary>
/// 
/// </summary>
public string[] ColumnNames { get; set; }
/// <summary>
/// 
/// </summary>
public JsonElement?[] Values { get; set; }
/// <summary>
/// 
/// </summary>
public Error SqlError { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Database.addDatabase</c>
/// </remarks>
internal partial class DatabaseAddDatabaseWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Database.addDatabase";
/// <summary>
/// 
/// </summary>
public Database Database { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Debugger
{
/// <summary>
/// Location in the source code.
/// </summary>
internal partial class Location
{
/// <summary>
/// Script identifier as reported in the &lt;code&gt;Debugger.scriptParsed&lt;/code&gt;.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// Line number in the script (0-based).
/// </summary>
public int? LineNumber { get; set; }
/// <summary>
/// Column number in the script (0-based).
/// </summary>
public int? ColumnNumber { get; set; }}
/// <summary>
/// Action to perform when a breakpoint is triggered.
/// </summary>
internal partial class BreakpointAction
{
/// <summary>
/// Different kinds of breakpoint actions.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Data associated with this breakpoint type (e.g. for type "eval" this is the JavaScript string to evaluate).
/// </summary>
public string Data { get; set; }
/// <summary>
/// A frontend-assigned identifier for this breakpoint action.
/// </summary>
public int? Id { get; set; }}
/// <summary>
/// Extra options that modify breakpoint behavior.
/// </summary>
internal partial class BreakpointOptions
{
/// <summary>
/// Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
/// </summary>
public string Condition { get; set; }
/// <summary>
/// Actions to perform automatically when the breakpoint is triggered.
/// </summary>
public BreakpointAction[] Actions { get; set; }
/// <summary>
/// Automatically continue after hitting this breakpoint and running actions.
/// </summary>
public bool? AutoContinue { get; set; }
/// <summary>
/// Number of times to ignore this breakpoint, before stopping on the breakpoint and running actions.
/// </summary>
public int? IgnoreCount { get; set; }}
/// <summary>
/// Information about the function.
/// </summary>
internal partial class FunctionDetails
{
/// <summary>
/// Location of the function.
/// </summary>
public Location Location { get; set; }
/// <summary>
/// Name of the function. Not present for anonymous functions.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Display name of the function(specified in 'displayName' property on the function object).
/// </summary>
public string DisplayName { get; set; }
/// <summary>
/// Scope chain for this closure.
/// </summary>
public Scope[] ScopeChain { get; set; }}
/// <summary>
/// JavaScript call frame. Array of call frames form the call stack.
/// </summary>
internal partial class CallFrame
{
/// <summary>
/// Call frame identifier. This identifier is only valid while the virtual machine is paused.
/// </summary>
public string CallFrameId { get; set; }
/// <summary>
/// Name of the JavaScript function called on this call frame.
/// </summary>
public string FunctionName { get; set; }
/// <summary>
/// Location in the source code.
/// </summary>
public Location Location { get; set; }
/// <summary>
/// Scope chain for this call frame.
/// </summary>
public Scope[] ScopeChain { get; set; }
/// <summary>
/// &lt;code&gt;this&lt;/code&gt; object for this call frame.
/// </summary>
public Runtime.RemoteObject This { get; set; }
/// <summary>
/// Is the current frame tail deleted from a tail call.
/// </summary>
public bool? IsTailDeleted { get; set; }}
/// <summary>
/// Scope description.
/// </summary>
internal partial class Scope
{
/// <summary>
/// Object representing the scope. For &lt;code&gt;global&lt;/code&gt; and &lt;code&gt;with&lt;/code&gt; scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties.
/// </summary>
public Runtime.RemoteObject Object { get; set; }
/// <summary>
/// Scope type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Name associated with the scope.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Location if available of the scope definition.
/// </summary>
public Location Location { get; set; }
/// <summary>
/// Whether the scope has any variables.
/// </summary>
public bool? Empty { get; set; }}
/// <summary>
/// A sample collected by evaluating a probe breakpoint action.
/// </summary>
internal partial class ProbeSample
{
/// <summary>
/// Identifier of the probe breakpoint action that created the sample.
/// </summary>
public int? ProbeId { get; set; }
/// <summary>
/// Unique identifier for this sample.
/// </summary>
public int? SampleId { get; set; }
/// <summary>
/// A batch identifier which is the same for all samples taken at the same breakpoint hit.
/// </summary>
public int? BatchId { get; set; }
/// <summary>
/// Timestamp of when the sample was taken.
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// Contents of the sample.
/// </summary>
public Runtime.RemoteObject Payload { get; set; }}
/// <summary>
/// The pause reason auxiliary data when paused because of an assertion.
/// </summary>
internal partial class AssertPauseReason
{
/// <summary>
/// The console.assert message string if provided.
/// </summary>
public string Message { get; set; }}
/// <summary>
/// The pause reason auxiliary data when paused because of hitting a breakpoint.
/// </summary>
internal partial class BreakpointPauseReason
{
/// <summary>
/// The identifier of the breakpoint causing the pause.
/// </summary>
public string BreakpointId { get; set; }}
/// <summary>
/// The pause reason auxiliary data when paused because of a Content Security Policy directive.
/// </summary>
internal partial class CSPViolationPauseReason
{
/// <summary>
/// The CSP directive that blocked script execution.
/// </summary>
public string Directive { get; set; }}
/// <summary>
/// Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.enable</c>
/// </remarks>
internal partial class DebuggerEnableRequest : IWebkitRequest<DebuggerEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.enable";
}
/// <summary>
/// Response from <see cref="DebuggerEnableRequest"/>
/// </summary>
internal partial class DebuggerEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables debugger for given page.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.disable</c>
/// </remarks>
internal partial class DebuggerDisableRequest : IWebkitRequest<DebuggerDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.disable";
}
/// <summary>
/// Response from <see cref="DebuggerDisableRequest"/>
/// </summary>
internal partial class DebuggerDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Set the async stack trace depth for the page. A value of zero disables recording of async stack traces.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setAsyncStackTraceDepth</c>
/// </remarks>
internal partial class DebuggerSetAsyncStackTraceDepthRequest : IWebkitRequest<DebuggerSetAsyncStackTraceDepthResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setAsyncStackTraceDepth";
/// <summary>
/// Async stack trace depth.
/// </summary>
public int? Depth { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetAsyncStackTraceDepthRequest"/>
/// </summary>
internal partial class DebuggerSetAsyncStackTraceDepthResponse: IWebkitResponse
{
}
/// <summary>
/// Activates / deactivates all breakpoints on the page.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setBreakpointsActive</c>
/// </remarks>
internal partial class DebuggerSetBreakpointsActiveRequest : IWebkitRequest<DebuggerSetBreakpointsActiveResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setBreakpointsActive";
/// <summary>
/// New value for breakpoints active state.
/// </summary>
public bool? Active { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetBreakpointsActiveRequest"/>
/// </summary>
internal partial class DebuggerSetBreakpointsActiveResponse: IWebkitResponse
{
}
/// <summary>
/// Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in &lt;code&gt;locations&lt;/code&gt; property. Further matching script parsing will result in subsequent &lt;code&gt;breakpointResolved&lt;/code&gt; events issued. This logical breakpoint will survive page reloads.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setBreakpointByUrl</c>
/// </remarks>
internal partial class DebuggerSetBreakpointByUrlRequest : IWebkitRequest<DebuggerSetBreakpointByUrlResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setBreakpointByUrl";
/// <summary>
/// Line number to set breakpoint at.
/// </summary>
public int? LineNumber { get; set; }
/// <summary>
/// URL of the resources to set breakpoint on.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Regex pattern for the URLs of the resources to set breakpoints on. Either &lt;code&gt;url&lt;/code&gt; or &lt;code&gt;urlRegex&lt;/code&gt; must be specified.
/// </summary>
public string UrlRegex { get; set; }
/// <summary>
/// Offset in the line to set breakpoint at.
/// </summary>
public int? ColumnNumber { get; set; }
/// <summary>
/// Options to apply to this breakpoint to modify its behavior.
/// </summary>
public BreakpointOptions Options { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetBreakpointByUrlRequest"/>
/// </summary>
internal partial class DebuggerSetBreakpointByUrlResponse: IWebkitResponse
{
/// <summary>
/// Id of the created breakpoint for further reference.
/// </summary>
public string BreakpointId { get; set; }
/// <summary>
/// List of the locations this breakpoint resolved into upon addition.
/// </summary>
public Location[] Locations { get; set; }}
/// <summary>
/// Sets JavaScript breakpoint at a given location.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setBreakpoint</c>
/// </remarks>
internal partial class DebuggerSetBreakpointRequest : IWebkitRequest<DebuggerSetBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setBreakpoint";
/// <summary>
/// Location to set breakpoint in.
/// </summary>
public Location Location { get; set; }
/// <summary>
/// Options to apply to this breakpoint to modify its behavior.
/// </summary>
public BreakpointOptions Options { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetBreakpointRequest"/>
/// </summary>
internal partial class DebuggerSetBreakpointResponse: IWebkitResponse
{
/// <summary>
/// Id of the created breakpoint for further reference.
/// </summary>
public string BreakpointId { get; set; }
/// <summary>
/// Location this breakpoint resolved into.
/// </summary>
public Location ActualLocation { get; set; }}
/// <summary>
/// Removes JavaScript breakpoint.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.removeBreakpoint</c>
/// </remarks>
internal partial class DebuggerRemoveBreakpointRequest : IWebkitRequest<DebuggerRemoveBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.removeBreakpoint";
/// <summary>
/// 
/// </summary>
public string BreakpointId { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerRemoveBreakpointRequest"/>
/// </summary>
internal partial class DebuggerRemoveBreakpointResponse: IWebkitResponse
{
}
/// <summary>
/// Continues execution until the current evaluation completes. This will trigger either a Debugger.paused or Debugger.resumed event.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.continueUntilNextRunLoop</c>
/// </remarks>
internal partial class DebuggerContinueUntilNextRunLoopRequest : IWebkitRequest<DebuggerContinueUntilNextRunLoopResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.continueUntilNextRunLoop";
}
/// <summary>
/// Response from <see cref="DebuggerContinueUntilNextRunLoopRequest"/>
/// </summary>
internal partial class DebuggerContinueUntilNextRunLoopResponse: IWebkitResponse
{
}
/// <summary>
/// Continues execution until specific location is reached. This will trigger either a Debugger.paused or Debugger.resumed event.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.continueToLocation</c>
/// </remarks>
internal partial class DebuggerContinueToLocationRequest : IWebkitRequest<DebuggerContinueToLocationResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.continueToLocation";
/// <summary>
/// Location to continue to.
/// </summary>
public Location Location { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerContinueToLocationRequest"/>
/// </summary>
internal partial class DebuggerContinueToLocationResponse: IWebkitResponse
{
}
/// <summary>
/// Steps over the statement. This will trigger either a Debugger.paused or Debugger.resumed event.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.stepOver</c>
/// </remarks>
internal partial class DebuggerStepOverRequest : IWebkitRequest<DebuggerStepOverResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.stepOver";
}
/// <summary>
/// Response from <see cref="DebuggerStepOverRequest"/>
/// </summary>
internal partial class DebuggerStepOverResponse: IWebkitResponse
{
}
/// <summary>
/// Steps into the function call. This will trigger either a Debugger.paused or Debugger.resumed event.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.stepInto</c>
/// </remarks>
internal partial class DebuggerStepIntoRequest : IWebkitRequest<DebuggerStepIntoResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.stepInto";
}
/// <summary>
/// Response from <see cref="DebuggerStepIntoRequest"/>
/// </summary>
internal partial class DebuggerStepIntoResponse: IWebkitResponse
{
}
/// <summary>
/// Steps out of the function call. This will trigger either a Debugger.paused or Debugger.resumed event.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.stepOut</c>
/// </remarks>
internal partial class DebuggerStepOutRequest : IWebkitRequest<DebuggerStepOutResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.stepOut";
}
/// <summary>
/// Response from <see cref="DebuggerStepOutRequest"/>
/// </summary>
internal partial class DebuggerStepOutResponse: IWebkitResponse
{
}
/// <summary>
/// Stops on the next JavaScript statement.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.pause</c>
/// </remarks>
internal partial class DebuggerPauseRequest : IWebkitRequest<DebuggerPauseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.pause";
}
/// <summary>
/// Response from <see cref="DebuggerPauseRequest"/>
/// </summary>
internal partial class DebuggerPauseResponse: IWebkitResponse
{
}
/// <summary>
/// Resumes JavaScript execution. This will trigger a Debugger.resumed event.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.resume</c>
/// </remarks>
internal partial class DebuggerResumeRequest : IWebkitRequest<DebuggerResumeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.resume";
}
/// <summary>
/// Response from <see cref="DebuggerResumeRequest"/>
/// </summary>
internal partial class DebuggerResumeResponse: IWebkitResponse
{
}
/// <summary>
/// Searches for given string in script content.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.searchInContent</c>
/// </remarks>
internal partial class DebuggerSearchInContentRequest : IWebkitRequest<DebuggerSearchInContentResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.searchInContent";
/// <summary>
/// Id of the script to search in.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// String to search for.
/// </summary>
public string Query { get; set; }
/// <summary>
/// If true, search is case sensitive.
/// </summary>
public bool? CaseSensitive { get; set; }
/// <summary>
/// If true, treats string parameter as regex.
/// </summary>
public bool? IsRegex { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSearchInContentRequest"/>
/// </summary>
internal partial class DebuggerSearchInContentResponse: IWebkitResponse
{
/// <summary>
/// List of search matches.
/// </summary>
public GenericTypes.SearchMatch[] Result { get; set; }}
/// <summary>
/// Returns source for the script with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.getScriptSource</c>
/// </remarks>
internal partial class DebuggerGetScriptSourceRequest : IWebkitRequest<DebuggerGetScriptSourceResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.getScriptSource";
/// <summary>
/// Id of the script to get source for.
/// </summary>
public string ScriptId { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerGetScriptSourceRequest"/>
/// </summary>
internal partial class DebuggerGetScriptSourceResponse: IWebkitResponse
{
/// <summary>
/// Script source.
/// </summary>
public string ScriptSource { get; set; }}
/// <summary>
/// Returns detailed information on given function.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.getFunctionDetails</c>
/// </remarks>
internal partial class DebuggerGetFunctionDetailsRequest : IWebkitRequest<DebuggerGetFunctionDetailsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.getFunctionDetails";
/// <summary>
/// Id of the function to get location for.
/// </summary>
public string FunctionId { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerGetFunctionDetailsRequest"/>
/// </summary>
internal partial class DebuggerGetFunctionDetailsResponse: IWebkitResponse
{
/// <summary>
/// Information about the function.
/// </summary>
public FunctionDetails Details { get; set; }}
/// <summary>
/// Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is &lt;code&gt;none&lt;/code&gt;.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setPauseOnExceptions</c>
/// </remarks>
internal partial class DebuggerSetPauseOnExceptionsRequest : IWebkitRequest<DebuggerSetPauseOnExceptionsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setPauseOnExceptions";
/// <summary>
/// Pause on exceptions mode.
/// </summary>
public string State { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetPauseOnExceptionsRequest"/>
/// </summary>
internal partial class DebuggerSetPauseOnExceptionsResponse: IWebkitResponse
{
}
/// <summary>
/// Set pause on assertions state. Assertions are console.assert assertions.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setPauseOnAssertions</c>
/// </remarks>
internal partial class DebuggerSetPauseOnAssertionsRequest : IWebkitRequest<DebuggerSetPauseOnAssertionsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setPauseOnAssertions";
/// <summary>
/// 
/// </summary>
public bool? Enabled { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetPauseOnAssertionsRequest"/>
/// </summary>
internal partial class DebuggerSetPauseOnAssertionsResponse: IWebkitResponse
{
}
/// <summary>
/// Pause when running the next JavaScript microtask.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setPauseOnMicrotasks</c>
/// </remarks>
internal partial class DebuggerSetPauseOnMicrotasksRequest : IWebkitRequest<DebuggerSetPauseOnMicrotasksResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setPauseOnMicrotasks";
/// <summary>
/// 
/// </summary>
public bool? Enabled { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetPauseOnMicrotasksRequest"/>
/// </summary>
internal partial class DebuggerSetPauseOnMicrotasksResponse: IWebkitResponse
{
}
/// <summary>
/// Change whether to pause in the debugger for internal scripts. The default value is false.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setPauseForInternalScripts</c>
/// </remarks>
internal partial class DebuggerSetPauseForInternalScriptsRequest : IWebkitRequest<DebuggerSetPauseForInternalScriptsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setPauseForInternalScripts";
/// <summary>
/// 
/// </summary>
public bool? ShouldPause { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetPauseForInternalScriptsRequest"/>
/// </summary>
internal partial class DebuggerSetPauseForInternalScriptsResponse: IWebkitResponse
{
}
/// <summary>
/// Evaluates expression on a given call frame.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.evaluateOnCallFrame</c>
/// </remarks>
internal partial class DebuggerEvaluateOnCallFrameRequest : IWebkitRequest<DebuggerEvaluateOnCallFrameResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.evaluateOnCallFrame";
/// <summary>
/// Call frame identifier to evaluate on.
/// </summary>
public string CallFrameId { get; set; }
/// <summary>
/// Expression to evaluate.
/// </summary>
public string Expression { get; set; }
/// <summary>
/// String object group name to put result into (allows rapid releasing resulting object handles using &lt;code&gt;releaseObjectGroup&lt;/code&gt;).
/// </summary>
public string ObjectGroup { get; set; }
/// <summary>
/// Specifies whether command line API should be available to the evaluated expression, defaults to false.
/// </summary>
public bool? IncludeCommandLineAPI { get; set; }
/// <summary>
/// Specifies whether evaluation should stop on exceptions and mute console. Overrides setPauseOnException state.
/// </summary>
public bool? DoNotPauseOnExceptionsAndMuteConsole { get; set; }
/// <summary>
/// Whether the result is expected to be a JSON object that should be sent by value.
/// </summary>
public bool? ReturnByValue { get; set; }
/// <summary>
/// Whether preview should be generated for the result.
/// </summary>
public bool? GeneratePreview { get; set; }
/// <summary>
/// Whether the resulting value should be considered for saving in the $n history.
/// </summary>
public bool? SaveResult { get; set; }
/// <summary>
/// Whether the expression should be considered to be in a user gesture or not.
/// </summary>
public bool? EmulateUserGesture { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerEvaluateOnCallFrameRequest"/>
/// </summary>
internal partial class DebuggerEvaluateOnCallFrameResponse: IWebkitResponse
{
/// <summary>
/// Object wrapper for the evaluation result.
/// </summary>
public Runtime.RemoteObject Result { get; set; }
/// <summary>
/// True if the result was thrown during the evaluation.
/// </summary>
public bool? WasThrown { get; set; }
/// <summary>
/// If the result was saved, this is the $n index that can be used to access the value.
/// </summary>
public int? SavedResultIndex { get; set; }}
/// <summary>
/// Sets whether the given URL should be in the list of blackboxed scripts, which are ignored when pausing/stepping/debugging.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setShouldBlackboxURL</c>
/// </remarks>
internal partial class DebuggerSetShouldBlackboxURLRequest : IWebkitRequest<DebuggerSetShouldBlackboxURLResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setShouldBlackboxURL";
/// <summary>
/// 
/// </summary>
public string Url { get; set; }
/// <summary>
/// 
/// </summary>
public bool? ShouldBlackbox { get; set; }
/// <summary>
/// If true, &lt;code&gt;url&lt;/code&gt; is case sensitive.
/// </summary>
public bool? CaseSensitive { get; set; }
/// <summary>
/// If true, treat &lt;code&gt;url&lt;/code&gt; as regular expression.
/// </summary>
public bool? IsRegex { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetShouldBlackboxURLRequest"/>
/// </summary>
internal partial class DebuggerSetShouldBlackboxURLResponse: IWebkitResponse
{
}
/// <summary>
/// Called when global has been cleared and debugger client should reset its state. Happens upon navigation or reload.
/// </summary>
/// <remarks>
/// Matches on the event <c>Debugger.globalObjectCleared</c>
/// </remarks>
internal partial class DebuggerGlobalObjectClearedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Debugger.globalObjectCleared";
}
/// <summary>
/// Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
/// </summary>
/// <remarks>
/// Matches on the event <c>Debugger.scriptParsed</c>
/// </remarks>
internal partial class DebuggerScriptParsedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Debugger.scriptParsed";
/// <summary>
/// Identifier of the script parsed.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// URL of the script parsed (if any).
/// </summary>
public string Url { get; set; }
/// <summary>
/// Line offset of the script within the resource with given URL (for script tags).
/// </summary>
public int? StartLine { get; set; }
/// <summary>
/// Column offset of the script within the resource with given URL.
/// </summary>
public int? StartColumn { get; set; }
/// <summary>
/// Last line of the script.
/// </summary>
public int? EndLine { get; set; }
/// <summary>
/// Length of the last line of the script.
/// </summary>
public int? EndColumn { get; set; }
/// <summary>
/// Determines whether this script is a user extension script.
/// </summary>
public bool? IsContentScript { get; set; }
/// <summary>
/// sourceURL name of the script (if any).
/// </summary>
public string SourceURL { get; set; }
/// <summary>
/// URL of source map associated with script (if any).
/// </summary>
public string SourceMapURL { get; set; }
/// <summary>
/// True if this script was parsed as a module.
/// </summary>
public bool? Module { get; set; }}
/// <summary>
/// Fired when virtual machine fails to parse the script.
/// </summary>
/// <remarks>
/// Matches on the event <c>Debugger.scriptFailedToParse</c>
/// </remarks>
internal partial class DebuggerScriptFailedToParseWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Debugger.scriptFailedToParse";
/// <summary>
/// URL of the script that failed to parse.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Source text of the script that failed to parse.
/// </summary>
public string ScriptSource { get; set; }
/// <summary>
/// Line offset of the script within the resource.
/// </summary>
public int? StartLine { get; set; }
/// <summary>
/// Line with error.
/// </summary>
public int? ErrorLine { get; set; }
/// <summary>
/// Parse error message.
/// </summary>
public string ErrorMessage { get; set; }}
/// <summary>
/// Fired when breakpoint is resolved to an actual script and location.
/// </summary>
/// <remarks>
/// Matches on the event <c>Debugger.breakpointResolved</c>
/// </remarks>
internal partial class DebuggerBreakpointResolvedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Debugger.breakpointResolved";
/// <summary>
/// Breakpoint unique identifier.
/// </summary>
public string BreakpointId { get; set; }
/// <summary>
/// Actual breakpoint location.
/// </summary>
public Location Location { get; set; }}
/// <summary>
/// Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
/// </summary>
/// <remarks>
/// Matches on the event <c>Debugger.paused</c>
/// </remarks>
internal partial class DebuggerPausedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Debugger.paused";
/// <summary>
/// Call stack the virtual machine stopped on.
/// </summary>
public CallFrame[] CallFrames { get; set; }
/// <summary>
/// Pause reason.
/// </summary>
public string Reason { get; set; }
/// <summary>
/// Object containing break-specific auxiliary properties.
/// </summary>
public object Data { get; set; }
/// <summary>
/// Linked list of asynchronous StackTraces.
/// </summary>
public Console.StackTrace AsyncStackTrace { get; set; }}
/// <summary>
/// Fired when the virtual machine resumed execution.
/// </summary>
/// <remarks>
/// Matches on the event <c>Debugger.resumed</c>
/// </remarks>
internal partial class DebuggerResumedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Debugger.resumed";
}
/// <summary>
/// Fires when a new probe sample is collected.
/// </summary>
/// <remarks>
/// Matches on the event <c>Debugger.didSampleProbe</c>
/// </remarks>
internal partial class DebuggerDidSampleProbeWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Debugger.didSampleProbe";
/// <summary>
/// A collected probe sample.
/// </summary>
public ProbeSample Sample { get; set; }}
/// <summary>
/// Fired when a "sound" breakpoint action is triggered on a breakpoint.
/// </summary>
/// <remarks>
/// Matches on the event <c>Debugger.playBreakpointActionSound</c>
/// </remarks>
internal partial class DebuggerPlayBreakpointActionSoundWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Debugger.playBreakpointActionSound";
/// <summary>
/// Breakpoint action identifier.
/// </summary>
public int? BreakpointActionId { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Dialog
{
/// <summary>
/// Enables dialog domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Dialog.enable</c>
/// </remarks>
internal partial class DialogEnableRequest : IWebkitRequest<DialogEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Dialog.enable";
}
/// <summary>
/// Response from <see cref="DialogEnableRequest"/>
/// </summary>
internal partial class DialogEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables dialog domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Dialog.disable</c>
/// </remarks>
internal partial class DialogDisableRequest : IWebkitRequest<DialogDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Dialog.disable";
}
/// <summary>
/// Response from <see cref="DialogDisableRequest"/>
/// </summary>
internal partial class DialogDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
/// </summary>
/// <remarks>
/// Will send the command <c>Dialog.handleJavaScriptDialog</c>
/// </remarks>
internal partial class DialogHandleJavaScriptDialogRequest : IWebkitRequest<DialogHandleJavaScriptDialogResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Dialog.handleJavaScriptDialog";
/// <summary>
/// Whether to accept or dismiss the dialog.
/// </summary>
public bool? Accept { get; set; }
/// <summary>
/// The text to enter into the dialog prompt before accepting. Used only if this is a prompt dialog.
/// </summary>
public string PromptText { get; set; }}
/// <summary>
/// Response from <see cref="DialogHandleJavaScriptDialogRequest"/>
/// </summary>
internal partial class DialogHandleJavaScriptDialogResponse: IWebkitResponse
{
}
/// <summary>
/// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to open.
/// </summary>
/// <remarks>
/// Matches on the event <c>Dialog.javascriptDialogOpening</c>
/// </remarks>
internal partial class DialogJavascriptDialogOpeningWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Dialog.javascriptDialogOpening";
/// <summary>
/// Dialog type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Message that will be displayed by the dialog.
/// </summary>
public string Message { get; set; }
/// <summary>
/// Default dialog prompt.
/// </summary>
public string DefaultPrompt { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.DOM
{
/// <summary>
/// Pseudo element type.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum PseudoType
{
[System.Runtime.Serialization.EnumMember(Value = "before")]Before,
[System.Runtime.Serialization.EnumMember(Value = "after")]After}
/// <summary>
/// Shadow root type.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum ShadowRootType
{
[System.Runtime.Serialization.EnumMember(Value = "user-agent")]UserAgent,
[System.Runtime.Serialization.EnumMember(Value = "open")]Open,
[System.Runtime.Serialization.EnumMember(Value = "closed")]Closed}
/// <summary>
/// Custom element state.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum CustomElementState
{
[System.Runtime.Serialization.EnumMember(Value = "builtin")]Builtin,
[System.Runtime.Serialization.EnumMember(Value = "custom")]Custom,
[System.Runtime.Serialization.EnumMember(Value = "waiting")]Waiting,
[System.Runtime.Serialization.EnumMember(Value = "failed")]Failed}
/// <summary>
/// Token values of @aria-relevant attribute.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum LiveRegionRelevant
{
[System.Runtime.Serialization.EnumMember(Value = "additions")]Additions,
[System.Runtime.Serialization.EnumMember(Value = "removals")]Removals,
[System.Runtime.Serialization.EnumMember(Value = "text")]Text}
/// <summary>
/// DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type.
/// </summary>
internal partial class Node
{
/// <summary>
/// Node identifier that is passed into the rest of the DOM messages as the &lt;code&gt;nodeId&lt;/code&gt;. Backend will only push node with given &lt;code&gt;id&lt;/code&gt; once. It is aware of all requested nodes and will only fire DOM events for nodes known to the client.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// &lt;code&gt;Node&lt;/code&gt;'s nodeType.
/// </summary>
public int? NodeType { get; set; }
/// <summary>
/// &lt;code&gt;Node&lt;/code&gt;'s nodeName.
/// </summary>
public string NodeName { get; set; }
/// <summary>
/// &lt;code&gt;Node&lt;/code&gt;'s localName.
/// </summary>
public string LocalName { get; set; }
/// <summary>
/// &lt;code&gt;Node&lt;/code&gt;'s nodeValue.
/// </summary>
public string NodeValue { get; set; }
/// <summary>
/// Identifier of the containing frame.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Child count for &lt;code&gt;Container&lt;/code&gt; nodes.
/// </summary>
public int? ChildNodeCount { get; set; }
/// <summary>
/// Child nodes of this node when requested with children.
/// </summary>
public Node[] Children { get; set; }
/// <summary>
/// Attributes of the &lt;code&gt;Element&lt;/code&gt; node in the form of flat array &lt;code&gt;[name1, value1, name2, value2]&lt;/code&gt;.
/// </summary>
public string[] Attributes { get; set; }
/// <summary>
/// Document URL that &lt;code&gt;Document&lt;/code&gt; or &lt;code&gt;FrameOwner&lt;/code&gt; node points to.
/// </summary>
public string DocumentURL { get; set; }
/// <summary>
/// Base URL that &lt;code&gt;Document&lt;/code&gt; or &lt;code&gt;FrameOwner&lt;/code&gt; node uses for URL completion.
/// </summary>
public string BaseURL { get; set; }
/// <summary>
/// &lt;code&gt;DocumentType&lt;/code&gt;'s publicId.
/// </summary>
public string PublicId { get; set; }
/// <summary>
/// &lt;code&gt;DocumentType&lt;/code&gt;'s systemId.
/// </summary>
public string SystemId { get; set; }
/// <summary>
/// &lt;code&gt;Document&lt;/code&gt;'s XML version in case of XML documents.
/// </summary>
public string XmlVersion { get; set; }
/// <summary>
/// &lt;code&gt;Attr&lt;/code&gt;'s name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// &lt;code&gt;Attr&lt;/code&gt;'s value.
/// </summary>
public string Value { get; set; }
/// <summary>
/// Pseudo element type for this node.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public PseudoType PseudoType { get; set; }
/// <summary>
/// Shadow root type.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public ShadowRootType ShadowRootType { get; set; }
/// <summary>
/// Custom element state.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public CustomElementState CustomElementState { get; set; }
/// <summary>
/// Content document for frame owner elements.
/// </summary>
public Node ContentDocument { get; set; }
/// <summary>
/// Shadow root list for given element host.
/// </summary>
public Node[] ShadowRoots { get; set; }
/// <summary>
/// Content document fragment for template elements
/// </summary>
public Node TemplateContent { get; set; }
/// <summary>
/// Pseudo elements associated with this node.
/// </summary>
public Node[] PseudoElements { get; set; }
/// <summary>
/// Computed SHA-256 Content Security Policy hash source for given element.
/// </summary>
public string ContentSecurityPolicyHash { get; set; }}
/// <summary>
/// Relationship between data that is associated with a node and the node itself.
/// </summary>
internal partial class DataBinding
{
/// <summary>
/// The binding key that is specified.
/// </summary>
public string Binding { get; set; }
/// <summary>
/// A more descriptive name for the type of binding that represents this paritcular data relationship
/// </summary>
public string Type { get; set; }
/// <summary>
/// The value that is resolved to with this data binding relationship.
/// </summary>
public string Value { get; set; }}
/// <summary>
/// A structure holding event listener properties.
/// </summary>
internal partial class EventListener
{
/// <summary>
/// 
/// </summary>
public int? EventListenerId { get; set; }
/// <summary>
/// &lt;code&gt;EventListener&lt;/code&gt;'s type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// &lt;code&gt;EventListener&lt;/code&gt;'s useCapture.
/// </summary>
public bool? UseCapture { get; set; }
/// <summary>
/// &lt;code&gt;EventListener&lt;/code&gt;'s isAttribute.
/// </summary>
public bool? IsAttribute { get; set; }
/// <summary>
/// The target &lt;code&gt;DOMNode&lt;/code&gt; id if the event listener is for a node.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// True if the event listener was added to the window.
/// </summary>
public bool? OnWindow { get; set; }
/// <summary>
/// Handler code location.
/// </summary>
public Debugger.Location Location { get; set; }
/// <summary>
/// Event handler function name.
/// </summary>
public string HandlerName { get; set; }
/// <summary>
/// &lt;code&gt;EventListener&lt;/code&gt;'s passive.
/// </summary>
public bool? Passive { get; set; }
/// <summary>
/// &lt;code&gt;EventListener&lt;/code&gt;'s once.
/// </summary>
public bool? Once { get; set; }
/// <summary>
/// 
/// </summary>
public bool? Disabled { get; set; }
/// <summary>
/// 
/// </summary>
public bool? HasBreakpoint { get; set; }}
/// <summary>
/// A structure holding accessibility properties.
/// </summary>
internal partial class AccessibilityProperties
{
/// <summary>
/// &lt;code&gt;DOMNode&lt;/code&gt; id of the accessibility object referenced by aria-activedescendant.
/// </summary>
public int? ActiveDescendantNodeId { get; set; }
/// <summary>
/// Value of @aria-busy on current or ancestor node.
/// </summary>
public bool? Busy { get; set; }
/// <summary>
/// Checked state of certain form controls.
/// </summary>
public string Checked { get; set; }
/// <summary>
/// Array of &lt;code&gt;DOMNode&lt;/code&gt; ids of the accessibility tree children if available.
/// </summary>
public int?[] ChildNodeIds { get; set; }
/// <summary>
/// Array of &lt;code&gt;DOMNode&lt;/code&gt; ids of any nodes referenced via @aria-controls.
/// </summary>
public int?[] ControlledNodeIds { get; set; }
/// <summary>
/// Current item within a container or set of related elements.
/// </summary>
public string Current { get; set; }
/// <summary>
/// Disabled state of form controls.
/// </summary>
public bool? Disabled { get; set; }
/// <summary>
/// Heading level of a heading element.
/// </summary>
public double? HeadingLevel { get; set; }
/// <summary>
/// The hierarchical level of an element.
/// </summary>
public double? HierarchyLevel { get; set; }
/// <summary>
/// Whether an element is a popup button.
/// </summary>
public bool? IsPopUpButton { get; set; }
/// <summary>
/// Indicates whether there is an existing AX object for the DOM node. If this is false, all the other properties will be default values.
/// </summary>
public bool? Exists { get; set; }
/// <summary>
/// Expanded state.
/// </summary>
public bool? Expanded { get; set; }
/// <summary>
/// Array of &lt;code&gt;DOMNode&lt;/code&gt; ids of any nodes referenced via @aria-flowto.
/// </summary>
public int?[] FlowedNodeIds { get; set; }
/// <summary>
/// Focused state. Only defined on focusable elements.
/// </summary>
public bool? Focused { get; set; }
/// <summary>
/// Indicates whether the accessibility of the associated AX object node is ignored, whether heuristically or explicitly.
/// </summary>
public bool? Ignored { get; set; }
/// <summary>
/// State indicating whether the accessibility of the associated AX object node is ignored by default for node type.
/// </summary>
public bool? IgnoredByDefault { get; set; }
/// <summary>
/// Invalid status of form controls.
/// </summary>
public string Invalid { get; set; }
/// <summary>
/// Hidden state. True if node or an ancestor is hidden via CSS or explicit @aria-hidden, to clarify why the element is ignored.
/// </summary>
public bool? Hidden { get; set; }
/// <summary>
/// Computed label value for the node, sometimes calculated by referencing other nodes.
/// </summary>
public string Label { get; set; }
/// <summary>
/// Value of @aria-atomic.
/// </summary>
public bool? LiveRegionAtomic { get; set; }
/// <summary>
/// Token value(s) of element's @aria-relevant attribute. Array of string values matching $ref LiveRegionRelevant. FIXME: Enum values blocked by http://webkit.org/b/133711
/// </summary>
public string[] LiveRegionRelevant { get; set; }
/// <summary>
/// Value of element's @aria-live attribute.
/// </summary>
public string LiveRegionStatus { get; set; }
/// <summary>
/// &lt;code&gt;DOMNode&lt;/code&gt; id of node or closest ancestor node that has a mousedown, mouseup, or click event handler.
/// </summary>
public int? MouseEventNodeId { get; set; }
/// <summary>
/// Target &lt;code&gt;DOMNode&lt;/code&gt; id.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Array of &lt;code&gt;DOMNode&lt;/code&gt; ids of any nodes referenced via @aria-owns.
/// </summary>
public int?[] OwnedNodeIds { get; set; }
/// <summary>
/// &lt;code&gt;DOMNode&lt;/code&gt; id of the accessibility tree parent object if available.
/// </summary>
public int? ParentNodeId { get; set; }
/// <summary>
/// Pressed state for toggle buttons.
/// </summary>
public bool? Pressed { get; set; }
/// <summary>
/// Readonly state of text controls.
/// </summary>
public bool? Readonly { get; set; }
/// <summary>
/// Required state of form controls.
/// </summary>
public bool? Required { get; set; }
/// <summary>
/// Computed value for first recognized role token, default role per element, or overridden role.
/// </summary>
public string Role { get; set; }
/// <summary>
/// Selected state of certain form controls.
/// </summary>
public bool? Selected { get; set; }
/// <summary>
/// Array of &lt;code&gt;DOMNode&lt;/code&gt; ids of any children marked as selected.
/// </summary>
public int?[] SelectedChildNodeIds { get; set; }}
/// <summary>
/// A structure holding an RGBA color.
/// </summary>
internal partial class RGBAColor
{
/// <summary>
/// The red component, in the [0-255] range.
/// </summary>
public int? R { get; set; }
/// <summary>
/// The green component, in the [0-255] range.
/// </summary>
public int? G { get; set; }
/// <summary>
/// The blue component, in the [0-255] range.
/// </summary>
public int? B { get; set; }
/// <summary>
/// The alpha component, in the [0-1] range (default: 1).
/// </summary>
public double? A { get; set; }}
/// <summary>
/// Configuration data for the highlighting of page elements.
/// </summary>
internal partial class HighlightConfig
{
/// <summary>
/// Whether the node info tooltip should be shown (default: false).
/// </summary>
public bool? ShowInfo { get; set; }
/// <summary>
/// The content box highlight fill color (default: transparent).
/// </summary>
public RGBAColor ContentColor { get; set; }
/// <summary>
/// The padding highlight fill color (default: transparent).
/// </summary>
public RGBAColor PaddingColor { get; set; }
/// <summary>
/// The border highlight fill color (default: transparent).
/// </summary>
public RGBAColor BorderColor { get; set; }
/// <summary>
/// The margin highlight fill color (default: transparent).
/// </summary>
public RGBAColor MarginColor { get; set; }}
/// <summary>
/// Data to construct File object.
/// </summary>
internal partial class FilePayload
{
/// <summary>
/// File name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// File type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Base64-encoded file data.
/// </summary>
public string Data { get; set; }}
/// <summary>
/// Returns the root DOM node to the caller.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getDocument</c>
/// </remarks>
internal partial class DOMGetDocumentRequest : IWebkitRequest<DOMGetDocumentResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getDocument";
}
/// <summary>
/// Response from <see cref="DOMGetDocumentRequest"/>
/// </summary>
internal partial class DOMGetDocumentResponse: IWebkitResponse
{
/// <summary>
/// Resulting node.
/// </summary>
public Node Root { get; set; }}
/// <summary>
/// Requests that children of the node with given id are returned to the caller in form of &lt;code&gt;setChildNodes&lt;/code&gt; events where not only immediate children are retrieved, but all children down to the specified depth.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.requestChildNodes</c>
/// </remarks>
internal partial class DOMRequestChildNodesRequest : IWebkitRequest<DOMRequestChildNodesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.requestChildNodes";
/// <summary>
/// Id of the node to get children for.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0.
/// </summary>
public int? Depth { get; set; }}
/// <summary>
/// Response from <see cref="DOMRequestChildNodesRequest"/>
/// </summary>
internal partial class DOMRequestChildNodesResponse: IWebkitResponse
{
}
/// <summary>
/// Executes &lt;code&gt;querySelector&lt;/code&gt; on a given node.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.querySelector</c>
/// </remarks>
internal partial class DOMQuerySelectorRequest : IWebkitRequest<DOMQuerySelectorResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.querySelector";
/// <summary>
/// Id of the node to query upon.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Selector string.
/// </summary>
public string Selector { get; set; }}
/// <summary>
/// Response from <see cref="DOMQuerySelectorRequest"/>
/// </summary>
internal partial class DOMQuerySelectorResponse: IWebkitResponse
{
/// <summary>
/// Query selector result.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Executes &lt;code&gt;querySelectorAll&lt;/code&gt; on a given node.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.querySelectorAll</c>
/// </remarks>
internal partial class DOMQuerySelectorAllRequest : IWebkitRequest<DOMQuerySelectorAllResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.querySelectorAll";
/// <summary>
/// Id of the node to query upon.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Selector string.
/// </summary>
public string Selector { get; set; }}
/// <summary>
/// Response from <see cref="DOMQuerySelectorAllRequest"/>
/// </summary>
internal partial class DOMQuerySelectorAllResponse: IWebkitResponse
{
/// <summary>
/// Query selector result.
/// </summary>
public int?[] NodeIds { get; set; }}
/// <summary>
/// Sets node name for a node with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setNodeName</c>
/// </remarks>
internal partial class DOMSetNodeNameRequest : IWebkitRequest<DOMSetNodeNameResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setNodeName";
/// <summary>
/// Id of the node to set name for.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// New node's name.
/// </summary>
public string Name { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetNodeNameRequest"/>
/// </summary>
internal partial class DOMSetNodeNameResponse: IWebkitResponse
{
/// <summary>
/// New node's id.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Sets node value for a node with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setNodeValue</c>
/// </remarks>
internal partial class DOMSetNodeValueRequest : IWebkitRequest<DOMSetNodeValueResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setNodeValue";
/// <summary>
/// Id of the node to set value for.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// New node's value.
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetNodeValueRequest"/>
/// </summary>
internal partial class DOMSetNodeValueResponse: IWebkitResponse
{
}
/// <summary>
/// Removes node with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.removeNode</c>
/// </remarks>
internal partial class DOMRemoveNodeRequest : IWebkitRequest<DOMRemoveNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.removeNode";
/// <summary>
/// Id of the node to remove.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMRemoveNodeRequest"/>
/// </summary>
internal partial class DOMRemoveNodeResponse: IWebkitResponse
{
}
/// <summary>
/// Sets attribute for an element with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setAttributeValue</c>
/// </remarks>
internal partial class DOMSetAttributeValueRequest : IWebkitRequest<DOMSetAttributeValueResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setAttributeValue";
/// <summary>
/// Id of the element to set attribute for.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Attribute name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Attribute value.
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetAttributeValueRequest"/>
/// </summary>
internal partial class DOMSetAttributeValueResponse: IWebkitResponse
{
}
/// <summary>
/// Sets attributes on element with given id. This method is useful when user edits some existing attribute value and types in several attribute name/value pairs.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setAttributesAsText</c>
/// </remarks>
internal partial class DOMSetAttributesAsTextRequest : IWebkitRequest<DOMSetAttributesAsTextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setAttributesAsText";
/// <summary>
/// Id of the element to set attributes for.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Text with a number of attributes. Will parse this text using HTML parser.
/// </summary>
public string Text { get; set; }
/// <summary>
/// Attribute name to replace with new attributes derived from text in case text parsed successfully.
/// </summary>
public string Name { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetAttributesAsTextRequest"/>
/// </summary>
internal partial class DOMSetAttributesAsTextResponse: IWebkitResponse
{
}
/// <summary>
/// Removes attribute with given name from an element with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.removeAttribute</c>
/// </remarks>
internal partial class DOMRemoveAttributeRequest : IWebkitRequest<DOMRemoveAttributeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.removeAttribute";
/// <summary>
/// Id of the element to remove attribute from.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Name of the attribute to remove.
/// </summary>
public string Name { get; set; }}
/// <summary>
/// Response from <see cref="DOMRemoveAttributeRequest"/>
/// </summary>
internal partial class DOMRemoveAttributeResponse: IWebkitResponse
{
}
/// <summary>
/// Gets the list of builtin DOM event names.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getSupportedEventNames</c>
/// </remarks>
internal partial class DOMGetSupportedEventNamesRequest : IWebkitRequest<DOMGetSupportedEventNamesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getSupportedEventNames";
}
/// <summary>
/// Response from <see cref="DOMGetSupportedEventNamesRequest"/>
/// </summary>
internal partial class DOMGetSupportedEventNamesResponse: IWebkitResponse
{
/// <summary>
/// 
/// </summary>
public string[] EventNames { get; set; }}
/// <summary>
/// Returns all data binding relationships between data that is associated with the node and the node itself.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getDataBindingsForNode</c>
/// </remarks>
internal partial class DOMGetDataBindingsForNodeRequest : IWebkitRequest<DOMGetDataBindingsForNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getDataBindingsForNode";
/// <summary>
/// Id of the node to get data bindings for.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetDataBindingsForNodeRequest"/>
/// </summary>
internal partial class DOMGetDataBindingsForNodeResponse: IWebkitResponse
{
/// <summary>
/// Array of binding relationships between data and node
/// </summary>
public DataBinding[] DataBindings { get; set; }}
/// <summary>
/// Returns all data that has been associated with the node and is available for data binding.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getAssociatedDataForNode</c>
/// </remarks>
internal partial class DOMGetAssociatedDataForNodeRequest : IWebkitRequest<DOMGetAssociatedDataForNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getAssociatedDataForNode";
/// <summary>
/// Id of the node to get associated data for.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetAssociatedDataForNodeRequest"/>
/// </summary>
internal partial class DOMGetAssociatedDataForNodeResponse: IWebkitResponse
{
/// <summary>
/// Associated data bound to this node. Sent as a JSON string.
/// </summary>
public string AssociatedData { get; set; }}
/// <summary>
/// Returns event listeners relevant to the node.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getEventListenersForNode</c>
/// </remarks>
internal partial class DOMGetEventListenersForNodeRequest : IWebkitRequest<DOMGetEventListenersForNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getEventListenersForNode";
/// <summary>
/// Id of the node to get listeners for.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetEventListenersForNodeRequest"/>
/// </summary>
internal partial class DOMGetEventListenersForNodeResponse: IWebkitResponse
{
/// <summary>
/// Array of relevant listeners.
/// </summary>
public EventListener[] Listeners { get; set; }}
/// <summary>
/// Enable/disable the given event listener. A disabled event listener will not fire.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setEventListenerDisabled</c>
/// </remarks>
internal partial class DOMSetEventListenerDisabledRequest : IWebkitRequest<DOMSetEventListenerDisabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setEventListenerDisabled";
/// <summary>
/// 
/// </summary>
public int? EventListenerId { get; set; }
/// <summary>
/// 
/// </summary>
public bool? Disabled { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetEventListenerDisabledRequest"/>
/// </summary>
internal partial class DOMSetEventListenerDisabledResponse: IWebkitResponse
{
}
/// <summary>
/// Set a breakpoint on the given event listener.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setBreakpointForEventListener</c>
/// </remarks>
internal partial class DOMSetBreakpointForEventListenerRequest : IWebkitRequest<DOMSetBreakpointForEventListenerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setBreakpointForEventListener";
/// <summary>
/// 
/// </summary>
public int? EventListenerId { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetBreakpointForEventListenerRequest"/>
/// </summary>
internal partial class DOMSetBreakpointForEventListenerResponse: IWebkitResponse
{
}
/// <summary>
/// Remove any breakpoints on the given event listener.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.removeBreakpointForEventListener</c>
/// </remarks>
internal partial class DOMRemoveBreakpointForEventListenerRequest : IWebkitRequest<DOMRemoveBreakpointForEventListenerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.removeBreakpointForEventListener";
/// <summary>
/// 
/// </summary>
public int? EventListenerId { get; set; }}
/// <summary>
/// Response from <see cref="DOMRemoveBreakpointForEventListenerRequest"/>
/// </summary>
internal partial class DOMRemoveBreakpointForEventListenerResponse: IWebkitResponse
{
}
/// <summary>
/// Returns a dictionary of accessibility properties for the node.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getAccessibilityPropertiesForNode</c>
/// </remarks>
internal partial class DOMGetAccessibilityPropertiesForNodeRequest : IWebkitRequest<DOMGetAccessibilityPropertiesForNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getAccessibilityPropertiesForNode";
/// <summary>
/// Id of the node for which to get accessibility properties.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetAccessibilityPropertiesForNodeRequest"/>
/// </summary>
internal partial class DOMGetAccessibilityPropertiesForNodeResponse: IWebkitResponse
{
/// <summary>
/// Dictionary of relevant accessibility properties.
/// </summary>
public AccessibilityProperties Properties { get; set; }}
/// <summary>
/// Returns node's HTML markup.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getOuterHTML</c>
/// </remarks>
internal partial class DOMGetOuterHTMLRequest : IWebkitRequest<DOMGetOuterHTMLResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getOuterHTML";
/// <summary>
/// Id of the node to get markup for.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetOuterHTMLRequest"/>
/// </summary>
internal partial class DOMGetOuterHTMLResponse: IWebkitResponse
{
/// <summary>
/// Outer HTML markup.
/// </summary>
public string OuterHTML { get; set; }}
/// <summary>
/// Sets node HTML markup, returns new node id.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setOuterHTML</c>
/// </remarks>
internal partial class DOMSetOuterHTMLRequest : IWebkitRequest<DOMSetOuterHTMLResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setOuterHTML";
/// <summary>
/// Id of the node to set markup for.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Outer HTML markup to set.
/// </summary>
public string OuterHTML { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetOuterHTMLRequest"/>
/// </summary>
internal partial class DOMSetOuterHTMLResponse: IWebkitResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.insertAdjacentHTML</c>
/// </remarks>
internal partial class DOMInsertAdjacentHTMLRequest : IWebkitRequest<DOMInsertAdjacentHTMLResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.insertAdjacentHTML";
/// <summary>
/// 
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// 
/// </summary>
public string Position { get; set; }
/// <summary>
/// 
/// </summary>
public string Html { get; set; }}
/// <summary>
/// Response from <see cref="DOMInsertAdjacentHTMLRequest"/>
/// </summary>
internal partial class DOMInsertAdjacentHTMLResponse: IWebkitResponse
{
}
/// <summary>
/// Searches for a given string in the DOM tree. Use &lt;code&gt;getSearchResults&lt;/code&gt; to access search results or &lt;code&gt;cancelSearch&lt;/code&gt; to end this search session.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.performSearch</c>
/// </remarks>
internal partial class DOMPerformSearchRequest : IWebkitRequest<DOMPerformSearchResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.performSearch";
/// <summary>
/// Plain text or query selector or XPath search query.
/// </summary>
public string Query { get; set; }
/// <summary>
/// Ids of nodes to use as starting points for the search.
/// </summary>
public int?[] NodeIds { get; set; }
/// <summary>
/// If true, search is case sensitive.
/// </summary>
public bool? CaseSensitive { get; set; }}
/// <summary>
/// Response from <see cref="DOMPerformSearchRequest"/>
/// </summary>
internal partial class DOMPerformSearchResponse: IWebkitResponse
{
/// <summary>
/// Unique search session identifier.
/// </summary>
public string SearchId { get; set; }
/// <summary>
/// Number of search results.
/// </summary>
public int? ResultCount { get; set; }}
/// <summary>
/// Returns search results from given &lt;code&gt;fromIndex&lt;/code&gt; to given &lt;code&gt;toIndex&lt;/code&gt; from the sarch with the given identifier.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getSearchResults</c>
/// </remarks>
internal partial class DOMGetSearchResultsRequest : IWebkitRequest<DOMGetSearchResultsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getSearchResults";
/// <summary>
/// Unique search session identifier.
/// </summary>
public string SearchId { get; set; }
/// <summary>
/// Start index of the search result to be returned.
/// </summary>
public int? FromIndex { get; set; }
/// <summary>
/// End index of the search result to be returned.
/// </summary>
public int? ToIndex { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetSearchResultsRequest"/>
/// </summary>
internal partial class DOMGetSearchResultsResponse: IWebkitResponse
{
/// <summary>
/// Ids of the search result nodes.
/// </summary>
public int?[] NodeIds { get; set; }}
/// <summary>
/// Discards search results from the session with the given id. &lt;code&gt;getSearchResults&lt;/code&gt; should no longer be called for that search.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.discardSearchResults</c>
/// </remarks>
internal partial class DOMDiscardSearchResultsRequest : IWebkitRequest<DOMDiscardSearchResultsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.discardSearchResults";
/// <summary>
/// Unique search session identifier.
/// </summary>
public string SearchId { get; set; }}
/// <summary>
/// Response from <see cref="DOMDiscardSearchResultsRequest"/>
/// </summary>
internal partial class DOMDiscardSearchResultsResponse: IWebkitResponse
{
}
/// <summary>
/// Requests that the node is sent to the caller given the JavaScript node object reference. All nodes that form the path from the node to the root are also sent to the client as a series of &lt;code&gt;setChildNodes&lt;/code&gt; notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.requestNode</c>
/// </remarks>
internal partial class DOMRequestNodeRequest : IWebkitRequest<DOMRequestNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.requestNode";
/// <summary>
/// JavaScript object id to convert into node.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="DOMRequestNodeRequest"/>
/// </summary>
internal partial class DOMRequestNodeResponse: IWebkitResponse
{
/// <summary>
/// Node id for given object.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted. Backend then generates 'inspect' command upon element selection.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setInspectModeEnabled</c>
/// </remarks>
internal partial class DOMSetInspectModeEnabledRequest : IWebkitRequest<DOMSetInspectModeEnabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setInspectModeEnabled";
/// <summary>
/// True to enable inspection mode, false to disable it.
/// </summary>
public bool? Enabled { get; set; }
/// <summary>
/// A descriptor for the highlight appearance of hovered-over nodes. May be omitted if &lt;code&gt;enabled == false&lt;/code&gt;.
/// </summary>
public HighlightConfig HighlightConfig { get; set; }
/// <summary>
/// Whether the rulers should be shown during element selection. This overrides Page.setShowRulers.
/// </summary>
public bool? ShowRulers { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetInspectModeEnabledRequest"/>
/// </summary>
internal partial class DOMSetInspectModeEnabledResponse: IWebkitResponse
{
}
/// <summary>
/// Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.highlightRect</c>
/// </remarks>
internal partial class DOMHighlightRectRequest : IWebkitRequest<DOMHighlightRectResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.highlightRect";
/// <summary>
/// X coordinate
/// </summary>
public int? X { get; set; }
/// <summary>
/// Y coordinate
/// </summary>
public int? Y { get; set; }
/// <summary>
/// Rectangle width
/// </summary>
public int? Width { get; set; }
/// <summary>
/// Rectangle height
/// </summary>
public int? Height { get; set; }
/// <summary>
/// The highlight fill color (default: transparent).
/// </summary>
public RGBAColor Color { get; set; }
/// <summary>
/// The highlight outline color (default: transparent).
/// </summary>
public RGBAColor OutlineColor { get; set; }
/// <summary>
/// Indicates whether the provided parameters are in page coordinates or in viewport coordinates (the default).
/// </summary>
public bool? UsePageCoordinates { get; set; }}
/// <summary>
/// Response from <see cref="DOMHighlightRectRequest"/>
/// </summary>
internal partial class DOMHighlightRectResponse: IWebkitResponse
{
}
/// <summary>
/// Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.highlightQuad</c>
/// </remarks>
internal partial class DOMHighlightQuadRequest : IWebkitRequest<DOMHighlightQuadResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.highlightQuad";
/// <summary>
/// Quad to highlight
/// </summary>
public double?[] Quad { get; set; }
/// <summary>
/// The highlight fill color (default: transparent).
/// </summary>
public RGBAColor Color { get; set; }
/// <summary>
/// The highlight outline color (default: transparent).
/// </summary>
public RGBAColor OutlineColor { get; set; }
/// <summary>
/// Indicates whether the provided parameters are in page coordinates or in viewport coordinates (the default).
/// </summary>
public bool? UsePageCoordinates { get; set; }}
/// <summary>
/// Response from <see cref="DOMHighlightQuadRequest"/>
/// </summary>
internal partial class DOMHighlightQuadResponse: IWebkitResponse
{
}
/// <summary>
/// Highlights all DOM nodes that match a given selector. A string containing a CSS selector must be specified.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.highlightSelector</c>
/// </remarks>
internal partial class DOMHighlightSelectorRequest : IWebkitRequest<DOMHighlightSelectorResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.highlightSelector";
/// <summary>
/// A descriptor for the highlight appearance.
/// </summary>
public HighlightConfig HighlightConfig { get; set; }
/// <summary>
/// A CSS selector for finding matching nodes to highlight.
/// </summary>
public string SelectorString { get; set; }
/// <summary>
/// Identifier of the frame which will be searched using the selector.  If not provided, the main frame will be used.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Response from <see cref="DOMHighlightSelectorRequest"/>
/// </summary>
internal partial class DOMHighlightSelectorResponse: IWebkitResponse
{
}
/// <summary>
/// Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or objectId must be specified.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.highlightNode</c>
/// </remarks>
internal partial class DOMHighlightNodeRequest : IWebkitRequest<DOMHighlightNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.highlightNode";
/// <summary>
/// A descriptor for the highlight appearance.
/// </summary>
public HighlightConfig HighlightConfig { get; set; }
/// <summary>
/// Identifier of the node to highlight.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// JavaScript object id of the node to be highlighted.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="DOMHighlightNodeRequest"/>
/// </summary>
internal partial class DOMHighlightNodeResponse: IWebkitResponse
{
}
/// <summary>
/// Highlights each DOM node in the given list.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.highlightNodeList</c>
/// </remarks>
internal partial class DOMHighlightNodeListRequest : IWebkitRequest<DOMHighlightNodeListResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.highlightNodeList";
/// <summary>
/// 
/// </summary>
public int?[] NodeIds { get; set; }
/// <summary>
/// 
/// </summary>
public HighlightConfig HighlightConfig { get; set; }}
/// <summary>
/// Response from <see cref="DOMHighlightNodeListRequest"/>
/// </summary>
internal partial class DOMHighlightNodeListResponse: IWebkitResponse
{
}
/// <summary>
/// Hides DOM node highlight.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.hideHighlight</c>
/// </remarks>
internal partial class DOMHideHighlightRequest : IWebkitRequest<DOMHideHighlightResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.hideHighlight";
}
/// <summary>
/// Response from <see cref="DOMHideHighlightRequest"/>
/// </summary>
internal partial class DOMHideHighlightResponse: IWebkitResponse
{
}
/// <summary>
/// Highlights owner element of the frame with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.highlightFrame</c>
/// </remarks>
internal partial class DOMHighlightFrameRequest : IWebkitRequest<DOMHighlightFrameResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.highlightFrame";
/// <summary>
/// Identifier of the frame to highlight.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// The content box highlight fill color (default: transparent).
/// </summary>
public RGBAColor ContentColor { get; set; }
/// <summary>
/// The content box highlight outline color (default: transparent).
/// </summary>
public RGBAColor ContentOutlineColor { get; set; }}
/// <summary>
/// Response from <see cref="DOMHighlightFrameRequest"/>
/// </summary>
internal partial class DOMHighlightFrameResponse: IWebkitResponse
{
}
/// <summary>
/// Requests that the node is sent to the caller given its path.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.pushNodeByPathToFrontend</c>
/// </remarks>
internal partial class DOMPushNodeByPathToFrontendRequest : IWebkitRequest<DOMPushNodeByPathToFrontendResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.pushNodeByPathToFrontend";
/// <summary>
/// Path to node in the proprietary format.
/// </summary>
public string Path { get; set; }}
/// <summary>
/// Response from <see cref="DOMPushNodeByPathToFrontendRequest"/>
/// </summary>
internal partial class DOMPushNodeByPathToFrontendResponse: IWebkitResponse
{
/// <summary>
/// Id of the node for given path.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Resolves JavaScript node object for given node id.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.resolveNode</c>
/// </remarks>
internal partial class DOMResolveNodeRequest : IWebkitRequest<DOMResolveNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.resolveNode";
/// <summary>
/// Id of the node to resolve.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Source element handle.
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// Specifies in which execution context to adopt to.
/// </summary>
public int? ExecutionContextId { get; set; }
/// <summary>
/// Symbolic group name that can be used to release multiple objects.
/// </summary>
public string ObjectGroup { get; set; }}
/// <summary>
/// Response from <see cref="DOMResolveNodeRequest"/>
/// </summary>
internal partial class DOMResolveNodeResponse: IWebkitResponse
{
/// <summary>
/// JavaScript object wrapper for given node.
/// </summary>
public Runtime.RemoteObject Object { get; set; }}
/// <summary>
/// Returns attributes for the specified node.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getAttributes</c>
/// </remarks>
internal partial class DOMGetAttributesRequest : IWebkitRequest<DOMGetAttributesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getAttributes";
/// <summary>
/// Id of the node to retrieve attributes for.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetAttributesRequest"/>
/// </summary>
internal partial class DOMGetAttributesResponse: IWebkitResponse
{
/// <summary>
/// An interleaved array of node attribute names and values.
/// </summary>
public string[] Attributes { get; set; }}
/// <summary>
/// Moves node into the new container, places it before the given anchor.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.moveTo</c>
/// </remarks>
internal partial class DOMMoveToRequest : IWebkitRequest<DOMMoveToResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.moveTo";
/// <summary>
/// Id of the node to drop.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Id of the element to drop into.
/// </summary>
public int? TargetNodeId { get; set; }
/// <summary>
/// Drop node before given one.
/// </summary>
public int? InsertBeforeNodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMMoveToRequest"/>
/// </summary>
internal partial class DOMMoveToResponse: IWebkitResponse
{
/// <summary>
/// New id of the moved node.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Undoes the last performed action.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.undo</c>
/// </remarks>
internal partial class DOMUndoRequest : IWebkitRequest<DOMUndoResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.undo";
}
/// <summary>
/// Response from <see cref="DOMUndoRequest"/>
/// </summary>
internal partial class DOMUndoResponse: IWebkitResponse
{
}
/// <summary>
/// Re-does the last undone action.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.redo</c>
/// </remarks>
internal partial class DOMRedoRequest : IWebkitRequest<DOMRedoResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.redo";
}
/// <summary>
/// Response from <see cref="DOMRedoRequest"/>
/// </summary>
internal partial class DOMRedoResponse: IWebkitResponse
{
}
/// <summary>
/// Marks last undoable state.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.markUndoableState</c>
/// </remarks>
internal partial class DOMMarkUndoableStateRequest : IWebkitRequest<DOMMarkUndoableStateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.markUndoableState";
}
/// <summary>
/// Response from <see cref="DOMMarkUndoableStateRequest"/>
/// </summary>
internal partial class DOMMarkUndoableStateResponse: IWebkitResponse
{
}
/// <summary>
/// Focuses the given element.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.focus</c>
/// </remarks>
internal partial class DOMFocusRequest : IWebkitRequest<DOMFocusResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.focus";
/// <summary>
/// Id of the node to focus.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMFocusRequest"/>
/// </summary>
internal partial class DOMFocusResponse: IWebkitResponse
{
}
/// <summary>
/// Enables console to refer to the node with given id via $0 (see Command Line API for more details).
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setInspectedNode</c>
/// </remarks>
internal partial class DOMSetInspectedNodeRequest : IWebkitRequest<DOMSetInspectedNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setInspectedNode";
/// <summary>
/// DOM node id to be accessible by means of $0 command line API.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetInspectedNodeRequest"/>
/// </summary>
internal partial class DOMSetInspectedNodeResponse: IWebkitResponse
{
}
/// <summary>
/// Controls whether any DOM commands work for nodes inside a UserAgent shadow tree.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setAllowEditingUserAgentShadowTrees</c>
/// </remarks>
internal partial class DOMSetAllowEditingUserAgentShadowTreesRequest : IWebkitRequest<DOMSetAllowEditingUserAgentShadowTreesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setAllowEditingUserAgentShadowTrees";
/// <summary>
/// 
/// </summary>
public bool? Allow { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetAllowEditingUserAgentShadowTreesRequest"/>
/// </summary>
internal partial class DOMSetAllowEditingUserAgentShadowTreesResponse: IWebkitResponse
{
}
/// <summary>
/// Returns node description.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.describeNode</c>
/// </remarks>
internal partial class DOMDescribeNodeRequest : IWebkitRequest<DOMDescribeNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.describeNode";
/// <summary>
/// JavaScript object id of the node wrapper.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="DOMDescribeNodeRequest"/>
/// </summary>
internal partial class DOMDescribeNodeResponse: IWebkitResponse
{
/// <summary>
/// Frame ID for frame owner elements.
/// </summary>
public string ContentFrameId { get; set; }
/// <summary>
/// ID of the owning frame element.
/// </summary>
public string OwnerFrameId { get; set; }}
/// <summary>
/// Returns quads that describe node position on the page. This method
/// might return multiple quads for inline nodes.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getContentQuads</c>
/// </remarks>
internal partial class DOMGetContentQuadsRequest : IWebkitRequest<DOMGetContentQuadsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getContentQuads";
/// <summary>
/// JavaScript object id of the node wrapper.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetContentQuadsRequest"/>
/// </summary>
internal partial class DOMGetContentQuadsResponse: IWebkitResponse
{
/// <summary>
/// Quads that describe node layout relative to viewport.
/// </summary>
public double?[][] Quads { get; set; }}
/// <summary>
/// Sets input files for given &lt;input type=file&gt;
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setInputFiles</c>
/// </remarks>
internal partial class DOMSetInputFilesRequest : IWebkitRequest<DOMSetInputFilesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setInputFiles";
/// <summary>
/// Input element handle.
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// Files to set
/// </summary>
public FilePayload[] Files { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetInputFilesRequest"/>
/// </summary>
internal partial class DOMSetInputFilesResponse: IWebkitResponse
{
}
/// <summary>
/// Fired when &lt;code&gt;Document&lt;/code&gt; has been totally updated. Node ids are no longer valid.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.documentUpdated</c>
/// </remarks>
internal partial class DOMDocumentUpdatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.documentUpdated";
}
/// <summary>
/// Inspect a particular node.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.inspect</c>
/// </remarks>
internal partial class DOMInspectWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.inspect";
/// <summary>
/// Equivalent of Inspector.inspect but with a nodeId instead of a RemoteObject. Useful for augmented contexts.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Fired when backend wants to provide client with the missing DOM structure. This happens upon most of the calls requesting node ids.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.setChildNodes</c>
/// </remarks>
internal partial class DOMSetChildNodesWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.setChildNodes";
/// <summary>
/// Parent node id to populate with children.
/// </summary>
public int? ParentId { get; set; }
/// <summary>
/// Child nodes array.
/// </summary>
public Node[] Nodes { get; set; }}
/// <summary>
/// Fired when &lt;code&gt;Element&lt;/code&gt;'s attribute is modified.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.attributeModified</c>
/// </remarks>
internal partial class DOMAttributeModifiedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.attributeModified";
/// <summary>
/// Id of the node that has changed.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Attribute name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Attribute value.
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Fired when &lt;code&gt;Element&lt;/code&gt;'s attribute is removed.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.attributeRemoved</c>
/// </remarks>
internal partial class DOMAttributeRemovedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.attributeRemoved";
/// <summary>
/// Id of the node that has changed.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Attribute name.
/// </summary>
public string Name { get; set; }}
/// <summary>
/// Fired when &lt;code&gt;Element&lt;/code&gt;'s inline style is modified via a CSS property modification.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.inlineStyleInvalidated</c>
/// </remarks>
internal partial class DOMInlineStyleInvalidatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.inlineStyleInvalidated";
/// <summary>
/// Ids of the nodes for which the inline styles have been invalidated.
/// </summary>
public int?[] NodeIds { get; set; }}
/// <summary>
/// Mirrors &lt;code&gt;DOMCharacterDataModified&lt;/code&gt; event.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.characterDataModified</c>
/// </remarks>
internal partial class DOMCharacterDataModifiedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.characterDataModified";
/// <summary>
/// Id of the node that has changed.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// New text value.
/// </summary>
public string CharacterData { get; set; }}
/// <summary>
/// Fired when &lt;code&gt;Container&lt;/code&gt;'s child node count has changed.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.childNodeCountUpdated</c>
/// </remarks>
internal partial class DOMChildNodeCountUpdatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.childNodeCountUpdated";
/// <summary>
/// Id of the node that has changed.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// New node count.
/// </summary>
public int? ChildNodeCount { get; set; }}
/// <summary>
/// Mirrors &lt;code&gt;DOMNodeInserted&lt;/code&gt; event.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.childNodeInserted</c>
/// </remarks>
internal partial class DOMChildNodeInsertedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.childNodeInserted";
/// <summary>
/// Id of the node that has changed.
/// </summary>
public int? ParentNodeId { get; set; }
/// <summary>
/// Id of the previous sibling.
/// </summary>
public int? PreviousNodeId { get; set; }
/// <summary>
/// Inserted node data.
/// </summary>
public Node Node { get; set; }}
/// <summary>
/// Mirrors &lt;code&gt;DOMNodeRemoved&lt;/code&gt; event.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.childNodeRemoved</c>
/// </remarks>
internal partial class DOMChildNodeRemovedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.childNodeRemoved";
/// <summary>
/// Parent id.
/// </summary>
public int? ParentNodeId { get; set; }
/// <summary>
/// Id of the node that has been removed.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Called when shadow root is pushed into the element.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.shadowRootPushed</c>
/// </remarks>
internal partial class DOMShadowRootPushedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.shadowRootPushed";
/// <summary>
/// Host element id.
/// </summary>
public int? HostId { get; set; }
/// <summary>
/// Shadow root.
/// </summary>
public Node Root { get; set; }}
/// <summary>
/// Called when shadow root is popped from the element.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.shadowRootPopped</c>
/// </remarks>
internal partial class DOMShadowRootPoppedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.shadowRootPopped";
/// <summary>
/// Host element id.
/// </summary>
public int? HostId { get; set; }
/// <summary>
/// Shadow root id.
/// </summary>
public int? RootId { get; set; }}
/// <summary>
/// Called when the custom element state is changed.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.customElementStateChanged</c>
/// </remarks>
internal partial class DOMCustomElementStateChangedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.customElementStateChanged";
/// <summary>
/// Element id.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Custom element state.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public CustomElementState CustomElementState { get; set; }}
/// <summary>
/// Called when a pseudo element is added to an element.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.pseudoElementAdded</c>
/// </remarks>
internal partial class DOMPseudoElementAddedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.pseudoElementAdded";
/// <summary>
/// Pseudo element's parent element id.
/// </summary>
public int? ParentId { get; set; }
/// <summary>
/// The added pseudo element.
/// </summary>
public Node PseudoElement { get; set; }}
/// <summary>
/// Called when a pseudo element is removed from an element.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.pseudoElementRemoved</c>
/// </remarks>
internal partial class DOMPseudoElementRemovedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.pseudoElementRemoved";
/// <summary>
/// Pseudo element's parent element id.
/// </summary>
public int? ParentId { get; set; }
/// <summary>
/// The removed pseudo element id.
/// </summary>
public int? PseudoElementId { get; set; }}
/// <summary>
/// Called when an event listener is added to a node.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.didAddEventListener</c>
/// </remarks>
internal partial class DOMDidAddEventListenerWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.didAddEventListener";
/// <summary>
/// 
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Called after a request has been made to remove an event listener from a node.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.willRemoveEventListener</c>
/// </remarks>
internal partial class DOMWillRemoveEventListenerWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.willRemoveEventListener";
/// <summary>
/// 
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Called when an event is fired on a node.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.didFireEvent</c>
/// </remarks>
internal partial class DOMDidFireEventWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.didFireEvent";
/// <summary>
/// 
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// 
/// </summary>
public string EventName { get; set; }
/// <summary>
/// Time when the event was fired
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// Holds ancillary information about the event or its target.
/// </summary>
public object Data { get; set; }}
/// <summary>
/// Called when an element enters/exits a power efficient playback state.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.powerEfficientPlaybackStateChanged</c>
/// </remarks>
internal partial class DOMPowerEfficientPlaybackStateChangedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOM.powerEfficientPlaybackStateChanged";
/// <summary>
/// 
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// 
/// </summary>
public bool? IsPowerEfficient { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.DOMDebugger
{
/// <summary>
/// DOM breakpoint type.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum DOMBreakpointType
{
[System.Runtime.Serialization.EnumMember(Value = "subtree-modified")]SubtreeModified,
[System.Runtime.Serialization.EnumMember(Value = "attribute-modified")]AttributeModified,
[System.Runtime.Serialization.EnumMember(Value = "node-removed")]NodeRemoved}
/// <summary>
/// Event breakpoint type.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum EventBreakpointType
{
[System.Runtime.Serialization.EnumMember(Value = "animation-frame")]AnimationFrame,
[System.Runtime.Serialization.EnumMember(Value = "interval")]Interval,
[System.Runtime.Serialization.EnumMember(Value = "listener")]Listener,
[System.Runtime.Serialization.EnumMember(Value = "timeout")]Timeout}
/// <summary>
/// Sets breakpoint on particular operation with DOM.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.setDOMBreakpoint</c>
/// </remarks>
internal partial class DOMDebuggerSetDOMBreakpointRequest : IWebkitRequest<DOMDebuggerSetDOMBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.setDOMBreakpoint";
/// <summary>
/// Identifier of the node to set breakpoint on.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Type of the operation to stop upon.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public DOMBreakpointType Type { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerSetDOMBreakpointRequest"/>
/// </summary>
internal partial class DOMDebuggerSetDOMBreakpointResponse: IWebkitResponse
{
}
/// <summary>
/// Removes DOM breakpoint that was set using &lt;code&gt;setDOMBreakpoint&lt;/code&gt;.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.removeDOMBreakpoint</c>
/// </remarks>
internal partial class DOMDebuggerRemoveDOMBreakpointRequest : IWebkitRequest<DOMDebuggerRemoveDOMBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.removeDOMBreakpoint";
/// <summary>
/// Identifier of the node to remove breakpoint from.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Type of the breakpoint to remove.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public DOMBreakpointType Type { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerRemoveDOMBreakpointRequest"/>
/// </summary>
internal partial class DOMDebuggerRemoveDOMBreakpointResponse: IWebkitResponse
{
}
/// <summary>
/// Sets breakpoint on particular event of given type.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.setEventBreakpoint</c>
/// </remarks>
internal partial class DOMDebuggerSetEventBreakpointRequest : IWebkitRequest<DOMDebuggerSetEventBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.setEventBreakpoint";
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public EventBreakpointType BreakpointType { get; set; }
/// <summary>
/// The name of the specific event to stop on.
/// </summary>
public string EventName { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerSetEventBreakpointRequest"/>
/// </summary>
internal partial class DOMDebuggerSetEventBreakpointResponse: IWebkitResponse
{
}
/// <summary>
/// Removes breakpoint on particular event of given type.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.removeEventBreakpoint</c>
/// </remarks>
internal partial class DOMDebuggerRemoveEventBreakpointRequest : IWebkitRequest<DOMDebuggerRemoveEventBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.removeEventBreakpoint";
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public EventBreakpointType BreakpointType { get; set; }
/// <summary>
/// The name of the specific event to stop on.
/// </summary>
public string EventName { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerRemoveEventBreakpointRequest"/>
/// </summary>
internal partial class DOMDebuggerRemoveEventBreakpointResponse: IWebkitResponse
{
}
/// <summary>
/// Sets breakpoint on network activity for the given URL.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.setURLBreakpoint</c>
/// </remarks>
internal partial class DOMDebuggerSetURLBreakpointRequest : IWebkitRequest<DOMDebuggerSetURLBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.setURLBreakpoint";
/// <summary>
/// Resource URL substring or regular expression. All requests having this substring in the URL will get stopped upon. An empty string will pause on all requests.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Whether the URL string is a regular expression.
/// </summary>
public bool? IsRegex { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerSetURLBreakpointRequest"/>
/// </summary>
internal partial class DOMDebuggerSetURLBreakpointResponse: IWebkitResponse
{
}
/// <summary>
/// Removes breakpoint from network activity for the given URL.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.removeURLBreakpoint</c>
/// </remarks>
internal partial class DOMDebuggerRemoveURLBreakpointRequest : IWebkitRequest<DOMDebuggerRemoveURLBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.removeURLBreakpoint";
/// <summary>
/// Resource URL substring. An empty string will stop pausing on all requests.
/// </summary>
public string Url { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerRemoveURLBreakpointRequest"/>
/// </summary>
internal partial class DOMDebuggerRemoveURLBreakpointResponse: IWebkitResponse
{
}
}
namespace PlaywrightSharp.Webkit.Protocol.DOMStorage
{
/// <summary>
/// DOM Storage identifier.
/// </summary>
internal partial class StorageId
{
/// <summary>
/// Security origin for the storage.
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// Whether the storage is local storage (not session storage).
/// </summary>
public bool? IsLocalStorage { get; set; }}
/// <summary>
/// Enables storage tracking, storage events will now be delivered to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMStorage.enable</c>
/// </remarks>
internal partial class DOMStorageEnableRequest : IWebkitRequest<DOMStorageEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMStorage.enable";
}
/// <summary>
/// Response from <see cref="DOMStorageEnableRequest"/>
/// </summary>
internal partial class DOMStorageEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables storage tracking, prevents storage events from being sent to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMStorage.disable</c>
/// </remarks>
internal partial class DOMStorageDisableRequest : IWebkitRequest<DOMStorageDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMStorage.disable";
}
/// <summary>
/// Response from <see cref="DOMStorageDisableRequest"/>
/// </summary>
internal partial class DOMStorageDisableResponse: IWebkitResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>DOMStorage.getDOMStorageItems</c>
/// </remarks>
internal partial class DOMStorageGetDOMStorageItemsRequest : IWebkitRequest<DOMStorageGetDOMStorageItemsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMStorage.getDOMStorageItems";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }}
/// <summary>
/// Response from <see cref="DOMStorageGetDOMStorageItemsRequest"/>
/// </summary>
internal partial class DOMStorageGetDOMStorageItemsResponse: IWebkitResponse
{
/// <summary>
/// 
/// </summary>
public string[][] Entries { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>DOMStorage.setDOMStorageItem</c>
/// </remarks>
internal partial class DOMStorageSetDOMStorageItemRequest : IWebkitRequest<DOMStorageSetDOMStorageItemResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMStorage.setDOMStorageItem";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }
/// <summary>
/// 
/// </summary>
public string Key { get; set; }
/// <summary>
/// 
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Response from <see cref="DOMStorageSetDOMStorageItemRequest"/>
/// </summary>
internal partial class DOMStorageSetDOMStorageItemResponse: IWebkitResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>DOMStorage.removeDOMStorageItem</c>
/// </remarks>
internal partial class DOMStorageRemoveDOMStorageItemRequest : IWebkitRequest<DOMStorageRemoveDOMStorageItemResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMStorage.removeDOMStorageItem";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }
/// <summary>
/// 
/// </summary>
public string Key { get; set; }}
/// <summary>
/// Response from <see cref="DOMStorageRemoveDOMStorageItemRequest"/>
/// </summary>
internal partial class DOMStorageRemoveDOMStorageItemResponse: IWebkitResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>DOMStorage.domStorageItemsCleared</c>
/// </remarks>
internal partial class DOMStorageDomStorageItemsClearedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOMStorage.domStorageItemsCleared";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>DOMStorage.domStorageItemRemoved</c>
/// </remarks>
internal partial class DOMStorageDomStorageItemRemovedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOMStorage.domStorageItemRemoved";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }
/// <summary>
/// 
/// </summary>
public string Key { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>DOMStorage.domStorageItemAdded</c>
/// </remarks>
internal partial class DOMStorageDomStorageItemAddedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOMStorage.domStorageItemAdded";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }
/// <summary>
/// 
/// </summary>
public string Key { get; set; }
/// <summary>
/// 
/// </summary>
public string NewValue { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>DOMStorage.domStorageItemUpdated</c>
/// </remarks>
internal partial class DOMStorageDomStorageItemUpdatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "DOMStorage.domStorageItemUpdated";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }
/// <summary>
/// 
/// </summary>
public string Key { get; set; }
/// <summary>
/// 
/// </summary>
public string OldValue { get; set; }
/// <summary>
/// 
/// </summary>
public string NewValue { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Emulation
{
/// <summary>
/// Overrides device metrics with provided values.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setDeviceMetricsOverride</c>
/// </remarks>
internal partial class EmulationSetDeviceMetricsOverrideRequest : IWebkitRequest<EmulationSetDeviceMetricsOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setDeviceMetricsOverride";
/// <summary>
/// 
/// </summary>
public int? Width { get; set; }
/// <summary>
/// 
/// </summary>
public int? Height { get; set; }
/// <summary>
/// 
/// </summary>
public double? DeviceScaleFactor { get; set; }
/// <summary>
/// 
/// </summary>
public bool? FixedLayout { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetDeviceMetricsOverrideRequest"/>
/// </summary>
internal partial class EmulationSetDeviceMetricsOverrideResponse: IWebkitResponse
{
}
/// <summary>
/// Allows to disable script execution for the page.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setJavaScriptEnabled</c>
/// </remarks>
internal partial class EmulationSetJavaScriptEnabledRequest : IWebkitRequest<EmulationSetJavaScriptEnabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setJavaScriptEnabled";
/// <summary>
/// 
/// </summary>
public bool? Enabled { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetJavaScriptEnabledRequest"/>
/// </summary>
internal partial class EmulationSetJavaScriptEnabledResponse: IWebkitResponse
{
}
/// <summary>
/// Credentials to use during HTTP authentication.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setAuthCredentials</c>
/// </remarks>
internal partial class EmulationSetAuthCredentialsRequest : IWebkitRequest<EmulationSetAuthCredentialsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setAuthCredentials";
/// <summary>
/// 
/// </summary>
public string Username { get; set; }
/// <summary>
/// 
/// </summary>
public string Password { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetAuthCredentialsRequest"/>
/// </summary>
internal partial class EmulationSetAuthCredentialsResponse: IWebkitResponse
{
}
}
namespace PlaywrightSharp.Webkit.Protocol.GenericTypes
{
/// <summary>
/// Search match in a resource.
/// </summary>
internal partial class SearchMatch
{
/// <summary>
/// Line number in resource content.
/// </summary>
public double? LineNumber { get; set; }
/// <summary>
/// Line with match content.
/// </summary>
public string LineContent { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Heap
{
/// <summary>
/// Information about a garbage collection.
/// </summary>
internal partial class GarbageCollection
{
/// <summary>
/// The type of garbage collection.
/// </summary>
public string Type { get; set; }
/// <summary>
/// 
/// </summary>
public double? StartTime { get; set; }
/// <summary>
/// 
/// </summary>
public double? EndTime { get; set; }}
/// <summary>
/// Enables Heap domain events.
/// </summary>
/// <remarks>
/// Will send the command <c>Heap.enable</c>
/// </remarks>
internal partial class HeapEnableRequest : IWebkitRequest<HeapEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Heap.enable";
}
/// <summary>
/// Response from <see cref="HeapEnableRequest"/>
/// </summary>
internal partial class HeapEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables Heap domain events.
/// </summary>
/// <remarks>
/// Will send the command <c>Heap.disable</c>
/// </remarks>
internal partial class HeapDisableRequest : IWebkitRequest<HeapDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Heap.disable";
}
/// <summary>
/// Response from <see cref="HeapDisableRequest"/>
/// </summary>
internal partial class HeapDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Trigger a full garbage collection.
/// </summary>
/// <remarks>
/// Will send the command <c>Heap.gc</c>
/// </remarks>
internal partial class HeapGcRequest : IWebkitRequest<HeapGcResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Heap.gc";
}
/// <summary>
/// Response from <see cref="HeapGcRequest"/>
/// </summary>
internal partial class HeapGcResponse: IWebkitResponse
{
}
/// <summary>
/// Take a heap snapshot.
/// </summary>
/// <remarks>
/// Will send the command <c>Heap.snapshot</c>
/// </remarks>
internal partial class HeapSnapshotRequest : IWebkitRequest<HeapSnapshotResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Heap.snapshot";
}
/// <summary>
/// Response from <see cref="HeapSnapshotRequest"/>
/// </summary>
internal partial class HeapSnapshotResponse: IWebkitResponse
{
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// 
/// </summary>
public string SnapshotData { get; set; }}
/// <summary>
/// Start tracking heap changes. This will produce a `trackingStart` event.
/// </summary>
/// <remarks>
/// Will send the command <c>Heap.startTracking</c>
/// </remarks>
internal partial class HeapStartTrackingRequest : IWebkitRequest<HeapStartTrackingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Heap.startTracking";
}
/// <summary>
/// Response from <see cref="HeapStartTrackingRequest"/>
/// </summary>
internal partial class HeapStartTrackingResponse: IWebkitResponse
{
}
/// <summary>
/// Stop tracking heap changes. This will produce a `trackingComplete` event.
/// </summary>
/// <remarks>
/// Will send the command <c>Heap.stopTracking</c>
/// </remarks>
internal partial class HeapStopTrackingRequest : IWebkitRequest<HeapStopTrackingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Heap.stopTracking";
}
/// <summary>
/// Response from <see cref="HeapStopTrackingRequest"/>
/// </summary>
internal partial class HeapStopTrackingResponse: IWebkitResponse
{
}
/// <summary>
/// Returns a preview (string, Debugger.FunctionDetails, or Runtime.ObjectPreview) for a Heap.HeapObjectId.
/// </summary>
/// <remarks>
/// Will send the command <c>Heap.getPreview</c>
/// </remarks>
internal partial class HeapGetPreviewRequest : IWebkitRequest<HeapGetPreviewResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Heap.getPreview";
/// <summary>
/// Identifier of the heap object within the snapshot.
/// </summary>
public int? HeapObjectId { get; set; }}
/// <summary>
/// Response from <see cref="HeapGetPreviewRequest"/>
/// </summary>
internal partial class HeapGetPreviewResponse: IWebkitResponse
{
/// <summary>
/// String value.
/// </summary>
public string String { get; set; }
/// <summary>
/// Function details.
/// </summary>
public Debugger.FunctionDetails FunctionDetails { get; set; }
/// <summary>
/// Object preview.
/// </summary>
public Runtime.ObjectPreview Preview { get; set; }}
/// <summary>
/// Returns the strongly referenced Runtime.RemoteObject for a Heap.HeapObjectId.
/// </summary>
/// <remarks>
/// Will send the command <c>Heap.getRemoteObject</c>
/// </remarks>
internal partial class HeapGetRemoteObjectRequest : IWebkitRequest<HeapGetRemoteObjectResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Heap.getRemoteObject";
/// <summary>
/// Identifier of the heap object within the snapshot.
/// </summary>
public int? HeapObjectId { get; set; }
/// <summary>
/// Symbolic group name that can be used to release multiple objects.
/// </summary>
public string ObjectGroup { get; set; }}
/// <summary>
/// Response from <see cref="HeapGetRemoteObjectRequest"/>
/// </summary>
internal partial class HeapGetRemoteObjectResponse: IWebkitResponse
{
/// <summary>
/// Resulting object.
/// </summary>
public Runtime.RemoteObject Result { get; set; }}
/// <summary>
/// Information about the garbage collection.
/// </summary>
/// <remarks>
/// Matches on the event <c>Heap.garbageCollected</c>
/// </remarks>
internal partial class HeapGarbageCollectedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Heap.garbageCollected";
/// <summary>
/// 
/// </summary>
public GarbageCollection Collection { get; set; }}
/// <summary>
/// Tracking started.
/// </summary>
/// <remarks>
/// Matches on the event <c>Heap.trackingStart</c>
/// </remarks>
internal partial class HeapTrackingStartWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Heap.trackingStart";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// Snapshot at the start of tracking.
/// </summary>
public string SnapshotData { get; set; }}
/// <summary>
/// Tracking stopped.
/// </summary>
/// <remarks>
/// Matches on the event <c>Heap.trackingComplete</c>
/// </remarks>
internal partial class HeapTrackingCompleteWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Heap.trackingComplete";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// Snapshot at the end of tracking.
/// </summary>
public string SnapshotData { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.IndexedDB
{
/// <summary>
/// Database with an array of object stores.
/// </summary>
internal partial class DatabaseWithObjectStores
{
/// <summary>
/// Database name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Database version.
/// </summary>
public double? Version { get; set; }
/// <summary>
/// Object stores in this database.
/// </summary>
public ObjectStore[] ObjectStores { get; set; }}
/// <summary>
/// Object store.
/// </summary>
internal partial class ObjectStore
{
/// <summary>
/// Object store name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Object store key path.
/// </summary>
public KeyPath KeyPath { get; set; }
/// <summary>
/// If true, object store has auto increment flag set.
/// </summary>
public bool? AutoIncrement { get; set; }
/// <summary>
/// Indexes in this object store.
/// </summary>
public ObjectStoreIndex[] Indexes { get; set; }}
/// <summary>
/// Object store index.
/// </summary>
internal partial class ObjectStoreIndex
{
/// <summary>
/// Index name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Index key path.
/// </summary>
public KeyPath KeyPath { get; set; }
/// <summary>
/// If true, index is unique.
/// </summary>
public bool? Unique { get; set; }
/// <summary>
/// If true, index allows multiple entries for a key.
/// </summary>
public bool? MultiEntry { get; set; }}
/// <summary>
/// Key.
/// </summary>
internal partial class Key
{
/// <summary>
/// Key type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Number value.
/// </summary>
public double? Number { get; set; }
/// <summary>
/// String value.
/// </summary>
public string String { get; set; }
/// <summary>
/// Date value.
/// </summary>
public double? Date { get; set; }
/// <summary>
/// Array value.
/// </summary>
public Key[] Array { get; set; }}
/// <summary>
/// Key range.
/// </summary>
internal partial class KeyRange
{
/// <summary>
/// Lower bound.
/// </summary>
public Key Lower { get; set; }
/// <summary>
/// Upper bound.
/// </summary>
public Key Upper { get; set; }
/// <summary>
/// If true lower bound is open.
/// </summary>
public bool? LowerOpen { get; set; }
/// <summary>
/// If true upper bound is open.
/// </summary>
public bool? UpperOpen { get; set; }}
/// <summary>
/// Data entry.
/// </summary>
internal partial class DataEntry
{
/// <summary>
/// Key.
/// </summary>
public Runtime.RemoteObject Key { get; set; }
/// <summary>
/// Primary key.
/// </summary>
public Runtime.RemoteObject PrimaryKey { get; set; }
/// <summary>
/// Value.
/// </summary>
public Runtime.RemoteObject Value { get; set; }}
/// <summary>
/// Key path.
/// </summary>
internal partial class KeyPath
{
/// <summary>
/// Key path type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// String value.
/// </summary>
public string String { get; set; }
/// <summary>
/// Array value.
/// </summary>
public string[] Array { get; set; }}
/// <summary>
/// Enables events from backend.
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.enable</c>
/// </remarks>
internal partial class IndexedDBEnableRequest : IWebkitRequest<IndexedDBEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.enable";
}
/// <summary>
/// Response from <see cref="IndexedDBEnableRequest"/>
/// </summary>
internal partial class IndexedDBEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables events from backend.
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.disable</c>
/// </remarks>
internal partial class IndexedDBDisableRequest : IWebkitRequest<IndexedDBDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.disable";
}
/// <summary>
/// Response from <see cref="IndexedDBDisableRequest"/>
/// </summary>
internal partial class IndexedDBDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Requests database names for given security origin.
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.requestDatabaseNames</c>
/// </remarks>
internal partial class IndexedDBRequestDatabaseNamesRequest : IWebkitRequest<IndexedDBRequestDatabaseNamesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.requestDatabaseNames";
/// <summary>
/// Security origin.
/// </summary>
public string SecurityOrigin { get; set; }}
/// <summary>
/// Response from <see cref="IndexedDBRequestDatabaseNamesRequest"/>
/// </summary>
internal partial class IndexedDBRequestDatabaseNamesResponse: IWebkitResponse
{
/// <summary>
/// Database names for origin.
/// </summary>
public string[] DatabaseNames { get; set; }}
/// <summary>
/// Requests database with given name in given frame.
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.requestDatabase</c>
/// </remarks>
internal partial class IndexedDBRequestDatabaseRequest : IWebkitRequest<IndexedDBRequestDatabaseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.requestDatabase";
/// <summary>
/// Security origin.
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// Database name.
/// </summary>
public string DatabaseName { get; set; }}
/// <summary>
/// Response from <see cref="IndexedDBRequestDatabaseRequest"/>
/// </summary>
internal partial class IndexedDBRequestDatabaseResponse: IWebkitResponse
{
/// <summary>
/// Database with an array of object stores.
/// </summary>
public DatabaseWithObjectStores DatabaseWithObjectStores { get; set; }}
/// <summary>
/// Requests data from object store or index.
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.requestData</c>
/// </remarks>
internal partial class IndexedDBRequestDataRequest : IWebkitRequest<IndexedDBRequestDataResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.requestData";
/// <summary>
/// Security origin.
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// Database name.
/// </summary>
public string DatabaseName { get; set; }
/// <summary>
/// Object store name.
/// </summary>
public string ObjectStoreName { get; set; }
/// <summary>
/// Index name, empty string for object store data requests.
/// </summary>
public string IndexName { get; set; }
/// <summary>
/// Number of records to skip.
/// </summary>
public int? SkipCount { get; set; }
/// <summary>
/// Number of records to fetch.
/// </summary>
public int? PageSize { get; set; }
/// <summary>
/// Key range.
/// </summary>
public KeyRange KeyRange { get; set; }}
/// <summary>
/// Response from <see cref="IndexedDBRequestDataRequest"/>
/// </summary>
internal partial class IndexedDBRequestDataResponse: IWebkitResponse
{
/// <summary>
/// Array of object store data entries.
/// </summary>
public DataEntry[] ObjectStoreDataEntries { get; set; }
/// <summary>
/// If true, there are more entries to fetch in the given range.
/// </summary>
public bool? HasMore { get; set; }}
/// <summary>
/// Clears all entries from an object store.
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.clearObjectStore</c>
/// </remarks>
internal partial class IndexedDBClearObjectStoreRequest : IWebkitRequest<IndexedDBClearObjectStoreResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.clearObjectStore";
/// <summary>
/// Security origin.
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// Database name.
/// </summary>
public string DatabaseName { get; set; }
/// <summary>
/// Object store name.
/// </summary>
public string ObjectStoreName { get; set; }}
/// <summary>
/// Response from <see cref="IndexedDBClearObjectStoreRequest"/>
/// </summary>
internal partial class IndexedDBClearObjectStoreResponse: IWebkitResponse
{
}
}
namespace PlaywrightSharp.Webkit.Protocol.Input
{
/// <summary>
/// Dispatches a key event to the page.
/// </summary>
/// <remarks>
/// Will send the command <c>Input.dispatchKeyEvent</c>
/// </remarks>
internal partial class InputDispatchKeyEventRequest : IWebkitRequest<InputDispatchKeyEventResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Input.dispatchKeyEvent";
/// <summary>
/// Type of the key event.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Bit field representing pressed modifier keys. (default: 0).
/// </summary>
public int? Modifiers { get; set; }
/// <summary>
/// Text as generated by processing a virtual key code with a keyboard layout. Not needed for
/// for `keyUp` and `rawKeyDown` events (default: "")
/// </summary>
public string Text { get; set; }
/// <summary>
/// Text that would have been generated by the keyboard if no modifiers were pressed (except for
/// shift). Useful for shortcut (accelerator) key handling (default: "").
/// </summary>
public string UnmodifiedText { get; set; }
/// <summary>
/// Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
/// </summary>
public string Code { get; set; }
/// <summary>
/// Unique DOM defined string value describing the meaning of the key in the context of active
/// modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
/// </summary>
public string Key { get; set; }
/// <summary>
/// Windows virtual key code (default: 0).
/// </summary>
public int? WindowsVirtualKeyCode { get; set; }
/// <summary>
/// Native virtual key code (default: 0).
/// </summary>
public int? NativeVirtualKeyCode { get; set; }
/// <summary>
/// Whether the event was generated from auto repeat (default: false).
/// </summary>
public bool? AutoRepeat { get; set; }
/// <summary>
/// Whether the event was generated from the keypad (default: false).
/// </summary>
public bool? IsKeypad { get; set; }
/// <summary>
/// Whether the event was a system key event (default: false).
/// </summary>
public bool? IsSystemKey { get; set; }
/// <summary>
/// Mac editing commands associated with this key
/// </summary>
public string[] MacCommands { get; set; }}
/// <summary>
/// Response from <see cref="InputDispatchKeyEventRequest"/>
/// </summary>
internal partial class InputDispatchKeyEventResponse: IWebkitResponse
{
}
/// <summary>
/// Dispatches a mouse event to the page.
/// </summary>
/// <remarks>
/// Will send the command <c>Input.dispatchMouseEvent</c>
/// </remarks>
internal partial class InputDispatchMouseEventRequest : IWebkitRequest<InputDispatchMouseEventResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Input.dispatchMouseEvent";
/// <summary>
/// Type of the mouse event.
/// </summary>
public string Type { get; set; }
/// <summary>
/// X coordinate of the event relative to the main frame's viewport in CSS pixels.
/// </summary>
public int? X { get; set; }
/// <summary>
/// Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
/// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
/// </summary>
public int? Y { get; set; }
/// <summary>
/// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).
/// </summary>
public int? Modifiers { get; set; }
/// <summary>
/// Mouse button (default: "none").
/// </summary>
public string Button { get; set; }
/// <summary>
/// A number indicating which buttons are pressed on the mouse when a mouse event is triggered.
/// Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
/// </summary>
public int? Buttons { get; set; }
/// <summary>
/// Number of times the mouse button was clicked (default: 0).
/// </summary>
public int? ClickCount { get; set; }
/// <summary>
/// X delta in CSS pixels for mouse wheel event (default: 0).
/// </summary>
public int? DeltaX { get; set; }
/// <summary>
/// Y delta in CSS pixels for mouse wheel event (default: 0).
/// </summary>
public int? DeltaY { get; set; }}
/// <summary>
/// Response from <see cref="InputDispatchMouseEventRequest"/>
/// </summary>
internal partial class InputDispatchMouseEventResponse: IWebkitResponse
{
}
}
namespace PlaywrightSharp.Webkit.Protocol.Inspector
{
/// <summary>
/// Enables inspector domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Inspector.enable</c>
/// </remarks>
internal partial class InspectorEnableRequest : IWebkitRequest<InspectorEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Inspector.enable";
}
/// <summary>
/// Response from <see cref="InspectorEnableRequest"/>
/// </summary>
internal partial class InspectorEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables inspector domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Inspector.disable</c>
/// </remarks>
internal partial class InspectorDisableRequest : IWebkitRequest<InspectorDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Inspector.disable";
}
/// <summary>
/// Response from <see cref="InspectorDisableRequest"/>
/// </summary>
internal partial class InspectorDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Sent by the frontend after all initialization messages have been sent.
/// </summary>
/// <remarks>
/// Will send the command <c>Inspector.initialized</c>
/// </remarks>
internal partial class InspectorInitializedRequest : IWebkitRequest<InspectorInitializedResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Inspector.initialized";
}
/// <summary>
/// Response from <see cref="InspectorInitializedRequest"/>
/// </summary>
internal partial class InspectorInitializedResponse: IWebkitResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Inspector.evaluateForTestInFrontend</c>
/// </remarks>
internal partial class InspectorEvaluateForTestInFrontendWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Inspector.evaluateForTestInFrontend";
/// <summary>
/// 
/// </summary>
public string Script { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Inspector.inspect</c>
/// </remarks>
internal partial class InspectorInspectWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Inspector.inspect";
/// <summary>
/// 
/// </summary>
public Runtime.RemoteObject Object { get; set; }
/// <summary>
/// 
/// </summary>
public object Hints { get; set; }}
/// <summary>
/// Fired when the backend has alternate domains that need to be activated.
/// </summary>
/// <remarks>
/// Matches on the event <c>Inspector.activateExtraDomains</c>
/// </remarks>
internal partial class InspectorActivateExtraDomainsWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Inspector.activateExtraDomains";
/// <summary>
/// Domain names that need activation
/// </summary>
public string[] Domains { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.LayerTree
{
/// <summary>
/// A rectangle.
/// </summary>
internal partial class IntRect
{
/// <summary>
/// The x position.
/// </summary>
public int? X { get; set; }
/// <summary>
/// The y position.
/// </summary>
public int? Y { get; set; }
/// <summary>
/// The width metric.
/// </summary>
public int? Width { get; set; }
/// <summary>
/// The height metric.
/// </summary>
public int? Height { get; set; }}
/// <summary>
/// Information about a compositing layer.
/// </summary>
internal partial class Layer
{
/// <summary>
/// The unique id for this layer.
/// </summary>
public string LayerId { get; set; }
/// <summary>
/// The id for the node associated with this layer.
/// </summary>
public int? NodeId { get; set; }
/// <summary>
/// Bounds of the layer in absolute page coordinates.
/// </summary>
public IntRect Bounds { get; set; }
/// <summary>
/// Indicates how many time this layer has painted.
/// </summary>
public int? PaintCount { get; set; }
/// <summary>
/// Estimated memory used by this layer.
/// </summary>
public int? Memory { get; set; }
/// <summary>
/// The bounds of the composited layer.
/// </summary>
public IntRect CompositedBounds { get; set; }
/// <summary>
/// Indicates whether this layer is associated with an element hosted in a shadow tree.
/// </summary>
public bool? IsInShadowTree { get; set; }
/// <summary>
/// Indicates whether this layer was used to provide a reflection for the element.
/// </summary>
public bool? IsReflection { get; set; }
/// <summary>
/// Indicates whether the layer is attached to a pseudo element that is CSS generated content.
/// </summary>
public bool? IsGeneratedContent { get; set; }
/// <summary>
/// Indicates whether the layer was created for a CSS anonymous block or box.
/// </summary>
public bool? IsAnonymous { get; set; }
/// <summary>
/// The id for the pseudo element associated with this layer.
/// </summary>
public string PseudoElementId { get; set; }
/// <summary>
/// The name of the CSS pseudo-element that prompted the layer to be generated.
/// </summary>
public string PseudoElement { get; set; }}
/// <summary>
/// An object containing the reasons why the layer was composited as properties.
/// </summary>
internal partial class CompositingReasons
{
/// <summary>
/// Composition due to association with an element with a CSS 3D transform.
/// </summary>
public bool? Transform3D { get; set; }
/// <summary>
/// Composition due to association with a &lt;video&gt; element.
/// </summary>
public bool? Video { get; set; }
/// <summary>
/// Composition due to the element being a &lt;canvas&gt; element.
/// </summary>
public bool? Canvas { get; set; }
/// <summary>
/// Composition due to association with a plugin.
/// </summary>
public bool? Plugin { get; set; }
/// <summary>
/// Composition due to association with an &lt;iframe&gt; element.
/// </summary>
public bool? IFrame { get; set; }
/// <summary>
/// Composition due to association with an element with a "backface-visibility: hidden" style.
/// </summary>
public bool? BackfaceVisibilityHidden { get; set; }
/// <summary>
/// Composition due to association with an element clipping compositing descendants.
/// </summary>
public bool? ClipsCompositingDescendants { get; set; }
/// <summary>
/// Composition due to association with an animated element.
/// </summary>
public bool? Animation { get; set; }
/// <summary>
/// Composition due to association with an element with CSS filters applied.
/// </summary>
public bool? Filters { get; set; }
/// <summary>
/// Composition due to association with an element with a "position: fixed" style.
/// </summary>
public bool? PositionFixed { get; set; }
/// <summary>
/// Composition due to association with an element with a "position: sticky" style.
/// </summary>
public bool? PositionSticky { get; set; }
/// <summary>
/// Composition due to association with an element with a "overflow-scrolling: touch" style.
/// </summary>
public bool? OverflowScrollingTouch { get; set; }
/// <summary>
/// Composition due to association with an element establishing a stacking context.
/// </summary>
public bool? Stacking { get; set; }
/// <summary>
/// Composition due to association with an element overlapping other composited elements.
/// </summary>
public bool? Overlap { get; set; }
/// <summary>
/// Composition due to association with an element with descendants that have a negative z-index.
/// </summary>
public bool? NegativeZIndexChildren { get; set; }
/// <summary>
/// Composition due to association with an element with composited descendants.
/// </summary>
public bool? TransformWithCompositedDescendants { get; set; }
/// <summary>
/// Composition due to association with an element with opacity applied and composited descendants.
/// </summary>
public bool? OpacityWithCompositedDescendants { get; set; }
/// <summary>
/// Composition due to association with a masked element and composited descendants.
/// </summary>
public bool? MaskWithCompositedDescendants { get; set; }
/// <summary>
/// Composition due to association with an element with a reflection and composited descendants.
/// </summary>
public bool? ReflectionWithCompositedDescendants { get; set; }
/// <summary>
/// Composition due to association with an element with CSS filters applied and composited descendants.
/// </summary>
public bool? FilterWithCompositedDescendants { get; set; }
/// <summary>
/// Composition due to association with an element with CSS blending applied and composited descendants.
/// </summary>
public bool? BlendingWithCompositedDescendants { get; set; }
/// <summary>
/// Composition due to association with an element isolating compositing descendants having CSS blending applied.
/// </summary>
public bool? IsolatesCompositedBlendingDescendants { get; set; }
/// <summary>
/// Composition due to association with an element with perspective applied.
/// </summary>
public bool? Perspective { get; set; }
/// <summary>
/// Composition due to association with an element with a "transform-style: preserve-3d" style.
/// </summary>
public bool? Preserve3D { get; set; }
/// <summary>
/// Composition due to association with an element with a "will-change" style.
/// </summary>
public bool? WillChange { get; set; }
/// <summary>
/// Composition due to association with the root element.
/// </summary>
public bool? Root { get; set; }
/// <summary>
/// Composition due to association with an element with a "blend-mode" style.
/// </summary>
public bool? Blending { get; set; }}
/// <summary>
/// Enables compositing tree inspection.
/// </summary>
/// <remarks>
/// Will send the command <c>LayerTree.enable</c>
/// </remarks>
internal partial class LayerTreeEnableRequest : IWebkitRequest<LayerTreeEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "LayerTree.enable";
}
/// <summary>
/// Response from <see cref="LayerTreeEnableRequest"/>
/// </summary>
internal partial class LayerTreeEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables compositing tree inspection.
/// </summary>
/// <remarks>
/// Will send the command <c>LayerTree.disable</c>
/// </remarks>
internal partial class LayerTreeDisableRequest : IWebkitRequest<LayerTreeDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "LayerTree.disable";
}
/// <summary>
/// Response from <see cref="LayerTreeDisableRequest"/>
/// </summary>
internal partial class LayerTreeDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Returns the layer tree structure of the current page.
/// </summary>
/// <remarks>
/// Will send the command <c>LayerTree.layersForNode</c>
/// </remarks>
internal partial class LayerTreeLayersForNodeRequest : IWebkitRequest<LayerTreeLayersForNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "LayerTree.layersForNode";
/// <summary>
/// Root of the subtree for which we want to gather layers.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Response from <see cref="LayerTreeLayersForNodeRequest"/>
/// </summary>
internal partial class LayerTreeLayersForNodeResponse: IWebkitResponse
{
/// <summary>
/// Child layers.
/// </summary>
public Layer[] Layers { get; set; }}
/// <summary>
/// Provides the reasons why the given layer was composited.
/// </summary>
/// <remarks>
/// Will send the command <c>LayerTree.reasonsForCompositingLayer</c>
/// </remarks>
internal partial class LayerTreeReasonsForCompositingLayerRequest : IWebkitRequest<LayerTreeReasonsForCompositingLayerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "LayerTree.reasonsForCompositingLayer";
/// <summary>
/// The id of the layer for which we want to get the reasons it was composited.
/// </summary>
public string LayerId { get; set; }}
/// <summary>
/// Response from <see cref="LayerTreeReasonsForCompositingLayerRequest"/>
/// </summary>
internal partial class LayerTreeReasonsForCompositingLayerResponse: IWebkitResponse
{
/// <summary>
/// An object containing the reasons why the layer was composited as properties.
/// </summary>
public CompositingReasons CompositingReasons { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>LayerTree.layerTreeDidChange</c>
/// </remarks>
internal partial class LayerTreeLayerTreeDidChangeWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "LayerTree.layerTreeDidChange";
}
}
namespace PlaywrightSharp.Webkit.Protocol.Memory
{
/// <summary>
/// 
/// </summary>
internal partial class Event
{
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// Breakdown of memory in categories.
/// </summary>
public CategoryData[] Categories { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class CategoryData
{
/// <summary>
/// Category type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Category size in bytes.
/// </summary>
public double? Size { get; set; }}
/// <summary>
/// Enables Memory domain events.
/// </summary>
/// <remarks>
/// Will send the command <c>Memory.enable</c>
/// </remarks>
internal partial class MemoryEnableRequest : IWebkitRequest<MemoryEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Memory.enable";
}
/// <summary>
/// Response from <see cref="MemoryEnableRequest"/>
/// </summary>
internal partial class MemoryEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables Memory domain events.
/// </summary>
/// <remarks>
/// Will send the command <c>Memory.disable</c>
/// </remarks>
internal partial class MemoryDisableRequest : IWebkitRequest<MemoryDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Memory.disable";
}
/// <summary>
/// Response from <see cref="MemoryDisableRequest"/>
/// </summary>
internal partial class MemoryDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Start tracking memory. This will produce a `trackingStart` event.
/// </summary>
/// <remarks>
/// Will send the command <c>Memory.startTracking</c>
/// </remarks>
internal partial class MemoryStartTrackingRequest : IWebkitRequest<MemoryStartTrackingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Memory.startTracking";
}
/// <summary>
/// Response from <see cref="MemoryStartTrackingRequest"/>
/// </summary>
internal partial class MemoryStartTrackingResponse: IWebkitResponse
{
}
/// <summary>
/// Stop tracking memory. This will produce a `trackingComplete` event.
/// </summary>
/// <remarks>
/// Will send the command <c>Memory.stopTracking</c>
/// </remarks>
internal partial class MemoryStopTrackingRequest : IWebkitRequest<MemoryStopTrackingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Memory.stopTracking";
}
/// <summary>
/// Response from <see cref="MemoryStopTrackingRequest"/>
/// </summary>
internal partial class MemoryStopTrackingResponse: IWebkitResponse
{
}
/// <summary>
/// Memory pressure was encountered.
/// </summary>
/// <remarks>
/// Matches on the event <c>Memory.memoryPressure</c>
/// </remarks>
internal partial class MemoryMemoryPressureWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Memory.memoryPressure";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// The severity of the memory pressure event.
/// </summary>
public string Severity { get; set; }}
/// <summary>
/// Tracking started.
/// </summary>
/// <remarks>
/// Matches on the event <c>Memory.trackingStart</c>
/// </remarks>
internal partial class MemoryTrackingStartWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Memory.trackingStart";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }}
/// <summary>
/// Periodic tracking updates with event data.
/// </summary>
/// <remarks>
/// Matches on the event <c>Memory.trackingUpdate</c>
/// </remarks>
internal partial class MemoryTrackingUpdateWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Memory.trackingUpdate";
/// <summary>
/// 
/// </summary>
public Event Event { get; set; }}
/// <summary>
/// Tracking stopped.
/// </summary>
/// <remarks>
/// Matches on the event <c>Memory.trackingComplete</c>
/// </remarks>
internal partial class MemoryTrackingCompleteWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Memory.trackingComplete";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Network
{
/// <summary>
/// Request / response headers as keys / values of JSON object.
/// </summary>
internal partial class Headers
{
}
/// <summary>
/// Timing information for the request.
/// </summary>
internal partial class ResourceTiming
{
/// <summary>
/// Request is initiated
/// </summary>
public double? StartTime { get; set; }
/// <summary>
/// Started redirect resolution.
/// </summary>
public double? RedirectStart { get; set; }
/// <summary>
/// Finished redirect resolution.
/// </summary>
public double? RedirectEnd { get; set; }
/// <summary>
/// Resource fetching started.
/// </summary>
public double? FetchStart { get; set; }
/// <summary>
/// Started DNS address resolve in milliseconds relative to fetchStart.
/// </summary>
public double? DomainLookupStart { get; set; }
/// <summary>
/// Finished DNS address resolve in milliseconds relative to fetchStart.
/// </summary>
public double? DomainLookupEnd { get; set; }
/// <summary>
/// Started connecting to the remote host in milliseconds relative to fetchStart.
/// </summary>
public double? ConnectStart { get; set; }
/// <summary>
/// Connected to the remote host in milliseconds relative to fetchStart.
/// </summary>
public double? ConnectEnd { get; set; }
/// <summary>
/// Started SSL handshake in milliseconds relative to fetchStart.
/// </summary>
public double? SecureConnectionStart { get; set; }
/// <summary>
/// Started sending request in milliseconds relative to fetchStart.
/// </summary>
public double? RequestStart { get; set; }
/// <summary>
/// Started receiving response headers in milliseconds relative to fetchStart.
/// </summary>
public double? ResponseStart { get; set; }
/// <summary>
/// Finished receiving response headers in milliseconds relative to fetchStart.
/// </summary>
public double? ResponseEnd { get; set; }}
/// <summary>
/// HTTP request data.
/// </summary>
internal partial class Request
{
/// <summary>
/// Request URL.
/// </summary>
public string Url { get; set; }
/// <summary>
/// HTTP request method.
/// </summary>
public string Method { get; set; }
/// <summary>
/// HTTP request headers.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }
/// <summary>
/// HTTP POST request data.
/// </summary>
public string PostData { get; set; }}
/// <summary>
/// HTTP response data.
/// </summary>
internal partial class Response
{
/// <summary>
/// Response URL. This URL can be different from CachedResource.url in case of redirect.
/// </summary>
public string Url { get; set; }
/// <summary>
/// HTTP response status code.
/// </summary>
public int? Status { get; set; }
/// <summary>
/// HTTP response status text.
/// </summary>
public string StatusText { get; set; }
/// <summary>
/// HTTP response headers.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }
/// <summary>
/// Resource mimeType as determined by the browser.
/// </summary>
public string MimeType { get; set; }
/// <summary>
/// Specifies where the response came from.
/// </summary>
public string Source { get; set; }
/// <summary>
/// Refined HTTP request headers that were actually transmitted over the network.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> RequestHeaders { get; set; }
/// <summary>
/// Timing information for the given request.
/// </summary>
public ResourceTiming Timing { get; set; }
/// <summary>
/// The security information for the given request.
/// </summary>
public Security.Security Security { get; set; }}
/// <summary>
/// Network load metrics.
/// </summary>
internal partial class Metrics
{
/// <summary>
/// Network protocol. ALPN Protocol ID Identification Sequence, as per RFC 7301 (for example, http/2, http/1.1, spdy/3.1)
/// </summary>
public string Protocol { get; set; }
/// <summary>
/// Network priority.
/// </summary>
public string Priority { get; set; }
/// <summary>
/// Connection identifier.
/// </summary>
public string ConnectionIdentifier { get; set; }
/// <summary>
/// Remote IP address.
/// </summary>
public string RemoteAddress { get; set; }
/// <summary>
/// Refined HTTP request headers that were actually transmitted over the network.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> RequestHeaders { get; set; }
/// <summary>
/// Total HTTP request header bytes sent over the network.
/// </summary>
public double? RequestHeaderBytesSent { get; set; }
/// <summary>
/// Total HTTP request body bytes sent over the network.
/// </summary>
public double? RequestBodyBytesSent { get; set; }
/// <summary>
/// Total HTTP response header bytes received over the network.
/// </summary>
public double? ResponseHeaderBytesReceived { get; set; }
/// <summary>
/// Total HTTP response body bytes received over the network.
/// </summary>
public double? ResponseBodyBytesReceived { get; set; }
/// <summary>
/// Total decoded response body size in bytes.
/// </summary>
public double? ResponseBodyDecodedSize { get; set; }
/// <summary>
/// Connection information for the completed request.
/// </summary>
public Security.Connection SecurityConnection { get; set; }}
/// <summary>
/// WebSocket request data.
/// </summary>
internal partial class WebSocketRequest
{
/// <summary>
/// HTTP response headers.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }}
/// <summary>
/// WebSocket response data.
/// </summary>
internal partial class WebSocketResponse
{
/// <summary>
/// HTTP response status code.
/// </summary>
public int? Status { get; set; }
/// <summary>
/// HTTP response status text.
/// </summary>
public string StatusText { get; set; }
/// <summary>
/// HTTP response headers.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }}
/// <summary>
/// WebSocket frame data.
/// </summary>
internal partial class WebSocketFrame
{
/// <summary>
/// WebSocket frame opcode.
/// </summary>
public double? Opcode { get; set; }
/// <summary>
/// WebSocket frame mask.
/// </summary>
public bool? Mask { get; set; }
/// <summary>
/// WebSocket frame payload data.
/// </summary>
public string PayloadData { get; set; }
/// <summary>
/// WebSocket frame payload length in bytes.
/// </summary>
public double? PayloadLength { get; set; }}
/// <summary>
/// Information about the cached resource.
/// </summary>
internal partial class CachedResource
{
/// <summary>
/// Resource URL. This is the url of the original network request.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Type of this resource.
/// </summary>
public Page.ResourceType Type { get; set; }
/// <summary>
/// Cached response data.
/// </summary>
public Response Response { get; set; }
/// <summary>
/// Cached response body size.
/// </summary>
public double? BodySize { get; set; }
/// <summary>
/// URL of source map associated with this resource (if any).
/// </summary>
public string SourceMapURL { get; set; }}
/// <summary>
/// Information about the request initiator.
/// </summary>
internal partial class Initiator
{
/// <summary>
/// Type of this initiator.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Initiator JavaScript stack trace, set for Script only.
/// </summary>
public Console.CallFrame[] StackTrace { get; set; }
/// <summary>
/// Initiator URL, set for Parser type only.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Initiator line number, set for Parser type only.
/// </summary>
public double? LineNumber { get; set; }
/// <summary>
/// Set if the load was triggered by a DOM node, in addition to the other initiator information.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Different stages of a network request.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum NetworkStage
{
[System.Runtime.Serialization.EnumMember(Value = "response")]Response}
/// <summary>
/// Enables network tracking, network events will now be delivered to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.enable</c>
/// </remarks>
internal partial class NetworkEnableRequest : IWebkitRequest<NetworkEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.enable";
}
/// <summary>
/// Response from <see cref="NetworkEnableRequest"/>
/// </summary>
internal partial class NetworkEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables network tracking, prevents network events from being sent to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.disable</c>
/// </remarks>
internal partial class NetworkDisableRequest : IWebkitRequest<NetworkDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.disable";
}
/// <summary>
/// Response from <see cref="NetworkDisableRequest"/>
/// </summary>
internal partial class NetworkDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Specifies whether to always send extra HTTP headers with the requests from this page.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.setExtraHTTPHeaders</c>
/// </remarks>
internal partial class NetworkSetExtraHTTPHeadersRequest : IWebkitRequest<NetworkSetExtraHTTPHeadersResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.setExtraHTTPHeaders";
/// <summary>
/// Map with extra HTTP headers.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }}
/// <summary>
/// Response from <see cref="NetworkSetExtraHTTPHeadersRequest"/>
/// </summary>
internal partial class NetworkSetExtraHTTPHeadersResponse: IWebkitResponse
{
}
/// <summary>
/// Returns content served for the given request.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.getResponseBody</c>
/// </remarks>
internal partial class NetworkGetResponseBodyRequest : IWebkitRequest<NetworkGetResponseBodyResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.getResponseBody";
/// <summary>
/// Identifier of the network request to get content for.
/// </summary>
public string RequestId { get; set; }}
/// <summary>
/// Response from <see cref="NetworkGetResponseBodyRequest"/>
/// </summary>
internal partial class NetworkGetResponseBodyResponse: IWebkitResponse
{
/// <summary>
/// Response body.
/// </summary>
public string Body { get; set; }
/// <summary>
/// True, if content was sent as base64.
/// </summary>
public bool? Base64Encoded { get; set; }}
/// <summary>
/// Toggles whether the resource cache may be used when loading resources in the inspected page. If &lt;code&gt;true&lt;/code&gt;, the resource cache will not be used when loading resources.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.setResourceCachingDisabled</c>
/// </remarks>
internal partial class NetworkSetResourceCachingDisabledRequest : IWebkitRequest<NetworkSetResourceCachingDisabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.setResourceCachingDisabled";
/// <summary>
/// Whether to prevent usage of the resource cache.
/// </summary>
public bool? Disabled { get; set; }}
/// <summary>
/// Response from <see cref="NetworkSetResourceCachingDisabledRequest"/>
/// </summary>
internal partial class NetworkSetResourceCachingDisabledResponse: IWebkitResponse
{
}
/// <summary>
/// Loads a resource in the context of a frame on the inspected page without cross origin checks.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.loadResource</c>
/// </remarks>
internal partial class NetworkLoadResourceRequest : IWebkitRequest<NetworkLoadResourceResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.loadResource";
/// <summary>
/// Frame to load the resource from.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// URL of the resource to load.
/// </summary>
public string Url { get; set; }}
/// <summary>
/// Response from <see cref="NetworkLoadResourceRequest"/>
/// </summary>
internal partial class NetworkLoadResourceResponse: IWebkitResponse
{
/// <summary>
/// Resource content.
/// </summary>
public string Content { get; set; }
/// <summary>
/// Resource mimeType.
/// </summary>
public string MimeType { get; set; }
/// <summary>
/// HTTP response status code.
/// </summary>
public int? Status { get; set; }}
/// <summary>
/// Fetches a serialized secure certificate for the given requestId to be displayed via InspectorFrontendHost.showCertificate.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.getSerializedCertificate</c>
/// </remarks>
internal partial class NetworkGetSerializedCertificateRequest : IWebkitRequest<NetworkGetSerializedCertificateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.getSerializedCertificate";
/// <summary>
/// 
/// </summary>
public string RequestId { get; set; }}
/// <summary>
/// Response from <see cref="NetworkGetSerializedCertificateRequest"/>
/// </summary>
internal partial class NetworkGetSerializedCertificateResponse: IWebkitResponse
{
/// <summary>
/// Represents a base64 encoded WebCore::CertificateInfo object.
/// </summary>
public string SerializedCertificate { get; set; }}
/// <summary>
/// Resolves JavaScript WebSocket object for given request id.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.resolveWebSocket</c>
/// </remarks>
internal partial class NetworkResolveWebSocketRequest : IWebkitRequest<NetworkResolveWebSocketResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.resolveWebSocket";
/// <summary>
/// Identifier of the WebSocket resource to resolve.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Symbolic group name that can be used to release multiple objects.
/// </summary>
public string ObjectGroup { get; set; }}
/// <summary>
/// Response from <see cref="NetworkResolveWebSocketRequest"/>
/// </summary>
internal partial class NetworkResolveWebSocketResponse: IWebkitResponse
{
/// <summary>
/// JavaScript object wrapper for given node.
/// </summary>
public Runtime.RemoteObject Object { get; set; }}
/// <summary>
/// Enable interception of network requests.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.setInterceptionEnabled</c>
/// </remarks>
internal partial class NetworkSetInterceptionEnabledRequest : IWebkitRequest<NetworkSetInterceptionEnabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.setInterceptionEnabled";
/// <summary>
/// 
/// </summary>
public bool? Enabled { get; set; }
/// <summary>
/// 
/// </summary>
public bool? InterceptRequests { get; set; }}
/// <summary>
/// Response from <see cref="NetworkSetInterceptionEnabledRequest"/>
/// </summary>
internal partial class NetworkSetInterceptionEnabledResponse: IWebkitResponse
{
}
/// <summary>
/// Add an interception.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.addInterception</c>
/// </remarks>
internal partial class NetworkAddInterceptionRequest : IWebkitRequest<NetworkAddInterceptionResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.addInterception";
/// <summary>
/// 
/// </summary>
public string Url { get; set; }
/// <summary>
/// If false, ignores letter casing of `url` parameter.
/// </summary>
public bool? CaseSensitive { get; set; }
/// <summary>
/// If true, treats `url` parameter as a regular expression.
/// </summary>
public bool? IsRegex { get; set; }
/// <summary>
/// If not present this applies to all network stages.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public NetworkStage Stage { get; set; }}
/// <summary>
/// Response from <see cref="NetworkAddInterceptionRequest"/>
/// </summary>
internal partial class NetworkAddInterceptionResponse: IWebkitResponse
{
}
/// <summary>
/// Remove an interception.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.removeInterception</c>
/// </remarks>
internal partial class NetworkRemoveInterceptionRequest : IWebkitRequest<NetworkRemoveInterceptionResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.removeInterception";
/// <summary>
/// 
/// </summary>
public string Url { get; set; }
/// <summary>
/// If false, ignores letter casing of `url` parameter.
/// </summary>
public bool? CaseSensitive { get; set; }
/// <summary>
/// If true, treats `url` parameter as a regular expression.
/// </summary>
public bool? IsRegex { get; set; }
/// <summary>
/// If not present this applies to all network stages.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public NetworkStage Stage { get; set; }}
/// <summary>
/// Response from <see cref="NetworkRemoveInterceptionRequest"/>
/// </summary>
internal partial class NetworkRemoveInterceptionResponse: IWebkitResponse
{
}
/// <summary>
/// Continue an interception with no modifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.interceptContinue</c>
/// </remarks>
internal partial class NetworkInterceptContinueRequest : IWebkitRequest<NetworkInterceptContinueResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.interceptContinue";
/// <summary>
/// Identifier for the intercepted Network request or response to continue.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// HTTP request method.
/// </summary>
public string Method { get; set; }
/// <summary>
/// HTTP response headers. Pass through original values if unmodified.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }
/// <summary>
/// HTTP POST request data.
/// </summary>
public string PostData { get; set; }}
/// <summary>
/// Response from <see cref="NetworkInterceptContinueRequest"/>
/// </summary>
internal partial class NetworkInterceptContinueResponse: IWebkitResponse
{
}
/// <summary>
/// Abort the intercepted request with given reason.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.interceptAsError</c>
/// </remarks>
internal partial class NetworkInterceptAsErrorRequest : IWebkitRequest<NetworkInterceptAsErrorResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.interceptAsError";
/// <summary>
/// Identifier for the intercepted Network request.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Deliver error reason for the request.
/// </summary>
public string Reason { get; set; }}
/// <summary>
/// Response from <see cref="NetworkInterceptAsErrorRequest"/>
/// </summary>
internal partial class NetworkInterceptAsErrorResponse: IWebkitResponse
{
}
/// <summary>
/// Provide response content for an intercepted response.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.interceptWithResponse</c>
/// </remarks>
internal partial class NetworkInterceptWithResponseRequest : IWebkitRequest<NetworkInterceptWithResponseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.interceptWithResponse";
/// <summary>
/// Identifier for the intercepted Network response to modify.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// 
/// </summary>
public string Content { get; set; }
/// <summary>
/// True, if content was sent as base64.
/// </summary>
public bool? Base64Encoded { get; set; }
/// <summary>
/// MIME Type for the data.
/// </summary>
public string MimeType { get; set; }
/// <summary>
/// HTTP response status code. Pass through original values if unmodified.
/// </summary>
public int? Status { get; set; }
/// <summary>
/// HTTP response status text. Pass through original values if unmodified.
/// </summary>
public string StatusText { get; set; }
/// <summary>
/// HTTP response headers. Pass through original values if unmodified.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }}
/// <summary>
/// Response from <see cref="NetworkInterceptWithResponseRequest"/>
/// </summary>
internal partial class NetworkInterceptWithResponseResponse: IWebkitResponse
{
}
/// <summary>
/// Emulate offline state overriding the actual state.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.setEmulateOfflineState</c>
/// </remarks>
internal partial class NetworkSetEmulateOfflineStateRequest : IWebkitRequest<NetworkSetEmulateOfflineStateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.setEmulateOfflineState";
/// <summary>
/// True to emulate offline.
/// </summary>
public bool? Offline { get; set; }}
/// <summary>
/// Response from <see cref="NetworkSetEmulateOfflineStateRequest"/>
/// </summary>
internal partial class NetworkSetEmulateOfflineStateResponse: IWebkitResponse
{
}
/// <summary>
/// Fired when page is about to send HTTP request.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.requestWillBeSent</c>
/// </remarks>
internal partial class NetworkRequestWillBeSentWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.requestWillBeSent";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Frame identifier.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Loader identifier.
/// </summary>
public string LoaderId { get; set; }
/// <summary>
/// URL of the document this request is loaded for.
/// </summary>
public string DocumentURL { get; set; }
/// <summary>
/// Request data.
/// </summary>
public Request Request { get; set; }
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// 
/// </summary>
public double? Walltime { get; set; }
/// <summary>
/// Request initiator.
/// </summary>
public Initiator Initiator { get; set; }
/// <summary>
/// Redirect response data.
/// </summary>
public Response RedirectResponse { get; set; }
/// <summary>
/// Resource type.
/// </summary>
public Page.ResourceType Type { get; set; }
/// <summary>
/// Identifier for the context of where the load originated. In general this is the target identifier. For Workers this will be the workerId.
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// Fired when HTTP response is available.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.responseReceived</c>
/// </remarks>
internal partial class NetworkResponseReceivedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.responseReceived";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Frame identifier.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Loader identifier.
/// </summary>
public string LoaderId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// Resource type.
/// </summary>
public Page.ResourceType Type { get; set; }
/// <summary>
/// Response data.
/// </summary>
public Response Response { get; set; }}
/// <summary>
/// Fired when data chunk was received over the network.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.dataReceived</c>
/// </remarks>
internal partial class NetworkDataReceivedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.dataReceived";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// Data chunk length.
/// </summary>
public int? DataLength { get; set; }
/// <summary>
/// Actual bytes received (might be less than dataLength for compressed encodings).
/// </summary>
public int? EncodedDataLength { get; set; }}
/// <summary>
/// Fired when HTTP request has finished loading.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.loadingFinished</c>
/// </remarks>
internal partial class NetworkLoadingFinishedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.loadingFinished";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// URL of source map associated with this resource (if any).
/// </summary>
public string SourceMapURL { get; set; }
/// <summary>
/// Network metrics.
/// </summary>
public Metrics Metrics { get; set; }}
/// <summary>
/// Fired when HTTP request has failed to load.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.loadingFailed</c>
/// </remarks>
internal partial class NetworkLoadingFailedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.loadingFailed";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// User friendly error message.
/// </summary>
public string ErrorText { get; set; }
/// <summary>
/// True if loading was canceled.
/// </summary>
public bool? Canceled { get; set; }}
/// <summary>
/// Fired when HTTP request has been served from memory cache.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.requestServedFromMemoryCache</c>
/// </remarks>
internal partial class NetworkRequestServedFromMemoryCacheWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.requestServedFromMemoryCache";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Frame identifier.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Loader identifier.
/// </summary>
public string LoaderId { get; set; }
/// <summary>
/// URL of the document this request is loaded for.
/// </summary>
public string DocumentURL { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// Request initiator.
/// </summary>
public Initiator Initiator { get; set; }
/// <summary>
/// Cached resource data.
/// </summary>
public CachedResource Resource { get; set; }}
/// <summary>
/// Fired when HTTP response has been intercepted. The frontend must response with &lt;code&gt;Network.interceptContinue&lt;/code&gt; or &lt;code&gt;Network.interceptWithRespons&lt;/code&gt;` to continue this response.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.responseIntercepted</c>
/// </remarks>
internal partial class NetworkResponseInterceptedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.responseIntercepted";
/// <summary>
/// Identifier for this intercepted network. Corresponds with an earlier &lt;code&gt;Network.requestWillBeSent&lt;/code&gt;.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Original response content that would proceed if this is continued.
/// </summary>
public Response Response { get; set; }}
/// <summary>
/// Fired when HTTP request has been intercepted. The frontend must response with &lt;code&gt;Network.interceptContinue&lt;/code&gt; or &lt;code&gt;Network.interceptWithRespons&lt;/code&gt;` to continue this response.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.requestIntercepted</c>
/// </remarks>
internal partial class NetworkRequestInterceptedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.requestIntercepted";
/// <summary>
/// Identifier for this intercepted network. Corresponds with an earlier &lt;code&gt;Network.requestWillBeSent&lt;/code&gt;.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Original request content that would proceed if this is continued.
/// </summary>
public Request Request { get; set; }}
/// <summary>
/// Fired when WebSocket is about to initiate handshake.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.webSocketWillSendHandshakeRequest</c>
/// </remarks>
internal partial class NetworkWebSocketWillSendHandshakeRequestWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.webSocketWillSendHandshakeRequest";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// 
/// </summary>
public double? Walltime { get; set; }
/// <summary>
/// WebSocket request data.
/// </summary>
public WebSocketRequest Request { get; set; }}
/// <summary>
/// Fired when WebSocket handshake response becomes available.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.webSocketHandshakeResponseReceived</c>
/// </remarks>
internal partial class NetworkWebSocketHandshakeResponseReceivedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.webSocketHandshakeResponseReceived";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// WebSocket response data.
/// </summary>
public WebSocketResponse Response { get; set; }}
/// <summary>
/// Fired upon WebSocket creation.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.webSocketCreated</c>
/// </remarks>
internal partial class NetworkWebSocketCreatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.webSocketCreated";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// WebSocket request URL.
/// </summary>
public string Url { get; set; }}
/// <summary>
/// Fired when WebSocket is closed.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.webSocketClosed</c>
/// </remarks>
internal partial class NetworkWebSocketClosedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.webSocketClosed";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double? Timestamp { get; set; }}
/// <summary>
/// Fired when WebSocket frame is received.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.webSocketFrameReceived</c>
/// </remarks>
internal partial class NetworkWebSocketFrameReceivedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.webSocketFrameReceived";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// WebSocket response data.
/// </summary>
public WebSocketFrame Response { get; set; }}
/// <summary>
/// Fired when WebSocket frame error occurs.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.webSocketFrameError</c>
/// </remarks>
internal partial class NetworkWebSocketFrameErrorWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.webSocketFrameError";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// WebSocket frame error message.
/// </summary>
public string ErrorMessage { get; set; }}
/// <summary>
/// Fired when WebSocket frame is sent.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.webSocketFrameSent</c>
/// </remarks>
internal partial class NetworkWebSocketFrameSentWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Network.webSocketFrameSent";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// WebSocket response data.
/// </summary>
public WebSocketFrame Response { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Page
{
/// <summary>
/// List of settings able to be overridden by WebInspector. Keep this in sync with FOR_EACH_INSPECTOR_OVERRIDE_SETTING.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum Setting
{
[System.Runtime.Serialization.EnumMember(Value = "AuthorAndUserStylesEnabled")]AuthorAndUserStylesEnabled,
[System.Runtime.Serialization.EnumMember(Value = "ICECandidateFilteringEnabled")]ICECandidateFilteringEnabled,
[System.Runtime.Serialization.EnumMember(Value = "ImagesEnabled")]ImagesEnabled,
[System.Runtime.Serialization.EnumMember(Value = "MediaCaptureRequiresSecureConnection")]MediaCaptureRequiresSecureConnection,
[System.Runtime.Serialization.EnumMember(Value = "MockCaptureDevicesEnabled")]MockCaptureDevicesEnabled,
[System.Runtime.Serialization.EnumMember(Value = "NeedsSiteSpecificQuirks")]NeedsSiteSpecificQuirks,
[System.Runtime.Serialization.EnumMember(Value = "ScriptEnabled")]ScriptEnabled,
[System.Runtime.Serialization.EnumMember(Value = "ShowDebugBorders")]ShowDebugBorders,
[System.Runtime.Serialization.EnumMember(Value = "ShowRepaintCounter")]ShowRepaintCounter,
[System.Runtime.Serialization.EnumMember(Value = "WebRTCEncryptionEnabled")]WebRTCEncryptionEnabled,
[System.Runtime.Serialization.EnumMember(Value = "WebSecurityEnabled")]WebSecurityEnabled}
/// <summary>
/// Resource type as it was perceived by the rendering engine.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum ResourceType
{
[System.Runtime.Serialization.EnumMember(Value = "Document")]Document,
[System.Runtime.Serialization.EnumMember(Value = "StyleSheet")]StyleSheet,
[System.Runtime.Serialization.EnumMember(Value = "Image")]Image,
[System.Runtime.Serialization.EnumMember(Value = "Font")]Font,
[System.Runtime.Serialization.EnumMember(Value = "Script")]Script,
[System.Runtime.Serialization.EnumMember(Value = "XHR")]XHR,
[System.Runtime.Serialization.EnumMember(Value = "Fetch")]Fetch,
[System.Runtime.Serialization.EnumMember(Value = "Ping")]Ping,
[System.Runtime.Serialization.EnumMember(Value = "Beacon")]Beacon,
[System.Runtime.Serialization.EnumMember(Value = "WebSocket")]WebSocket,
[System.Runtime.Serialization.EnumMember(Value = "Other")]Other}
/// <summary>
/// Coordinate system used by supplied coordinates.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum CoordinateSystem
{
[System.Runtime.Serialization.EnumMember(Value = "Viewport")]Viewport,
[System.Runtime.Serialization.EnumMember(Value = "Page")]Page}
/// <summary>
/// Same-Site policy of a cookie.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum CookieSameSitePolicy
{
[System.Runtime.Serialization.EnumMember(Value = "None")]None,
[System.Runtime.Serialization.EnumMember(Value = "Lax")]Lax,
[System.Runtime.Serialization.EnumMember(Value = "Strict")]Strict}
/// <summary>
/// Page appearance name.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum Appearance
{
[System.Runtime.Serialization.EnumMember(Value = "Light")]Light,
[System.Runtime.Serialization.EnumMember(Value = "Dark")]Dark}
/// <summary>
/// Information about the Frame on the page.
/// </summary>
internal partial class Frame
{
/// <summary>
/// Frame unique identifier.
/// </summary>
public string Id { get; set; }
/// <summary>
/// Parent frame identifier.
/// </summary>
public string ParentId { get; set; }
/// <summary>
/// Identifier of the loader associated with this frame.
/// </summary>
public string LoaderId { get; set; }
/// <summary>
/// Frame's name as specified in the tag.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Frame document's URL.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Frame document's security origin.
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// Frame document's mimeType as determined by the browser.
/// </summary>
public string MimeType { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class FrameResource
{
/// <summary>
/// Resource URL.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Type of this resource.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public ResourceType Type { get; set; }
/// <summary>
/// Resource mimeType as determined by the browser.
/// </summary>
public string MimeType { get; set; }
/// <summary>
/// True if the resource failed to load.
/// </summary>
public bool? Failed { get; set; }
/// <summary>
/// True if the resource was canceled during loading.
/// </summary>
public bool? Canceled { get; set; }
/// <summary>
/// URL of source map associated with this resource (if any).
/// </summary>
public string SourceMapURL { get; set; }
/// <summary>
/// Identifier for the context of where the load originated. In general this is the target identifier. For Workers this will be the workerId.
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// Information about the Frame hierarchy along with their cached resources.
/// </summary>
internal partial class FrameResourceTree
{
/// <summary>
/// Frame information for this tree item.
/// </summary>
public Frame Frame { get; set; }
/// <summary>
/// Child frames.
/// </summary>
public FrameResourceTree[] ChildFrames { get; set; }
/// <summary>
/// Information about frame resources.
/// </summary>
public FrameResource[] Resources { get; set; }}
/// <summary>
/// Search result for resource.
/// </summary>
internal partial class SearchResult
{
/// <summary>
/// Resource URL.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Resource frame id.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Number of matches in the resource content.
/// </summary>
public double? MatchesCount { get; set; }
/// <summary>
/// Network request id.
/// </summary>
public string RequestId { get; set; }}
/// <summary>
/// Cookie object
/// </summary>
internal partial class Cookie
{
/// <summary>
/// Cookie name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Cookie value.
/// </summary>
public string Value { get; set; }
/// <summary>
/// Cookie domain.
/// </summary>
public string Domain { get; set; }
/// <summary>
/// Cookie path.
/// </summary>
public string Path { get; set; }
/// <summary>
/// Cookie expires.
/// </summary>
public double? Expires { get; set; }
/// <summary>
/// Cookie size.
/// </summary>
public int? Size { get; set; }
/// <summary>
/// True if cookie is http-only.
/// </summary>
public bool? HttpOnly { get; set; }
/// <summary>
/// True if cookie is secure.
/// </summary>
public bool? Secure { get; set; }
/// <summary>
/// True in case of session cookie.
/// </summary>
public bool? Session { get; set; }
/// <summary>
/// Cookie Same-Site policy.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public CookieSameSitePolicy SameSite { get; set; }}
/// <summary>
/// Accessibility Node
/// </summary>
internal partial class AXNode
{
/// <summary>
/// The role.
/// </summary>
public string Role { get; set; }
/// <summary>
/// A human readable name for the node.
/// </summary>
public string Name { get; set; }
/// <summary>
/// The current value of the node.
/// </summary>
public object Value { get; set; }
/// <summary>
/// An additional human readable description of the node.
/// </summary>
public string Description { get; set; }
/// <summary>
/// Keyboard shortcuts associated with this node.
/// </summary>
public string Keyshortcuts { get; set; }
/// <summary>
/// A human readable alternative to the role.
/// </summary>
public string Roledescription { get; set; }
/// <summary>
/// A description of the current value.
/// </summary>
public string Valuetext { get; set; }
/// <summary>
/// Whether the node is disabled.
/// </summary>
public bool? Disabled { get; set; }
/// <summary>
/// Whether the node is expanded or collapsed.
/// </summary>
public bool? Expanded { get; set; }
/// <summary>
/// Whether the node is focused.
/// </summary>
public bool? Focused { get; set; }
/// <summary>
/// Whether the node is modal.
/// </summary>
public bool? Modal { get; set; }
/// <summary>
/// Whether the node text input supports multiline.
/// </summary>
public bool? Multiline { get; set; }
/// <summary>
/// Whether more than one child can be selected.
/// </summary>
public bool? Multiselectable { get; set; }
/// <summary>
/// Whether the node is read only.
/// </summary>
public bool? Readonly { get; set; }
/// <summary>
/// Whether the node is required.
/// </summary>
public bool? Required { get; set; }
/// <summary>
/// Whether the node is selected in its parent node.
/// </summary>
public bool? Selected { get; set; }
/// <summary>
/// Whether the checkbox is checked, or "mixed".
/// </summary>
public string Checked { get; set; }
/// <summary>
/// Whether the toggle button is checked, or "mixed".
/// </summary>
public string Pressed { get; set; }
/// <summary>
/// The level of a heading.
/// </summary>
public int? Level { get; set; }
/// <summary>
/// The minimum value in a node.
/// </summary>
public double? Valuemin { get; set; }
/// <summary>
/// The maximum value in a node.
/// </summary>
public double? Valuemax { get; set; }
/// <summary>
/// What kind of autocomplete is supported by a control.
/// </summary>
public string Autocomplete { get; set; }
/// <summary>
/// What kind of popup is currently being shown for a node.
/// </summary>
public string Haspopup { get; set; }
/// <summary>
/// Whether and in what way this node's value is invalid.
/// </summary>
public string Invalid { get; set; }
/// <summary>
/// Whether the node is oriented horizontally or vertically.
/// </summary>
public string Orientation { get; set; }
/// <summary>
/// Whether the node is focusable.
/// </summary>
public bool? Focusable { get; set; }
/// <summary>
/// Child AXNodes of this node, if any.
/// </summary>
public AXNode[] Children { get; set; }
/// <summary>
/// True if this AXNode corresponds with the ObjectId passed into acessibilitySnapshot.
/// </summary>
public bool? Found { get; set; }}
/// <summary>
/// Enables page domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.enable</c>
/// </remarks>
internal partial class PageEnableRequest : IWebkitRequest<PageEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.enable";
}
/// <summary>
/// Response from <see cref="PageEnableRequest"/>
/// </summary>
internal partial class PageEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables page domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.disable</c>
/// </remarks>
internal partial class PageDisableRequest : IWebkitRequest<PageDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.disable";
}
/// <summary>
/// Response from <see cref="PageDisableRequest"/>
/// </summary>
internal partial class PageDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Reloads the main frame of the inspected page.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.reload</c>
/// </remarks>
internal partial class PageReloadRequest : IWebkitRequest<PageReloadResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.reload";
/// <summary>
/// If true, the page is reloaded from its origin without using cached resources.
/// </summary>
public bool? IgnoreCache { get; set; }
/// <summary>
/// If true, all cached subresources will be revalidated when the main resource loads. Otherwise, only expired cached subresources will be revalidated (the default behavior for most WebKit clients).
/// </summary>
public bool? RevalidateAllResources { get; set; }}
/// <summary>
/// Response from <see cref="PageReloadRequest"/>
/// </summary>
internal partial class PageReloadResponse: IWebkitResponse
{
}
/// <summary>
/// Goes back in the history.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.goBack</c>
/// </remarks>
internal partial class PageGoBackRequest : IWebkitRequest<PageGoBackResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.goBack";
}
/// <summary>
/// Response from <see cref="PageGoBackRequest"/>
/// </summary>
internal partial class PageGoBackResponse: IWebkitResponse
{
}
/// <summary>
/// Goes forward in the history.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.goForward</c>
/// </remarks>
internal partial class PageGoForwardRequest : IWebkitRequest<PageGoForwardResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.goForward";
}
/// <summary>
/// Response from <see cref="PageGoForwardRequest"/>
/// </summary>
internal partial class PageGoForwardResponse: IWebkitResponse
{
}
/// <summary>
/// Navigates current page to the given URL.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.navigate</c>
/// </remarks>
internal partial class PageNavigateRequest : IWebkitRequest<PageNavigateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.navigate";
/// <summary>
/// URL to navigate the page to.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Id of the frame to navigate.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Referrer URL.
/// </summary>
public string Referrer { get; set; }}
/// <summary>
/// Response from <see cref="PageNavigateRequest"/>
/// </summary>
internal partial class PageNavigateResponse: IWebkitResponse
{
}
/// <summary>
/// Override's the user agent of the inspected page
/// </summary>
/// <remarks>
/// Will send the command <c>Page.overrideUserAgent</c>
/// </remarks>
internal partial class PageOverrideUserAgentRequest : IWebkitRequest<PageOverrideUserAgentResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.overrideUserAgent";
/// <summary>
/// Value to override the user agent with. If this value is not provided, the override is removed. Overrides are removed when Web Inspector closes/disconnects.
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Response from <see cref="PageOverrideUserAgentRequest"/>
/// </summary>
internal partial class PageOverrideUserAgentResponse: IWebkitResponse
{
}
/// <summary>
/// Allows the frontend to override the inspected page's settings.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.overrideSetting</c>
/// </remarks>
internal partial class PageOverrideSettingRequest : IWebkitRequest<PageOverrideSettingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.overrideSetting";
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public Setting Setting { get; set; }
/// <summary>
/// Value to override the setting with. If this value is not provided, the override is removed. Overrides are removed when Web Inspector closes/disconnects.
/// </summary>
public bool? Value { get; set; }}
/// <summary>
/// Response from <see cref="PageOverrideSettingRequest"/>
/// </summary>
internal partial class PageOverrideSettingResponse: IWebkitResponse
{
}
/// <summary>
/// Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the &lt;code&gt;cookies&lt;/code&gt; field.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.getCookies</c>
/// </remarks>
internal partial class PageGetCookiesRequest : IWebkitRequest<PageGetCookiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.getCookies";
}
/// <summary>
/// Response from <see cref="PageGetCookiesRequest"/>
/// </summary>
internal partial class PageGetCookiesResponse: IWebkitResponse
{
/// <summary>
/// Array of cookie objects.
/// </summary>
public Cookie[] Cookies { get; set; }}
/// <summary>
/// Deletes browser cookie with given name, domain and path.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.deleteCookie</c>
/// </remarks>
internal partial class PageDeleteCookieRequest : IWebkitRequest<PageDeleteCookieResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.deleteCookie";
/// <summary>
/// Name of the cookie to remove.
/// </summary>
public string CookieName { get; set; }
/// <summary>
/// URL to match cookie domain and path.
/// </summary>
public string Url { get; set; }}
/// <summary>
/// Response from <see cref="PageDeleteCookieRequest"/>
/// </summary>
internal partial class PageDeleteCookieResponse: IWebkitResponse
{
}
/// <summary>
/// Returns present frame / resource tree structure.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.getResourceTree</c>
/// </remarks>
internal partial class PageGetResourceTreeRequest : IWebkitRequest<PageGetResourceTreeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.getResourceTree";
}
/// <summary>
/// Response from <see cref="PageGetResourceTreeRequest"/>
/// </summary>
internal partial class PageGetResourceTreeResponse: IWebkitResponse
{
/// <summary>
/// Present frame / resource tree structure.
/// </summary>
public FrameResourceTree FrameTree { get; set; }}
/// <summary>
/// Returns content of the given resource.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.getResourceContent</c>
/// </remarks>
internal partial class PageGetResourceContentRequest : IWebkitRequest<PageGetResourceContentResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.getResourceContent";
/// <summary>
/// Frame id to get resource for.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// URL of the resource to get content for.
/// </summary>
public string Url { get; set; }}
/// <summary>
/// Response from <see cref="PageGetResourceContentRequest"/>
/// </summary>
internal partial class PageGetResourceContentResponse: IWebkitResponse
{
/// <summary>
/// Resource content.
/// </summary>
public string Content { get; set; }
/// <summary>
/// True, if content was served as base64.
/// </summary>
public bool? Base64Encoded { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setBootstrapScript</c>
/// </remarks>
internal partial class PageSetBootstrapScriptRequest : IWebkitRequest<PageSetBootstrapScriptResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setBootstrapScript";
/// <summary>
/// If `source` is provided (and not empty), it will be injected into all future global objects as soon as they're created. Omitting `source` will stop this from happening.
/// </summary>
public string Source { get; set; }}
/// <summary>
/// Response from <see cref="PageSetBootstrapScriptRequest"/>
/// </summary>
internal partial class PageSetBootstrapScriptResponse: IWebkitResponse
{
}
/// <summary>
/// Searches for given string in resource content.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.searchInResource</c>
/// </remarks>
internal partial class PageSearchInResourceRequest : IWebkitRequest<PageSearchInResourceResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.searchInResource";
/// <summary>
/// Frame id for resource to search in.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// URL of the resource to search in.
/// </summary>
public string Url { get; set; }
/// <summary>
/// String to search for.
/// </summary>
public string Query { get; set; }
/// <summary>
/// If true, search is case sensitive.
/// </summary>
public bool? CaseSensitive { get; set; }
/// <summary>
/// If true, treats string parameter as regex.
/// </summary>
public bool? IsRegex { get; set; }
/// <summary>
/// Request id for resource to search in.
/// </summary>
public string RequestId { get; set; }}
/// <summary>
/// Response from <see cref="PageSearchInResourceRequest"/>
/// </summary>
internal partial class PageSearchInResourceResponse: IWebkitResponse
{
/// <summary>
/// List of search matches.
/// </summary>
public GenericTypes.SearchMatch[] Result { get; set; }}
/// <summary>
/// Searches for given string in frame / resource tree structure.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.searchInResources</c>
/// </remarks>
internal partial class PageSearchInResourcesRequest : IWebkitRequest<PageSearchInResourcesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.searchInResources";
/// <summary>
/// String to search for.
/// </summary>
public string Text { get; set; }
/// <summary>
/// If true, search is case sensitive.
/// </summary>
public bool? CaseSensitive { get; set; }
/// <summary>
/// If true, treats string parameter as regex.
/// </summary>
public bool? IsRegex { get; set; }}
/// <summary>
/// Response from <see cref="PageSearchInResourcesRequest"/>
/// </summary>
internal partial class PageSearchInResourcesResponse: IWebkitResponse
{
/// <summary>
/// List of search results.
/// </summary>
public SearchResult[] Result { get; set; }}
/// <summary>
/// Requests that backend draw rulers in the inspector overlay
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setShowRulers</c>
/// </remarks>
internal partial class PageSetShowRulersRequest : IWebkitRequest<PageSetShowRulersResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setShowRulers";
/// <summary>
/// True for showing rulers
/// </summary>
public bool? Result { get; set; }}
/// <summary>
/// Response from <see cref="PageSetShowRulersRequest"/>
/// </summary>
internal partial class PageSetShowRulersResponse: IWebkitResponse
{
}
/// <summary>
/// Requests that backend shows paint rectangles
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setShowPaintRects</c>
/// </remarks>
internal partial class PageSetShowPaintRectsRequest : IWebkitRequest<PageSetShowPaintRectsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setShowPaintRects";
/// <summary>
/// True for showing paint rectangles
/// </summary>
public bool? Result { get; set; }}
/// <summary>
/// Response from <see cref="PageSetShowPaintRectsRequest"/>
/// </summary>
internal partial class PageSetShowPaintRectsResponse: IWebkitResponse
{
}
/// <summary>
/// Emulates the given media for CSS media queries.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setEmulatedMedia</c>
/// </remarks>
internal partial class PageSetEmulatedMediaRequest : IWebkitRequest<PageSetEmulatedMediaResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setEmulatedMedia";
/// <summary>
/// Media type to emulate. Empty string disables the override.
/// </summary>
public string Media { get; set; }}
/// <summary>
/// Response from <see cref="PageSetEmulatedMediaRequest"/>
/// </summary>
internal partial class PageSetEmulatedMediaResponse: IWebkitResponse
{
}
/// <summary>
/// Forces the given appearance for the page.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setForcedAppearance</c>
/// </remarks>
internal partial class PageSetForcedAppearanceRequest : IWebkitRequest<PageSetForcedAppearanceResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setForcedAppearance";
/// <summary>
/// Appearance name to force. Empty string disables the override.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public Appearance Appearance { get; set; }}
/// <summary>
/// Response from <see cref="PageSetForcedAppearanceRequest"/>
/// </summary>
internal partial class PageSetForcedAppearanceResponse: IWebkitResponse
{
}
/// <summary>
/// Enables touch events on platforms that lack them.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setTouchEmulationEnabled</c>
/// </remarks>
internal partial class PageSetTouchEmulationEnabledRequest : IWebkitRequest<PageSetTouchEmulationEnabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setTouchEmulationEnabled";
/// <summary>
/// Whether touch should be enabled.
/// </summary>
public bool? Enabled { get; set; }}
/// <summary>
/// Response from <see cref="PageSetTouchEmulationEnabledRequest"/>
/// </summary>
internal partial class PageSetTouchEmulationEnabledResponse: IWebkitResponse
{
}
/// <summary>
/// Capture a snapshot of the specified node that does not include unrelated layers.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.snapshotNode</c>
/// </remarks>
internal partial class PageSnapshotNodeRequest : IWebkitRequest<PageSnapshotNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.snapshotNode";
/// <summary>
/// Id of the node to snapshot.
/// </summary>
public int? NodeId { get; set; }}
/// <summary>
/// Response from <see cref="PageSnapshotNodeRequest"/>
/// </summary>
internal partial class PageSnapshotNodeResponse: IWebkitResponse
{
/// <summary>
/// Base64-encoded image data (PNG).
/// </summary>
public string DataURL { get; set; }}
/// <summary>
/// Capture a snapshot of the page within the specified rectangle and coordinate system.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.snapshotRect</c>
/// </remarks>
internal partial class PageSnapshotRectRequest : IWebkitRequest<PageSnapshotRectResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.snapshotRect";
/// <summary>
/// X coordinate
/// </summary>
public int? X { get; set; }
/// <summary>
/// Y coordinate
/// </summary>
public int? Y { get; set; }
/// <summary>
/// Rectangle width
/// </summary>
public int? Width { get; set; }
/// <summary>
/// Rectangle height
/// </summary>
public int? Height { get; set; }
/// <summary>
/// Indicates the coordinate system of the supplied rectangle.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public CoordinateSystem CoordinateSystem { get; set; }}
/// <summary>
/// Response from <see cref="PageSnapshotRectRequest"/>
/// </summary>
internal partial class PageSnapshotRectResponse: IWebkitResponse
{
/// <summary>
/// Base64-encoded image data (PNG).
/// </summary>
public string DataURL { get; set; }}
/// <summary>
/// Grab an archive of the page.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.archive</c>
/// </remarks>
internal partial class PageArchiveRequest : IWebkitRequest<PageArchiveResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.archive";
}
/// <summary>
/// Response from <see cref="PageArchiveRequest"/>
/// </summary>
internal partial class PageArchiveResponse: IWebkitResponse
{
/// <summary>
/// Base64-encoded web archive.
/// </summary>
public string Data { get; set; }}
/// <summary>
/// Insert text into the current selection of the page.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.insertText</c>
/// </remarks>
internal partial class PageInsertTextRequest : IWebkitRequest<PageInsertTextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.insertText";
/// <summary>
/// Text to insert.
/// </summary>
public string Text { get; set; }}
/// <summary>
/// Response from <see cref="PageInsertTextRequest"/>
/// </summary>
internal partial class PageInsertTextResponse: IWebkitResponse
{
}
/// <summary>
/// Serializes and returns all of the accessibility nodes of the page.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.accessibilitySnapshot</c>
/// </remarks>
internal partial class PageAccessibilitySnapshotRequest : IWebkitRequest<PageAccessibilitySnapshotResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.accessibilitySnapshot";
/// <summary>
/// Object Id of a node to find in the accessibility tree.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="PageAccessibilitySnapshotRequest"/>
/// </summary>
internal partial class PageAccessibilitySnapshotResponse: IWebkitResponse
{
/// <summary>
/// The root AXNode.
/// </summary>
public AXNode AxNode { get; set; }}
/// <summary>
/// Intercepts file chooser dialog
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setInterceptFileChooserDialog</c>
/// </remarks>
internal partial class PageSetInterceptFileChooserDialogRequest : IWebkitRequest<PageSetInterceptFileChooserDialogResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setInterceptFileChooserDialog";
/// <summary>
/// True to enable.
/// </summary>
public bool? Enabled { get; set; }}
/// <summary>
/// Response from <see cref="PageSetInterceptFileChooserDialogRequest"/>
/// </summary>
internal partial class PageSetInterceptFileChooserDialogResponse: IWebkitResponse
{
}
/// <summary>
/// Sets or clears an override of the default background color of the frame. This override is used if the content does not specify one.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setDefaultBackgroundColorOverride</c>
/// </remarks>
internal partial class PageSetDefaultBackgroundColorOverrideRequest : IWebkitRequest<PageSetDefaultBackgroundColorOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setDefaultBackgroundColorOverride";
/// <summary>
/// RGBA of the default background color. If not specified, any existing override will be cleared.
/// </summary>
public DOM.RGBAColor Color { get; set; }}
/// <summary>
/// Response from <see cref="PageSetDefaultBackgroundColorOverrideRequest"/>
/// </summary>
internal partial class PageSetDefaultBackgroundColorOverrideResponse: IWebkitResponse
{
}
/// <summary>
/// Creates an user world for every loaded frame.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.createUserWorld</c>
/// </remarks>
internal partial class PageCreateUserWorldRequest : IWebkitRequest<PageCreateUserWorldResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.createUserWorld";
/// <summary>
/// Isolated world name, will be used as an execution context name.
/// </summary>
public string Name { get; set; }}
/// <summary>
/// Response from <see cref="PageCreateUserWorldRequest"/>
/// </summary>
internal partial class PageCreateUserWorldResponse: IWebkitResponse
{
}
/// <summary>
/// Enable page Content Security Policy by-passing.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setBypassCSP</c>
/// </remarks>
internal partial class PageSetBypassCSPRequest : IWebkitRequest<PageSetBypassCSPResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setBypassCSP";
/// <summary>
/// Whether to bypass page CSP.
/// </summary>
public bool? Enabled { get; set; }}
/// <summary>
/// Response from <see cref="PageSetBypassCSPRequest"/>
/// </summary>
internal partial class PageSetBypassCSPResponse: IWebkitResponse
{
}
/// <summary>
/// Crashes the page process
/// </summary>
/// <remarks>
/// Will send the command <c>Page.crash</c>
/// </remarks>
internal partial class PageCrashRequest : IWebkitRequest<PageCrashResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.crash";
}
/// <summary>
/// Response from <see cref="PageCrashRequest"/>
/// </summary>
internal partial class PageCrashResponse: IWebkitResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.domContentEventFired</c>
/// </remarks>
internal partial class PageDomContentEventFiredWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Page.domContentEventFired";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// Id of the frame that has fired DOMContentLoaded event.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.loadEventFired</c>
/// </remarks>
internal partial class PageLoadEventFiredWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Page.loadEventFired";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// Id of the frame that has fired load event.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Fired once navigation of the frame has completed. Frame is now associated with the new loader.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameNavigated</c>
/// </remarks>
internal partial class PageFrameNavigatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Page.frameNavigated";
/// <summary>
/// Frame object.
/// </summary>
public Frame Frame { get; set; }}
/// <summary>
/// Fired when frame has been attached to its parent.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameAttached</c>
/// </remarks>
internal partial class PageFrameAttachedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Page.frameAttached";
/// <summary>
/// Id of the frame that has been detached.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Parent frame id if non-root.
/// </summary>
public string ParentFrameId { get; set; }}
/// <summary>
/// Fired when frame has been detached from its parent.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameDetached</c>
/// </remarks>
internal partial class PageFrameDetachedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Page.frameDetached";
/// <summary>
/// Id of the frame that has been detached.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Fired when frame has started loading.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameStartedLoading</c>
/// </remarks>
internal partial class PageFrameStartedLoadingWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Page.frameStartedLoading";
/// <summary>
/// Id of the frame that has started loading.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Fired when frame has stopped loading.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameStoppedLoading</c>
/// </remarks>
internal partial class PageFrameStoppedLoadingWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Page.frameStoppedLoading";
/// <summary>
/// Id of the frame that has stopped loading.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Fired when frame schedules a potential navigation.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameScheduledNavigation</c>
/// </remarks>
internal partial class PageFrameScheduledNavigationWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Page.frameScheduledNavigation";
/// <summary>
/// Id of the frame that has scheduled a navigation.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Delay (in seconds) until the navigation is scheduled to begin. The navigation is not guaranteed to start.
/// </summary>
public double? Delay { get; set; }}
/// <summary>
/// Fired when frame no longer has a scheduled navigation.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameClearedScheduledNavigation</c>
/// </remarks>
internal partial class PageFrameClearedScheduledNavigationWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Page.frameClearedScheduledNavigation";
/// <summary>
/// Id of the frame that has cleared its scheduled navigation.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.navigatedWithinDocument</c>
/// </remarks>
internal partial class PageNavigatedWithinDocumentWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Page.navigatedWithinDocument";
/// <summary>
/// Id of the frame.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Frame's new url.
/// </summary>
public string Url { get; set; }}
/// <summary>
/// Fired when page's default appearance changes, even if there is a forced appearance.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.defaultAppearanceDidChange</c>
/// </remarks>
internal partial class PageDefaultAppearanceDidChangeWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Page.defaultAppearanceDidChange";
/// <summary>
/// Name of the appearance that is active (not considering any forced appearance.)
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public Appearance Appearance { get; set; }}
/// <summary>
/// Fired when the page shows file chooser for it's &lt;input type=file&gt;.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.fileChooserOpened</c>
/// </remarks>
internal partial class PageFileChooserOpenedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Page.fileChooserOpened";
/// <summary>
/// Frame where file chooser is opened.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Input element.
/// </summary>
public Runtime.RemoteObject Element { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Recording
{
/// <summary>
/// The type of the recording.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum Type
{
[System.Runtime.Serialization.EnumMember(Value = "canvas-2d")]Canvas2D,
[System.Runtime.Serialization.EnumMember(Value = "canvas-bitmaprenderer")]CanvasBitmaprenderer,
[System.Runtime.Serialization.EnumMember(Value = "canvas-webgl")]CanvasWebgl,
[System.Runtime.Serialization.EnumMember(Value = "canvas-webgl2")]CanvasWebgl2}
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum Initiator
{
[System.Runtime.Serialization.EnumMember(Value = "frontend")]Frontend,
[System.Runtime.Serialization.EnumMember(Value = "console")]Console,
[System.Runtime.Serialization.EnumMember(Value = "auto-capture")]AutoCapture}
/// <summary>
/// Information about the initial state of the recorded object.
/// </summary>
internal partial class InitialState
{
/// <summary>
/// Key-value map for each attribute of the state.
/// </summary>
public object Attributes { get; set; }
/// <summary>
/// Array of saved states of the context.
/// </summary>
public object[] States { get; set; }
/// <summary>
/// Array of values that were used to construct the recorded object.
/// </summary>
public object[] Parameters { get; set; }
/// <summary>
/// Current content at the start of the recording.
/// </summary>
public string Content { get; set; }}
/// <summary>
/// Container object for a single frame of the recording.
/// </summary>
internal partial class Frame
{
/// <summary>
/// Information about an action made to the recorded object. Follows the structure [name, parameters, swizzleTypes, trace], where name is a string, parameters is an array, swizzleTypes is an array, and trace is an array.
/// </summary>
public object[] Actions { get; set; }
/// <summary>
/// Total execution time of all actions recorded in this frame in milliseconds. 
/// </summary>
public double? Duration { get; set; }
/// <summary>
/// Flag indicating if the recording was stopped before this frame ended.
/// </summary>
public bool? Incomplete { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class Recording
{
/// <summary>
/// Used for future/backwards compatibility.
/// </summary>
public int? Version { get; set; }
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public Type Type { get; set; }
/// <summary>
/// JSON data of inital state of object before recording.
/// </summary>
public InitialState InitialState { get; set; }
/// <summary>
/// Array of objects that can be referenced by index. Used to avoid duplicating objects.
/// </summary>
public object[] Data { get; set; }
/// <summary>
/// 
/// </summary>
public string Name { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Runtime
{
/// <summary>
/// Mirror object referencing original JavaScript object.
/// </summary>
internal partial class RemoteObject
{
/// <summary>
/// Object type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Object subtype hint. Specified for &lt;code&gt;object&lt;/code&gt; &lt;code&gt;function&lt;/code&gt; (for class) type values only.
/// </summary>
public string Subtype { get; set; }
/// <summary>
/// Object class (constructor) name. Specified for &lt;code&gt;object&lt;/code&gt; type values only.
/// </summary>
public string ClassName { get; set; }
/// <summary>
/// Remote object value (in case of primitive values or JSON values if it was requested).
/// </summary>
public object Value { get; set; }
/// <summary>
/// String representation of the object.
/// </summary>
public string Description { get; set; }
/// <summary>
/// Unique object identifier (for non-primitive values).
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// Size of the array/collection. Specified for array/map/set/weakmap/weakset object type values only.
/// </summary>
public int? Size { get; set; }
/// <summary>
/// Remote object for the class prototype. Specified for class object type values only.
/// </summary>
public RemoteObject ClassPrototype { get; set; }
/// <summary>
/// Preview containing abbreviated property values. Specified for &lt;code&gt;object&lt;/code&gt; type values only.
/// </summary>
public ObjectPreview Preview { get; set; }}
/// <summary>
/// Object containing abbreviated remote object value.
/// </summary>
internal partial class ObjectPreview
{
/// <summary>
/// Object type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Object subtype hint. Specified for &lt;code&gt;object&lt;/code&gt; type values only.
/// </summary>
public string Subtype { get; set; }
/// <summary>
/// String representation of the object.
/// </summary>
public string Description { get; set; }
/// <summary>
/// Determines whether preview is lossless (contains all information of the original object).
/// </summary>
public bool? Lossless { get; set; }
/// <summary>
/// True iff some of the properties of the original did not fit.
/// </summary>
public bool? Overflow { get; set; }
/// <summary>
/// List of the properties.
/// </summary>
public PropertyPreview[] Properties { get; set; }
/// <summary>
/// List of the entries. Specified for &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; subtype values only.
/// </summary>
public EntryPreview[] Entries { get; set; }
/// <summary>
/// Size of the array/collection. Specified for array/map/set/weakmap/weakset object type values only.
/// </summary>
public int? Size { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class PropertyPreview
{
/// <summary>
/// Property name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Object type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Object subtype hint. Specified for &lt;code&gt;object&lt;/code&gt; type values only.
/// </summary>
public string Subtype { get; set; }
/// <summary>
/// User-friendly property value string.
/// </summary>
public string Value { get; set; }
/// <summary>
/// Nested value preview.
/// </summary>
public ObjectPreview ValuePreview { get; set; }
/// <summary>
/// True if this is an internal property.
/// </summary>
public bool? Internal { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class EntryPreview
{
/// <summary>
/// Entry key. Specified for map-like collection entries.
/// </summary>
public ObjectPreview Key { get; set; }
/// <summary>
/// Entry value.
/// </summary>
public ObjectPreview Value { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class CollectionEntry
{
/// <summary>
/// Entry key of a map-like collection, otherwise not provided.
/// </summary>
public Runtime.RemoteObject Key { get; set; }
/// <summary>
/// Entry value.
/// </summary>
public Runtime.RemoteObject Value { get; set; }}
/// <summary>
/// Object property descriptor.
/// </summary>
internal partial class PropertyDescriptor
{
/// <summary>
/// Property name or symbol description.
/// </summary>
public string Name { get; set; }
/// <summary>
/// The value associated with the property.
/// </summary>
public RemoteObject Value { get; set; }
/// <summary>
/// True if the value associated with the property may be changed (data descriptors only).
/// </summary>
public bool? Writable { get; set; }
/// <summary>
/// A function which serves as a getter for the property, or &lt;code&gt;undefined&lt;/code&gt; if there is no getter (accessor descriptors only).
/// </summary>
public RemoteObject Get { get; set; }
/// <summary>
/// A function which serves as a setter for the property, or &lt;code&gt;undefined&lt;/code&gt; if there is no setter (accessor descriptors only).
/// </summary>
public RemoteObject Set { get; set; }
/// <summary>
/// True if the result was thrown during the evaluation.
/// </summary>
public bool? WasThrown { get; set; }
/// <summary>
/// True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.
/// </summary>
public bool? Configurable { get; set; }
/// <summary>
/// True if this property shows up during enumeration of the properties on the corresponding object.
/// </summary>
public bool? Enumerable { get; set; }
/// <summary>
/// True if the property is owned for the object.
/// </summary>
public bool? IsOwn { get; set; }
/// <summary>
/// Property symbol object, if the property is a symbol.
/// </summary>
public Runtime.RemoteObject Symbol { get; set; }
/// <summary>
/// True if the property value came from a native getter.
/// </summary>
public bool? NativeGetter { get; set; }}
/// <summary>
/// Object internal property descriptor. This property isn't normally visible in JavaScript code.
/// </summary>
internal partial class InternalPropertyDescriptor
{
/// <summary>
/// Conventional property name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// The value associated with the property.
/// </summary>
public RemoteObject Value { get; set; }}
/// <summary>
/// Represents function call argument. Either remote object id &lt;code&gt;objectId&lt;/code&gt; or primitive &lt;code&gt;value&lt;/code&gt; or neither of (for undefined) them should be specified.
/// </summary>
internal partial class CallArgument
{
/// <summary>
/// Primitive value.
/// </summary>
public object Value { get; set; }
/// <summary>
/// Remote object handle.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Type of the execution context.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum ExecutionContextType
{
[System.Runtime.Serialization.EnumMember(Value = "normal")]Normal,
[System.Runtime.Serialization.EnumMember(Value = "user")]User,
[System.Runtime.Serialization.EnumMember(Value = "internal")]Internal}
/// <summary>
/// Description of an isolated world.
/// </summary>
internal partial class ExecutionContextDescription
{
/// <summary>
/// Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed.
/// </summary>
public int? Id { get; set; }
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public ExecutionContextType Type { get; set; }
/// <summary>
/// Human readable name describing given context.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Id of the owning frame.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Syntax error type: "none" for no error, "irrecoverable" for unrecoverable errors, "unterminated-literal" for when there is an unterminated literal, "recoverable" for when the expression is unfinished but valid so far.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum SyntaxErrorType
{
[System.Runtime.Serialization.EnumMember(Value = "none")]None,
[System.Runtime.Serialization.EnumMember(Value = "irrecoverable")]Irrecoverable,
[System.Runtime.Serialization.EnumMember(Value = "unterminated-literal")]UnterminatedLiteral,
[System.Runtime.Serialization.EnumMember(Value = "recoverable")]Recoverable}
/// <summary>
/// Range of an error in source code.
/// </summary>
internal partial class ErrorRange
{
/// <summary>
/// Start offset of range (inclusive).
/// </summary>
public int? StartOffset { get; set; }
/// <summary>
/// End offset of range (exclusive).
/// </summary>
public int? EndOffset { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class StructureDescription
{
/// <summary>
/// Array of strings, where the strings represent object properties.
/// </summary>
public string[] Fields { get; set; }
/// <summary>
/// Array of strings, where the strings represent optional object properties.
/// </summary>
public string[] OptionalFields { get; set; }
/// <summary>
/// Name of the constructor.
/// </summary>
public string ConstructorName { get; set; }
/// <summary>
/// Pointer to the StructureRepresentation of the protoype if one exists.
/// </summary>
public StructureDescription PrototypeStructure { get; set; }
/// <summary>
/// If true, it indicates that the fields in this StructureDescription may be inaccurate. I.e, there might have been fields that have been deleted before it was profiled or it has fields we haven't profiled.
/// </summary>
public bool? IsImprecise { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class TypeSet
{
/// <summary>
/// Indicates if this type description has been type Function.
/// </summary>
public bool? IsFunction { get; set; }
/// <summary>
/// Indicates if this type description has been type Undefined.
/// </summary>
public bool? IsUndefined { get; set; }
/// <summary>
/// Indicates if this type description has been type Null.
/// </summary>
public bool? IsNull { get; set; }
/// <summary>
/// Indicates if this type description has been type Boolean.
/// </summary>
public bool? IsBoolean { get; set; }
/// <summary>
/// Indicates if this type description has been type Integer.
/// </summary>
public bool? IsInteger { get; set; }
/// <summary>
/// Indicates if this type description has been type Number.
/// </summary>
public bool? IsNumber { get; set; }
/// <summary>
/// Indicates if this type description has been type String.
/// </summary>
public bool? IsString { get; set; }
/// <summary>
/// Indicates if this type description has been type Object.
/// </summary>
public bool? IsObject { get; set; }
/// <summary>
/// Indicates if this type description has been type Symbol.
/// </summary>
public bool? IsSymbol { get; set; }
/// <summary>
/// Indicates if this type description has been type BigInt.
/// </summary>
public bool? IsBigInt { get; set; }}
/// <summary>
/// Container for type information that has been gathered.
/// </summary>
internal partial class TypeDescription
{
/// <summary>
/// If true, we were able to correlate the offset successfuly with a program location. If false, the offset may be bogus or the offset may be from a CodeBlock that hasn't executed.
/// </summary>
public bool? IsValid { get; set; }
/// <summary>
/// Least common ancestor of all Constructors if the TypeDescription has seen any structures. This string is the display name of the shared constructor function.
/// </summary>
public string LeastCommonAncestor { get; set; }
/// <summary>
/// Set of booleans for determining the aggregate type of this type description.
/// </summary>
public TypeSet TypeSet { get; set; }
/// <summary>
/// Array of descriptions for all structures seen for this variable.
/// </summary>
public StructureDescription[] Structures { get; set; }
/// <summary>
/// If true, this indicates that no more structures are being profiled because some maximum threshold has been reached and profiling has stopped because of memory pressure.
/// </summary>
public bool? IsTruncated { get; set; }}
/// <summary>
/// Describes the location of an expression we want type information for.
/// </summary>
internal partial class TypeLocation
{
/// <summary>
/// What kind of type information do we want (normal, function return values, 'this' statement).
/// </summary>
public int? TypeInformationDescriptor { get; set; }
/// <summary>
/// sourceID uniquely identifying a script
/// </summary>
public string SourceID { get; set; }
/// <summary>
/// character offset for assignment range
/// </summary>
public int? Divot { get; set; }}
/// <summary>
/// From Wikipedia: a basic block is a portion of the code within a program with only one entry point and only one exit point. This type gives the location of a basic block and if that basic block has executed.
/// </summary>
internal partial class BasicBlock
{
/// <summary>
/// Start offset of the basic block.
/// </summary>
public int? StartOffset { get; set; }
/// <summary>
/// End offset of the basic block.
/// </summary>
public int? EndOffset { get; set; }
/// <summary>
/// Indicates if the basic block has executed before.
/// </summary>
public bool? HasExecuted { get; set; }
/// <summary>
/// Indicates how many times the basic block has executed.
/// </summary>
public int? ExecutionCount { get; set; }}
/// <summary>
/// Parses JavaScript source code for errors.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.parse</c>
/// </remarks>
internal partial class RuntimeParseRequest : IWebkitRequest<RuntimeParseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.parse";
/// <summary>
/// Source code to parse.
/// </summary>
public string Source { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeParseRequest"/>
/// </summary>
internal partial class RuntimeParseResponse: IWebkitResponse
{
/// <summary>
/// Parse result.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public SyntaxErrorType Result { get; set; }
/// <summary>
/// Parse error message.
/// </summary>
public string Message { get; set; }
/// <summary>
/// Range in the source where the error occurred.
/// </summary>
public ErrorRange Range { get; set; }}
/// <summary>
/// Evaluates expression on global object.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.evaluate</c>
/// </remarks>
internal partial class RuntimeEvaluateRequest : IWebkitRequest<RuntimeEvaluateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.evaluate";
/// <summary>
/// Expression to evaluate.
/// </summary>
public string Expression { get; set; }
/// <summary>
/// Symbolic group name that can be used to release multiple objects.
/// </summary>
public string ObjectGroup { get; set; }
/// <summary>
/// Determines whether Command Line API should be available during the evaluation.
/// </summary>
public bool? IncludeCommandLineAPI { get; set; }
/// <summary>
/// Specifies whether evaluation should stop on exceptions and mute console. Overrides setPauseOnException state.
/// </summary>
public bool? DoNotPauseOnExceptionsAndMuteConsole { get; set; }
/// <summary>
/// Specifies in which isolated context to perform evaluation. Each content script lives in an isolated context and this parameter may be used to specify one of those contexts. If the parameter is omitted or 0 the evaluation will be performed in the context of the inspected page.
/// </summary>
public int? ContextId { get; set; }
/// <summary>
/// Whether the result is expected to be a JSON object that should be sent by value.
/// </summary>
public bool? ReturnByValue { get; set; }
/// <summary>
/// Whether preview should be generated for the result.
/// </summary>
public bool? GeneratePreview { get; set; }
/// <summary>
/// Whether the resulting value should be considered for saving in the $n history.
/// </summary>
public bool? SaveResult { get; set; }
/// <summary>
/// Whether the expression should be considered to be in a user gesture or not.
/// </summary>
public bool? EmulateUserGesture { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeEvaluateRequest"/>
/// </summary>
internal partial class RuntimeEvaluateResponse: IWebkitResponse
{
/// <summary>
/// Evaluation result.
/// </summary>
public RemoteObject Result { get; set; }
/// <summary>
/// True if the result was thrown during the evaluation.
/// </summary>
public bool? WasThrown { get; set; }
/// <summary>
/// If the result was saved, this is the $n index that can be used to access the value.
/// </summary>
public int? SavedResultIndex { get; set; }}
/// <summary>
/// Calls the async callback when the promise with the given ID gets settled.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.awaitPromise</c>
/// </remarks>
internal partial class RuntimeAwaitPromiseRequest : IWebkitRequest<RuntimeAwaitPromiseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.awaitPromise";
/// <summary>
/// Identifier of the promise.
/// </summary>
public string PromiseObjectId { get; set; }
/// <summary>
/// Whether the result is expected to be a JSON object that should be sent by value.
/// </summary>
public bool? ReturnByValue { get; set; }
/// <summary>
/// Whether preview should be generated for the result.
/// </summary>
public bool? GeneratePreview { get; set; }
/// <summary>
/// Whether the resulting value should be considered for saving in the $n history.
/// </summary>
public bool? SaveResult { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeAwaitPromiseRequest"/>
/// </summary>
internal partial class RuntimeAwaitPromiseResponse: IWebkitResponse
{
/// <summary>
/// Evaluation result.
/// </summary>
public RemoteObject Result { get; set; }
/// <summary>
/// True if the result was thrown during the evaluation.
/// </summary>
public bool? WasThrown { get; set; }
/// <summary>
/// If the result was saved, this is the $n index that can be used to access the value.
/// </summary>
public int? SavedResultIndex { get; set; }}
/// <summary>
/// Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.callFunctionOn</c>
/// </remarks>
internal partial class RuntimeCallFunctionOnRequest : IWebkitRequest<RuntimeCallFunctionOnResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.callFunctionOn";
/// <summary>
/// Identifier of the object to call function on.
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// Declaration of the function to call.
/// </summary>
public string FunctionDeclaration { get; set; }
/// <summary>
/// Call arguments. All call arguments must belong to the same JavaScript world as the target object.
/// </summary>
public CallArgument[] Arguments { get; set; }
/// <summary>
/// Specifies whether function call should stop on exceptions and mute console. Overrides setPauseOnException state.
/// </summary>
public bool? DoNotPauseOnExceptionsAndMuteConsole { get; set; }
/// <summary>
/// Whether the result is expected to be a JSON object which should be sent by value.
/// </summary>
public bool? ReturnByValue { get; set; }
/// <summary>
/// Whether preview should be generated for the result.
/// </summary>
public bool? GeneratePreview { get; set; }
/// <summary>
/// Whether the expression should be considered to be in a user gesture or not.
/// </summary>
public bool? EmulateUserGesture { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeCallFunctionOnRequest"/>
/// </summary>
internal partial class RuntimeCallFunctionOnResponse: IWebkitResponse
{
/// <summary>
/// Call result.
/// </summary>
public RemoteObject Result { get; set; }
/// <summary>
/// True if the result was thrown during the evaluation.
/// </summary>
public bool? WasThrown { get; set; }}
/// <summary>
/// Returns a preview for the given object.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.getPreview</c>
/// </remarks>
internal partial class RuntimeGetPreviewRequest : IWebkitRequest<RuntimeGetPreviewResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.getPreview";
/// <summary>
/// Identifier of the object to return a preview for.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeGetPreviewRequest"/>
/// </summary>
internal partial class RuntimeGetPreviewResponse: IWebkitResponse
{
/// <summary>
/// 
/// </summary>
public ObjectPreview Preview { get; set; }}
/// <summary>
/// Returns properties of a given object. Object group of the result is inherited from the target object.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.getProperties</c>
/// </remarks>
internal partial class RuntimeGetPropertiesRequest : IWebkitRequest<RuntimeGetPropertiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.getProperties";
/// <summary>
/// Identifier of the object to return properties for.
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// If true, returns properties belonging only to the object itself, not to its prototype chain.
/// </summary>
public bool? OwnProperties { get; set; }
/// <summary>
/// If provided skip to this value before collecting values. Otherwise, start at the beginning. Has no effect when the `objectId` is for a `iterator`/`WeakMap`/`WeakSet` object.
/// </summary>
public int? FetchStart { get; set; }
/// <summary>
/// If provided only return `fetchCount` values. Otherwise, return values all the way to the end.
/// </summary>
public int? FetchCount { get; set; }
/// <summary>
/// Whether preview should be generated for property values.
/// </summary>
public bool? GeneratePreview { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeGetPropertiesRequest"/>
/// </summary>
internal partial class RuntimeGetPropertiesResponse: IWebkitResponse
{
/// <summary>
/// Object properties.
/// </summary>
public PropertyDescriptor[] Properties { get; set; }
/// <summary>
/// Internal object properties. Only included if `fetchStart` is 0.
/// </summary>
public InternalPropertyDescriptor[] InternalProperties { get; set; }}
/// <summary>
/// Returns displayable properties of a given object. Object group of the result is inherited from the target object. Displayable properties are own properties, internal properties, and native getters in the prototype chain (assumed to be bindings and treated like own properties for the frontend).
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.getDisplayableProperties</c>
/// </remarks>
internal partial class RuntimeGetDisplayablePropertiesRequest : IWebkitRequest<RuntimeGetDisplayablePropertiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.getDisplayableProperties";
/// <summary>
/// Identifier of the object to return properties for.
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// If provided skip to this value before collecting values. Otherwise, start at the beginning. Has no effect when the `objectId` is for a `iterator`/`WeakMap`/`WeakSet` object.
/// </summary>
public int? FetchStart { get; set; }
/// <summary>
/// If provided only return `fetchCount` values. Otherwise, return values all the way to the end.
/// </summary>
public int? FetchCount { get; set; }
/// <summary>
/// Whether preview should be generated for property values.
/// </summary>
public bool? GeneratePreview { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeGetDisplayablePropertiesRequest"/>
/// </summary>
internal partial class RuntimeGetDisplayablePropertiesResponse: IWebkitResponse
{
/// <summary>
/// Object properties.
/// </summary>
public PropertyDescriptor[] Properties { get; set; }
/// <summary>
/// Internal object properties. Only included if `fetchStart` is 0.
/// </summary>
public InternalPropertyDescriptor[] InternalProperties { get; set; }}
/// <summary>
/// Returns entries of given Map / Set collection.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.getCollectionEntries</c>
/// </remarks>
internal partial class RuntimeGetCollectionEntriesRequest : IWebkitRequest<RuntimeGetCollectionEntriesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.getCollectionEntries";
/// <summary>
/// Id of the collection to get entries for.
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// Symbolic group name that can be used to release multiple. If not provided, it will be the same objectGroup as the RemoteObject determined from &lt;code&gt;objectId&lt;/code&gt;. This is useful for WeakMap to release the collection entries.
/// </summary>
public string ObjectGroup { get; set; }
/// <summary>
/// If provided skip to this value before collecting values. Otherwise, start at the beginning. Has no effect when the `objectId&lt;` is for a `iterator&lt;`/`WeakMap&lt;`/`WeakSet&lt;` object.
/// </summary>
public int? FetchStart { get; set; }
/// <summary>
/// If provided only return `fetchCount` values. Otherwise, return values all the way to the end.
/// </summary>
public int? FetchCount { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeGetCollectionEntriesRequest"/>
/// </summary>
internal partial class RuntimeGetCollectionEntriesResponse: IWebkitResponse
{
/// <summary>
/// Array of collection entries.
/// </summary>
public CollectionEntry[] Entries { get; set; }}
/// <summary>
/// Assign a saved result index to this value.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.saveResult</c>
/// </remarks>
internal partial class RuntimeSaveResultRequest : IWebkitRequest<RuntimeSaveResultResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.saveResult";
/// <summary>
/// Id or value of the object to save.
/// </summary>
public CallArgument Value { get; set; }
/// <summary>
/// Unique id of the execution context. To specify in which execution context script evaluation should be performed. If not provided, determine from the CallArgument's objectId.
/// </summary>
public int? ContextId { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeSaveResultRequest"/>
/// </summary>
internal partial class RuntimeSaveResultResponse: IWebkitResponse
{
/// <summary>
/// If the value was saved, this is the $n index that can be used to access the value.
/// </summary>
public int? SavedResultIndex { get; set; }}
/// <summary>
/// Creates an additional reference to all saved values in the Console using the the given string as a prefix instead of $.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.setSavedResultAlias</c>
/// </remarks>
internal partial class RuntimeSetSavedResultAliasRequest : IWebkitRequest<RuntimeSetSavedResultAliasResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.setSavedResultAlias";
/// <summary>
/// Passing an empty/null string will clear the alias.
/// </summary>
public string Alias { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeSetSavedResultAliasRequest"/>
/// </summary>
internal partial class RuntimeSetSavedResultAliasResponse: IWebkitResponse
{
}
/// <summary>
/// Releases remote object with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.releaseObject</c>
/// </remarks>
internal partial class RuntimeReleaseObjectRequest : IWebkitRequest<RuntimeReleaseObjectResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.releaseObject";
/// <summary>
/// Identifier of the object to release.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeReleaseObjectRequest"/>
/// </summary>
internal partial class RuntimeReleaseObjectResponse: IWebkitResponse
{
}
/// <summary>
/// Releases all remote objects that belong to a given group.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.releaseObjectGroup</c>
/// </remarks>
internal partial class RuntimeReleaseObjectGroupRequest : IWebkitRequest<RuntimeReleaseObjectGroupResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.releaseObjectGroup";
/// <summary>
/// Symbolic object group name.
/// </summary>
public string ObjectGroup { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeReleaseObjectGroupRequest"/>
/// </summary>
internal partial class RuntimeReleaseObjectGroupResponse: IWebkitResponse
{
}
/// <summary>
/// Enables reporting of execution contexts creation by means of &lt;code&gt;executionContextCreated&lt;/code&gt; event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.enable</c>
/// </remarks>
internal partial class RuntimeEnableRequest : IWebkitRequest<RuntimeEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.enable";
}
/// <summary>
/// Response from <see cref="RuntimeEnableRequest"/>
/// </summary>
internal partial class RuntimeEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables reporting of execution contexts creation.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.disable</c>
/// </remarks>
internal partial class RuntimeDisableRequest : IWebkitRequest<RuntimeDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.disable";
}
/// <summary>
/// Response from <see cref="RuntimeDisableRequest"/>
/// </summary>
internal partial class RuntimeDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Returns detailed information on the given function.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.getRuntimeTypesForVariablesAtOffsets</c>
/// </remarks>
internal partial class RuntimeGetRuntimeTypesForVariablesAtOffsetsRequest : IWebkitRequest<RuntimeGetRuntimeTypesForVariablesAtOffsetsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.getRuntimeTypesForVariablesAtOffsets";
/// <summary>
/// An array of type locations we're requesting information for. Results are expected in the same order they're sent in.
/// </summary>
public TypeLocation[] Locations { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeGetRuntimeTypesForVariablesAtOffsetsRequest"/>
/// </summary>
internal partial class RuntimeGetRuntimeTypesForVariablesAtOffsetsResponse: IWebkitResponse
{
/// <summary>
/// 
/// </summary>
public TypeDescription[] Types { get; set; }}
/// <summary>
/// Enables type profiling on the VM.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.enableTypeProfiler</c>
/// </remarks>
internal partial class RuntimeEnableTypeProfilerRequest : IWebkitRequest<RuntimeEnableTypeProfilerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.enableTypeProfiler";
}
/// <summary>
/// Response from <see cref="RuntimeEnableTypeProfilerRequest"/>
/// </summary>
internal partial class RuntimeEnableTypeProfilerResponse: IWebkitResponse
{
}
/// <summary>
/// Disables type profiling on the VM.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.disableTypeProfiler</c>
/// </remarks>
internal partial class RuntimeDisableTypeProfilerRequest : IWebkitRequest<RuntimeDisableTypeProfilerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.disableTypeProfiler";
}
/// <summary>
/// Response from <see cref="RuntimeDisableTypeProfilerRequest"/>
/// </summary>
internal partial class RuntimeDisableTypeProfilerResponse: IWebkitResponse
{
}
/// <summary>
/// Enables control flow profiling on the VM.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.enableControlFlowProfiler</c>
/// </remarks>
internal partial class RuntimeEnableControlFlowProfilerRequest : IWebkitRequest<RuntimeEnableControlFlowProfilerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.enableControlFlowProfiler";
}
/// <summary>
/// Response from <see cref="RuntimeEnableControlFlowProfilerRequest"/>
/// </summary>
internal partial class RuntimeEnableControlFlowProfilerResponse: IWebkitResponse
{
}
/// <summary>
/// Disables control flow profiling on the VM.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.disableControlFlowProfiler</c>
/// </remarks>
internal partial class RuntimeDisableControlFlowProfilerRequest : IWebkitRequest<RuntimeDisableControlFlowProfilerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.disableControlFlowProfiler";
}
/// <summary>
/// Response from <see cref="RuntimeDisableControlFlowProfilerRequest"/>
/// </summary>
internal partial class RuntimeDisableControlFlowProfilerResponse: IWebkitResponse
{
}
/// <summary>
/// Returns a list of basic blocks for the given sourceID with information about their text ranges and whether or not they have executed.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.getBasicBlocks</c>
/// </remarks>
internal partial class RuntimeGetBasicBlocksRequest : IWebkitRequest<RuntimeGetBasicBlocksResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.getBasicBlocks";
/// <summary>
/// Indicates which sourceID information is requested for.
/// </summary>
public string SourceID { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeGetBasicBlocksRequest"/>
/// </summary>
internal partial class RuntimeGetBasicBlocksResponse: IWebkitResponse
{
/// <summary>
/// 
/// </summary>
public BasicBlock[] BasicBlocks { get; set; }}
/// <summary>
/// Issued when new execution context is created.
/// </summary>
/// <remarks>
/// Matches on the event <c>Runtime.executionContextCreated</c>
/// </remarks>
internal partial class RuntimeExecutionContextCreatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Runtime.executionContextCreated";
/// <summary>
/// A newly created execution context.
/// </summary>
public ExecutionContextDescription Context { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.ScriptProfiler
{
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum EventType
{
[System.Runtime.Serialization.EnumMember(Value = "API")]API,
[System.Runtime.Serialization.EnumMember(Value = "Microtask")]Microtask,
[System.Runtime.Serialization.EnumMember(Value = "Other")]Other}
/// <summary>
/// 
/// </summary>
internal partial class Event
{
/// <summary>
/// 
/// </summary>
public double? StartTime { get; set; }
/// <summary>
/// 
/// </summary>
public double? EndTime { get; set; }
/// <summary>
/// 
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public EventType Type { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class ExpressionLocation
{
/// <summary>
/// 1-based.
/// </summary>
public int? Line { get; set; }
/// <summary>
/// 1-based.
/// </summary>
public int? Column { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class StackFrame
{
/// <summary>
/// Unique script identifier.
/// </summary>
public string SourceID { get; set; }
/// <summary>
/// A displayable name for the stack frame. i.e function name, (program), etc.
/// </summary>
public string Name { get; set; }
/// <summary>
/// -1 if unavailable. 1-based if available.
/// </summary>
public int? Line { get; set; }
/// <summary>
/// -1 if unavailable. 1-based if available.
/// </summary>
public int? Column { get; set; }
/// <summary>
/// 
/// </summary>
public string Url { get; set; }
/// <summary>
/// 
/// </summary>
public ExpressionLocation ExpressionLocation { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class StackTrace
{
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// First array item is the bottom of the call stack and last array item is the top of the call stack.
/// </summary>
public StackFrame[] StackFrames { get; set; }}
/// <summary>
/// 
/// </summary>
internal partial class Samples
{
/// <summary>
/// 
/// </summary>
public StackTrace[] StackTraces { get; set; }}
/// <summary>
/// Start tracking script evaluations.
/// </summary>
/// <remarks>
/// Will send the command <c>ScriptProfiler.startTracking</c>
/// </remarks>
internal partial class ScriptProfilerStartTrackingRequest : IWebkitRequest<ScriptProfilerStartTrackingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ScriptProfiler.startTracking";
/// <summary>
/// Start the sampling profiler, defaults to false.
/// </summary>
public bool? IncludeSamples { get; set; }}
/// <summary>
/// Response from <see cref="ScriptProfilerStartTrackingRequest"/>
/// </summary>
internal partial class ScriptProfilerStartTrackingResponse: IWebkitResponse
{
}
/// <summary>
/// Stop tracking script evaluations. This will produce a `trackingComplete` event.
/// </summary>
/// <remarks>
/// Will send the command <c>ScriptProfiler.stopTracking</c>
/// </remarks>
internal partial class ScriptProfilerStopTrackingRequest : IWebkitRequest<ScriptProfilerStopTrackingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ScriptProfiler.stopTracking";
}
/// <summary>
/// Response from <see cref="ScriptProfilerStopTrackingRequest"/>
/// </summary>
internal partial class ScriptProfilerStopTrackingResponse: IWebkitResponse
{
}
/// <summary>
/// Tracking started.
/// </summary>
/// <remarks>
/// Matches on the event <c>ScriptProfiler.trackingStart</c>
/// </remarks>
internal partial class ScriptProfilerTrackingStartWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "ScriptProfiler.trackingStart";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }}
/// <summary>
/// Periodic tracking updates with event data.
/// </summary>
/// <remarks>
/// Matches on the event <c>ScriptProfiler.trackingUpdate</c>
/// </remarks>
internal partial class ScriptProfilerTrackingUpdateWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "ScriptProfiler.trackingUpdate";
/// <summary>
/// 
/// </summary>
public Event Event { get; set; }}
/// <summary>
/// Tracking stopped. Includes any buffered data during tracking, such as profiling information.
/// </summary>
/// <remarks>
/// Matches on the event <c>ScriptProfiler.trackingComplete</c>
/// </remarks>
internal partial class ScriptProfilerTrackingCompleteWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "ScriptProfiler.trackingComplete";
/// <summary>
/// 
/// </summary>
public double? Timestamp { get; set; }
/// <summary>
/// Stack traces.
/// </summary>
public Samples Samples { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Security
{
/// <summary>
/// Information about a SSL connection to display in the frontend.
/// </summary>
internal partial class Connection
{
/// <summary>
/// 
/// </summary>
public string Protocol { get; set; }
/// <summary>
/// 
/// </summary>
public string Cipher { get; set; }}
/// <summary>
/// Information about a SSL certificate to display in the frontend.
/// </summary>
internal partial class Certificate
{
/// <summary>
/// 
/// </summary>
public string Subject { get; set; }
/// <summary>
/// 
/// </summary>
public double? ValidFrom { get; set; }
/// <summary>
/// 
/// </summary>
public double? ValidUntil { get; set; }
/// <summary>
/// DNS names listed on the certificate.
/// </summary>
public string[] DnsNames { get; set; }
/// <summary>
/// IP addresses listed on the certificate.
/// </summary>
public string[] IpAddresses { get; set; }}
/// <summary>
/// Security information for a given Network.Response.
/// </summary>
internal partial class Security
{
/// <summary>
/// 
/// </summary>
public Connection Connection { get; set; }
/// <summary>
/// 
/// </summary>
public Certificate Certificate { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.ServiceWorker
{
/// <summary>
/// ServiceWorker metadata and initial state.
/// </summary>
internal partial class Configuration
{
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }
/// <summary>
/// 
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// ServiceWorker main script URL.
/// </summary>
public string Url { get; set; }
/// <summary>
/// ServiceWorker main script content.
/// </summary>
public string Content { get; set; }}
/// <summary>
/// Returns the initialization information for this target.
/// </summary>
/// <remarks>
/// Will send the command <c>ServiceWorker.getInitializationInfo</c>
/// </remarks>
internal partial class ServiceWorkerGetInitializationInfoRequest : IWebkitRequest<ServiceWorkerGetInitializationInfoResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ServiceWorker.getInitializationInfo";
}
/// <summary>
/// Response from <see cref="ServiceWorkerGetInitializationInfoRequest"/>
/// </summary>
internal partial class ServiceWorkerGetInitializationInfoResponse: IWebkitResponse
{
/// <summary>
/// 
/// </summary>
public Configuration Info { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Target
{
/// <summary>
/// Description of a target.
/// </summary>
internal partial class TargetInfo
{
/// <summary>
/// Unique identifier for the target.
/// </summary>
public string TargetId { get; set; }
/// <summary>
/// 
/// </summary>
public string Type { get; set; }
/// <summary>
/// True value indicates that this is a provisional page target i.e. Such target may be created when current page starts cross-origin navigation. Eventually each provisional target is either committed and swaps with the current target or gets destroyed, e.g. in case of load request failure.
/// </summary>
public bool? IsProvisional { get; set; }
/// <summary>
/// Unique identifier of the target which is going to be replaced if this target is committed. Only set for provisional targets.
/// </summary>
public string OldTargetId { get; set; }
/// <summary>
/// Whether the target is paused on start and has to be explicitely resumed by inspector.
/// </summary>
public bool? IsPaused { get; set; }}
/// <summary>
/// If set to true, new targets will be paused on start waiting for resume command. Other commands can be dispatched on the target before it is resumed.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.setPauseOnStart</c>
/// </remarks>
internal partial class TargetSetPauseOnStartRequest : IWebkitRequest<TargetSetPauseOnStartResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.setPauseOnStart";
/// <summary>
/// If set to true, new targets will be paused on start waiting for resume command.
/// </summary>
public bool? PauseOnStart { get; set; }}
/// <summary>
/// Response from <see cref="TargetSetPauseOnStartRequest"/>
/// </summary>
internal partial class TargetSetPauseOnStartResponse: IWebkitResponse
{
}
/// <summary>
/// Will resume target if it was paused on start.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.resume</c>
/// </remarks>
internal partial class TargetResumeRequest : IWebkitRequest<TargetResumeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.resume";
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// Response from <see cref="TargetResumeRequest"/>
/// </summary>
internal partial class TargetResumeResponse: IWebkitResponse
{
}
/// <summary>
/// Send an Inspector Protocol message to be dispatched to a Target's agents.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.sendMessageToTarget</c>
/// </remarks>
internal partial class TargetSendMessageToTargetRequest : IWebkitRequest<TargetSendMessageToTargetResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.sendMessageToTarget";
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }
/// <summary>
/// JSON Inspector Protocol message (command) to be dispatched on the backend.
/// </summary>
public string Message { get; set; }}
/// <summary>
/// Response from <see cref="TargetSendMessageToTargetRequest"/>
/// </summary>
internal partial class TargetSendMessageToTargetResponse: IWebkitResponse
{
}
/// <summary>
/// Reveals the target on screen.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.activate</c>
/// </remarks>
internal partial class TargetActivateRequest : IWebkitRequest<TargetActivateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.activate";
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// Response from <see cref="TargetActivateRequest"/>
/// </summary>
internal partial class TargetActivateResponse: IWebkitResponse
{
}
/// <summary>
/// Closes the target.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.close</c>
/// </remarks>
internal partial class TargetCloseRequest : IWebkitRequest<TargetCloseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.close";
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }
/// <summary>
/// 
/// </summary>
public bool? RunBeforeUnload { get; set; }}
/// <summary>
/// Response from <see cref="TargetCloseRequest"/>
/// </summary>
internal partial class TargetCloseResponse: IWebkitResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Target.targetCreated</c>
/// </remarks>
internal partial class TargetTargetCreatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Target.targetCreated";
/// <summary>
/// 
/// </summary>
public TargetInfo TargetInfo { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Target.targetDestroyed</c>
/// </remarks>
internal partial class TargetTargetDestroyedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Target.targetDestroyed";
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }
/// <summary>
/// 
/// </summary>
public bool? Crashed { get; set; }}
/// <summary>
/// This event is fired when provisional load is committed. Provisional target swaps with the current target.
/// </summary>
/// <remarks>
/// Matches on the event <c>Target.didCommitProvisionalTarget</c>
/// </remarks>
internal partial class TargetDidCommitProvisionalTargetWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Target.didCommitProvisionalTarget";
/// <summary>
/// ID of the old target that is swapped with the committed one.
/// </summary>
public string OldTargetId { get; set; }
/// <summary>
/// ID of the committed target.
/// </summary>
public string NewTargetId { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Target.dispatchMessageFromTarget</c>
/// </remarks>
internal partial class TargetDispatchMessageFromTargetWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Target.dispatchMessageFromTarget";
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }
/// <summary>
/// JSON Inspector Protocol message (response or event) to be dispatched on the frontend.
/// </summary>
public string Message { get; set; }}
}
namespace PlaywrightSharp.Webkit.Protocol.Timeline
{
/// <summary>
/// Timeline record type.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum EventType
{
[System.Runtime.Serialization.EnumMember(Value = "EventDispatch")]EventDispatch,
[System.Runtime.Serialization.EnumMember(Value = "ScheduleStyleRecalculation")]ScheduleStyleRecalculation,
[System.Runtime.Serialization.EnumMember(Value = "RecalculateStyles")]RecalculateStyles,
[System.Runtime.Serialization.EnumMember(Value = "InvalidateLayout")]InvalidateLayout,
[System.Runtime.Serialization.EnumMember(Value = "Layout")]Layout,
[System.Runtime.Serialization.EnumMember(Value = "Paint")]Paint,
[System.Runtime.Serialization.EnumMember(Value = "Composite")]Composite,
[System.Runtime.Serialization.EnumMember(Value = "RenderingFrame")]RenderingFrame,
[System.Runtime.Serialization.EnumMember(Value = "TimerInstall")]TimerInstall,
[System.Runtime.Serialization.EnumMember(Value = "TimerRemove")]TimerRemove,
[System.Runtime.Serialization.EnumMember(Value = "TimerFire")]TimerFire,
[System.Runtime.Serialization.EnumMember(Value = "EvaluateScript")]EvaluateScript,
[System.Runtime.Serialization.EnumMember(Value = "TimeStamp")]TimeStamp,
[System.Runtime.Serialization.EnumMember(Value = "Time")]Time,
[System.Runtime.Serialization.EnumMember(Value = "TimeEnd")]TimeEnd,
[System.Runtime.Serialization.EnumMember(Value = "FunctionCall")]FunctionCall,
[System.Runtime.Serialization.EnumMember(Value = "ProbeSample")]ProbeSample,
[System.Runtime.Serialization.EnumMember(Value = "ConsoleProfile")]ConsoleProfile,
[System.Runtime.Serialization.EnumMember(Value = "RequestAnimationFrame")]RequestAnimationFrame,
[System.Runtime.Serialization.EnumMember(Value = "CancelAnimationFrame")]CancelAnimationFrame,
[System.Runtime.Serialization.EnumMember(Value = "FireAnimationFrame")]FireAnimationFrame,
[System.Runtime.Serialization.EnumMember(Value = "ObserverCallback")]ObserverCallback}
/// <summary>
/// Instrument types.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
internal enum Instrument
{
[System.Runtime.Serialization.EnumMember(Value = "ScriptProfiler")]ScriptProfiler,
[System.Runtime.Serialization.EnumMember(Value = "Timeline")]Timeline,
[System.Runtime.Serialization.EnumMember(Value = "CPU")]CPU,
[System.Runtime.Serialization.EnumMember(Value = "Memory")]Memory,
[System.Runtime.Serialization.EnumMember(Value = "Heap")]Heap,
[System.Runtime.Serialization.EnumMember(Value = "Animation")]Animation}
/// <summary>
/// Timeline record contains information about the recorded activity.
/// </summary>
internal partial class TimelineEvent
{
/// <summary>
/// Event type.
/// </summary>
[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumMemberConverter))]
public EventType Type { get; set; }
/// <summary>
/// Event data.
/// </summary>
public object Data { get; set; }
/// <summary>
/// Nested records.
/// </summary>
public TimelineEvent[] Children { get; set; }}
/// <summary>
/// Enables Timeline domain events.
/// </summary>
/// <remarks>
/// Will send the command <c>Timeline.enable</c>
/// </remarks>
internal partial class TimelineEnableRequest : IWebkitRequest<TimelineEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Timeline.enable";
}
/// <summary>
/// Response from <see cref="TimelineEnableRequest"/>
/// </summary>
internal partial class TimelineEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disables Timeline domain events.
/// </summary>
/// <remarks>
/// Will send the command <c>Timeline.disable</c>
/// </remarks>
internal partial class TimelineDisableRequest : IWebkitRequest<TimelineDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Timeline.disable";
}
/// <summary>
/// Response from <see cref="TimelineDisableRequest"/>
/// </summary>
internal partial class TimelineDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Starts capturing instrumentation events.
/// </summary>
/// <remarks>
/// Will send the command <c>Timeline.start</c>
/// </remarks>
internal partial class TimelineStartRequest : IWebkitRequest<TimelineStartResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Timeline.start";
/// <summary>
/// Samples JavaScript stack traces up to &lt;code&gt;maxCallStackDepth&lt;/code&gt;, defaults to 5.
/// </summary>
public int? MaxCallStackDepth { get; set; }}
/// <summary>
/// Response from <see cref="TimelineStartRequest"/>
/// </summary>
internal partial class TimelineStartResponse: IWebkitResponse
{
}
/// <summary>
/// Stops capturing instrumentation events.
/// </summary>
/// <remarks>
/// Will send the command <c>Timeline.stop</c>
/// </remarks>
internal partial class TimelineStopRequest : IWebkitRequest<TimelineStopResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Timeline.stop";
}
/// <summary>
/// Response from <see cref="TimelineStopRequest"/>
/// </summary>
internal partial class TimelineStopResponse: IWebkitResponse
{
}
/// <summary>
/// Toggle auto capture state. If &lt;code&gt;true&lt;/code&gt; the backend will disable breakpoints and start capturing on navigation. The backend will fire the &lt;code&gt;autoCaptureStarted&lt;/code&gt; event when an auto capture starts. The frontend should stop the auto capture when appropriate and re-enable breakpoints.
/// </summary>
/// <remarks>
/// Will send the command <c>Timeline.setAutoCaptureEnabled</c>
/// </remarks>
internal partial class TimelineSetAutoCaptureEnabledRequest : IWebkitRequest<TimelineSetAutoCaptureEnabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Timeline.setAutoCaptureEnabled";
/// <summary>
/// New auto capture state.
/// </summary>
public bool? Enabled { get; set; }}
/// <summary>
/// Response from <see cref="TimelineSetAutoCaptureEnabledRequest"/>
/// </summary>
internal partial class TimelineSetAutoCaptureEnabledResponse: IWebkitResponse
{
}
/// <summary>
/// Instruments to enable when capture starts on the backend (e.g. auto capture or programmatic capture).
/// </summary>
/// <remarks>
/// Will send the command <c>Timeline.setInstruments</c>
/// </remarks>
internal partial class TimelineSetInstrumentsRequest : IWebkitRequest<TimelineSetInstrumentsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Timeline.setInstruments";
/// <summary>
/// Instruments to enable.
/// </summary>
public Instrument[] Instruments { get; set; }}
/// <summary>
/// Response from <see cref="TimelineSetInstrumentsRequest"/>
/// </summary>
internal partial class TimelineSetInstrumentsResponse: IWebkitResponse
{
}
/// <summary>
/// Fired for every instrumentation event while timeline is started.
/// </summary>
/// <remarks>
/// Matches on the event <c>Timeline.eventRecorded</c>
/// </remarks>
internal partial class TimelineEventRecordedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Timeline.eventRecorded";
/// <summary>
/// Timeline event record data.
/// </summary>
public TimelineEvent Record { get; set; }}
/// <summary>
/// Fired when recording has started.
/// </summary>
/// <remarks>
/// Matches on the event <c>Timeline.recordingStarted</c>
/// </remarks>
internal partial class TimelineRecordingStartedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Timeline.recordingStarted";
/// <summary>
/// Start time of this new recording.
/// </summary>
public double? StartTime { get; set; }}
/// <summary>
/// Fired when recording has stopped.
/// </summary>
/// <remarks>
/// Matches on the event <c>Timeline.recordingStopped</c>
/// </remarks>
internal partial class TimelineRecordingStoppedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Timeline.recordingStopped";
/// <summary>
/// End time of this recording.
/// </summary>
public double? EndTime { get; set; }}
/// <summary>
/// Fired when auto capture started.
/// </summary>
/// <remarks>
/// Matches on the event <c>Timeline.autoCaptureStarted</c>
/// </remarks>
internal partial class TimelineAutoCaptureStartedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Timeline.autoCaptureStarted";
}
}
namespace PlaywrightSharp.Webkit.Protocol.Worker
{
/// <summary>
/// Enable Worker domain events.
/// </summary>
/// <remarks>
/// Will send the command <c>Worker.enable</c>
/// </remarks>
internal partial class WorkerEnableRequest : IWebkitRequest<WorkerEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Worker.enable";
}
/// <summary>
/// Response from <see cref="WorkerEnableRequest"/>
/// </summary>
internal partial class WorkerEnableResponse: IWebkitResponse
{
}
/// <summary>
/// Disable Worker domain events.
/// </summary>
/// <remarks>
/// Will send the command <c>Worker.disable</c>
/// </remarks>
internal partial class WorkerDisableRequest : IWebkitRequest<WorkerDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Worker.disable";
}
/// <summary>
/// Response from <see cref="WorkerDisableRequest"/>
/// </summary>
internal partial class WorkerDisableResponse: IWebkitResponse
{
}
/// <summary>
/// Sent after the frontend has sent all initialization messages and can resume this worker. This command is required to allow execution in the worker.
/// </summary>
/// <remarks>
/// Will send the command <c>Worker.initialized</c>
/// </remarks>
internal partial class WorkerInitializedRequest : IWebkitRequest<WorkerInitializedResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Worker.initialized";
/// <summary>
/// 
/// </summary>
public string WorkerId { get; set; }}
/// <summary>
/// Response from <see cref="WorkerInitializedRequest"/>
/// </summary>
internal partial class WorkerInitializedResponse: IWebkitResponse
{
}
/// <summary>
/// Send an Inspector Protocol message to be dispatched to a Worker's agents.
/// </summary>
/// <remarks>
/// Will send the command <c>Worker.sendMessageToWorker</c>
/// </remarks>
internal partial class WorkerSendMessageToWorkerRequest : IWebkitRequest<WorkerSendMessageToWorkerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Worker.sendMessageToWorker";
/// <summary>
/// 
/// </summary>
public string WorkerId { get; set; }
/// <summary>
/// JSON Inspector Protocol message (command) to be dispatched on the backend.
/// </summary>
public string Message { get; set; }}
/// <summary>
/// Response from <see cref="WorkerSendMessageToWorkerRequest"/>
/// </summary>
internal partial class WorkerSendMessageToWorkerResponse: IWebkitResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Worker.workerCreated</c>
/// </remarks>
internal partial class WorkerWorkerCreatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Worker.workerCreated";
/// <summary>
/// 
/// </summary>
public string WorkerId { get; set; }
/// <summary>
/// 
/// </summary>
public string Url { get; set; }
/// <summary>
/// Id of the frame this worker belongs to.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Worker.workerTerminated</c>
/// </remarks>
internal partial class WorkerWorkerTerminatedWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Worker.workerTerminated";
/// <summary>
/// 
/// </summary>
public string WorkerId { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Worker.dispatchMessageFromWorker</c>
/// </remarks>
internal partial class WorkerDispatchMessageFromWorkerWebkitEvent : IWebkitEvent
{
public string InternalName { get; } = "Worker.dispatchMessageFromWorker";
/// <summary>
/// 
/// </summary>
public string WorkerId { get; set; }
/// <summary>
/// JSON Inspector Protocol message (response or event) to be dispatched on the frontend.
/// </summary>
public string Message { get; set; }}
}
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
