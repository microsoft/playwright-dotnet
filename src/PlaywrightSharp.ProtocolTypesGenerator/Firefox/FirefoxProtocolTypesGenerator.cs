using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using Microsoft.AspNetCore.NodeServices;
using Microsoft.Extensions.DependencyInjection;

namespace PlaywrightSharp.ProtocolTypesGenerator.Firefox
{
    internal class FirefoxProtocolTypesGenerator : IProtocolTypesGenerator
    {
        private const string NamespacePrefix = "PlaywrightSharp.Firefox.Protocol";
        private readonly IDictionary<string, string> _knownTypes = new Dictionary<string, string>();

        public async Task GenerateTypesAsync(RevisionInfo revision)
        {
            string directory = Path.Join("..", "..", "..", "..", "PlaywrightSharp.Firefox", "Protocol");
            string output = Path.Join(directory, "Protocol.Generated.cs");
            if (!Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }

            string json = await ConvertProtocolJsToJson(revision).ConfigureAwait(false);
            var document = JsonDocument.Parse(json);

            var builder = new StringBuilder();
            builder.AppendAutoGeneratedPrefix();
            foreach (var property in document.RootElement.GetProperty("domains").EnumerateObject())
            {
                builder.AppendLine($"namespace {NamespacePrefix}.{property.Name}");
                builder.AppendLine("{");

                GenerateTypes(builder, property);

                builder.AppendLine("}");
            }

            foreach (var property in document.RootElement.GetProperty("domains").EnumerateObject())
            {
                builder.AppendLine($"namespace {NamespacePrefix}.{property.Name}");
                builder.AppendLine("{");

                GenerateEvents(builder, property);
                GenerateMethods(builder, property);

                builder.AppendLine("}");
            }

            builder.AppendAutoGeneratedSuffix();
            await File.WriteAllTextAsync(output, builder.ToString()).ConfigureAwait(false);

            return;
        }

        private void GenerateEvents(StringBuilder builder, JsonProperty domain)
        {
            foreach (var eventDef in domain.Value.GetProperty("events").EnumerateObject())
            {
                string eventName = eventDef.Name;
                builder.AppendLine($"internal class {domain.Name}{eventName}FirefoxEvent");
                builder.AppendLine("{");
                foreach (var propertyDef in eventDef.Value.EnumerateObject())
                {
                    if (_knownTypes.TryGetValue(propertyDef.Value.GetRawText(), out string typeName))
                    {
                        builder.AppendLine($"public {typeName} {propertyDef.Name} {{ get; set; }}");
                        continue;
                    }

                    string csharpType = ConvertJsTypeToCsharp(builder, domain.Name, propertyDef);
                    builder.AppendLine($"public {csharpType} {propertyDef.Name} {{ get; set; }}");
                }

                builder.AppendLine("}");
            }
        }

        private void GenerateMethods(StringBuilder builder, JsonProperty domain)
        {
            foreach (var methodDef in domain.Value.GetProperty("methods").EnumerateObject())
            {
                Console.WriteLine($"method: {domain.Name}.{methodDef.Name}");

                if (methodDef.Value.TryGetProperty("params", out var paramsDef))
                {
                    Console.WriteLine(paramsDef);
                }

                if (methodDef.Value.TryGetProperty("returns", out var returnesDef))
                {
                    Console.WriteLine(returnesDef);
                }
            }
        }

        private void GenerateTypes(StringBuilder builder, JsonProperty domain)
        {
            foreach (var typeDef in domain.Value.GetProperty("types").EnumerateObject())
            {
                if (!_knownTypes.TryGetValue(typeDef.Value.GetRawText(), out string typeName))
                {
                    string jsonText = typeDef.Value.GetRawText();
                    string jsonTextNullable = jsonText.Substring(0, jsonText.Length - 1) + ",\"$nullable\":true}";
                    _knownTypes.Add(jsonText, $"{domain.Name}{typeDef.Name}");
                    _knownTypes.Add(jsonTextNullable, $"{domain.Name}{typeDef.Name}");
                    continue;
                }

                builder.Append("internal class ").AppendLine(typeDef.Name);
                builder.AppendLine("{");
                foreach (var propertyDef in typeDef.Value.EnumerateObject())
                {
                    string csharpType = ConvertJsTypeToCsharp(builder, domain.Name, propertyDef);
                    builder.AppendLine($"public {csharpType} {propertyDef.Name} {{ get; set; }}");
                }

                builder.AppendLine("}");
            }
        }

        private string ConvertJsTypeToCsharp(StringBuilder builder, string domain, JsonElement obj)
        {
            if (!obj.TryGetProperty("$type", out var typeElement))
            {
                return _knownTypes[obj.GetRawText()];
            }

            string type = typeElement.GetString();
            return type switch
            {
                "string" => "string",
                "boolean" => "boolean?",
                "number" => "double?",
                "enum" when _knownTypes.TryGetValue(obj.GetProperty("$values").GetRawText(), out string enumName) => enumName,
                "any" => "JsonElement?",
                _ => throw new ArgumentOutOfRangeException(nameof(obj), type, "invalid object type")
            };
        }

        private string ConvertJsTypeToCsharp(StringBuilder builder, string domain, JsonProperty objectDef)
        {
            try
            {
                if (!objectDef.Value.TryGetProperty("$type", out var typeElement))
                {
                    return _knownTypes[objectDef.Value.GetRawText()];
                }

                string type = typeElement.GetString();
                if (type == "enum" && objectDef.Value.TryGetProperty("$values", out var values)
                    && !_knownTypes.ContainsKey(values.GetRawText()))
                {
                    _knownTypes.Add(values.GetRawText(), $"{domain}.{objectDef.Name}");
                    builder.AppendLine($"internal enum {objectDef.Name}");
                    builder.AppendLine("{");
                    foreach (var value in values.EnumerateArray())
                    {
                        builder.Append(value.GetString());
                        builder.AppendLine(",");
                    }

                    builder.AppendLine("}");
                }

                return type switch
                {
                    "string" => "string",
                    "boolean" => "boolean?",
                    "number" => "double?",
                    "enum" when _knownTypes.TryGetValue(objectDef.Value.GetProperty("$values").GetRawText(), out string enumName) => enumName,
                    "any" => "JsonElement?",
                    "array" => ConvertJsTypeToCsharp(builder, domain, objectDef.Value.GetProperty("$items")) + "[]",

                    _ => throw new ArgumentOutOfRangeException(nameof(objectDef), type, "invalid object type")
                };
            }
            catch (Exception e)
            {
                throw new Exception("ERROR", e);
            }
        }

        // INodeServices is deprecated...
#pragma warning disable CS0618 // Type or member is obsolete
        private async Task<string> ConvertProtocolJsToJson(RevisionInfo revision)
        {
            string protocolJs = "chrome/juggler/content/protocol/Protocol.js";
            string zipFile = Path.Combine(Directory.GetParent(revision.ExecutablePath).FullName, "omni.ja");
            using var zip = ZipFile.OpenRead(zipFile);
            using var reader = new StreamReader(zip.GetEntry(protocolJs).Open());
            string js = await reader.ReadToEndAsync().ConfigureAwait(false);

            return await GetNodejs().InvokeExportAsync<string>("Firefox/firefox-protocol.js", "getJson", js).ConfigureAwait(false);
        }

        private INodeServices GetNodejs()
        {
            IServiceCollection services = new ServiceCollection();
            services.AddNodeServices();
            return services.BuildServiceProvider()
                .GetService<INodeServices>();
        }
#pragma warning restore CS0618 // Type or member is obsolete
    }
}
