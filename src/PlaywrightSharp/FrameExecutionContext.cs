using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;

namespace PlaywrightSharp
{
    internal class FrameExecutionContext : IFrameExecutionContext
    {
        // This could eventually be an embeeded resources downloaded from pw
        private readonly string _injectedSource = @"(/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \""\"";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \""./ src / injected / injected.ts\"");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \""./ src / injected / cssSelectorEngine.ts\"":\n/*!*******************************************!*\\\n  !*** ./src/injected/cssSelectorEngine.ts ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\""use strict\"";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \""License\"");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \""AS IS\"" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \""__esModule\"", { value: true });\nexports.CSSEngine = {\n    name: 'css',\n    create(root, targetElement) {\n        const tokens = [];\n        function uniqueCSSSelector(prefix) {\n            const path = tokens.slice();\n            if (prefix)\n                path.unshift(prefix);\n            const selector = path.join(' > ');\n            const nodes = Array.from(root.querySelectorAll(selector));\n            return nodes[0] === targetElement ? selector : undefined;\n        }\n        for (let element = targetElement; element && element !== root; element = element.parentElement) {\n            const nodeName = element.nodeName.toLowerCase();\n            // Element ID is the strongest signal, use it.\n            let bestTokenForLevel = '';\n            if (element.id) {\n                const token = /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(element.id) ? '#' + element.id : `[id=\""${element.id}\""]`;\n                const selector = uniqueCSSSelector(token);\n                if (selector)\n                    return selector;\n                bestTokenForLevel = token;\n            }\n            const parent = element.parentElement;\n            // Combine class names until unique.\n            const classes = Array.from(element.classList);\n            for (let i = 0; i < classes.length; ++i) {\n                const token = '.' + classes.slice(0, i + 1).join('.');\n                const selector = uniqueCSSSelector(token);\n                if (selector)\n                    return selector;\n                // Even if not unique, does this subset of classes uniquely identify node as a child?\n                if (!bestTokenForLevel && parent) {\n                    const sameClassSiblings = parent.querySelectorAll(token);\n                    if (sameClassSiblings.length === 1)\n                        bestTokenForLevel = token;\n                }\n            }\n            // Ordinal is the weakest signal.\n            if (parent) {\n                const siblings = Array.from(parent.children);\n                const sameTagSiblings = siblings.filter(sibling => sibling.nodeName.toLowerCase() === nodeName);\n                const token = sameTagSiblings.length === 1 ? nodeName : `${nodeName}:nth-child(${1 + siblings.indexOf(element)})`;\n                const selector = uniqueCSSSelector(token);\n                if (selector)\n                    return selector;\n                if (!bestTokenForLevel)\n                    bestTokenForLevel = token;\n            }\n            else if (!bestTokenForLevel) {\n                bestTokenForLevel = nodeName;\n            }\n            tokens.unshift(bestTokenForLevel);\n        }\n        return uniqueCSSSelector();\n    },\n    query(root, selector) {\n        return root.querySelector(selector) || undefined;\n    },\n    queryAll(root, selector) {\n        return Array.from(root.querySelectorAll(selector));\n    }\n};\n\n\n/***/ }),\n\n/***/ \""./ src / injected / injected.ts\"":\n/*!**********************************!*\\\n  !*** ./src/injected/injected.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\""use strict\"";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \""License\"");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \""AS IS\"" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \""__esModule\"", { value: true });\nconst utils_1 = __webpack_require__(/*! ./utils */ \""./src/injected/utils.ts\"");\nconst cssSelectorEngine_1 = __webpack_require__(/*! ./cssSelectorEngine */ \""./src/injected/cssSelectorEngine.ts\"");\nconst xpathSelectorEngine_1 = __webpack_require__(/*! ./xpathSelectorEngine */ \""./src/injected/xpathSelectorEngine.ts\"");\nconst textSelectorEngine_1 = __webpack_require__(/*! ./textSelectorEngine */ \""./src/injected/textSelectorEngine.ts\"");\nfunction createAttributeEngine(attribute) {\n    const engine = {\n        name: attribute,\n        create(root, target) {\n            const value = target.getAttribute(attribute);\n            if (!value)\n                return;\n            if (root.querySelector(`[${attribute}=${value}]`) === target)\n                return value;\n        },\n        query(root, selector) {\n            return root.querySelector(`[${attribute}=${selector}]`) || undefined;\n        },\n        queryAll(root, selector) {\n            return Array.from(root.querySelectorAll(`[${attribute}=${selector}]`));\n        }\n    };\n    return engine;\n}\nclass Injected {\n    constructor(customEngines) {\n        const defaultEngines = [\n            cssSelectorEngine_1.CSSEngine,\n            xpathSelectorEngine_1.XPathEngine,\n            textSelectorEngine_1.TextEngine,\n            createAttributeEngine('id'),\n            createAttributeEngine('data-testid'),\n            createAttributeEngine('data-test-id'),\n            createAttributeEngine('data-test'),\n        ];\n        this.utils = new utils_1.Utils();\n        this.engines = new Map();\n        for (const engine of [...defaultEngines, ...customEngines])\n            this.engines.set(engine.name, engine);\n    }\n    querySelector(selector, root) {\n        const parsed = this._parseSelector(selector);\n        if (!root['querySelector'])\n            throw new Error('Node is not queryable.');\n        let element = root;\n        for (const { engine, selector } of parsed) {\n            const next = engine.query(element.shadowRoot || element, selector);\n            if (!next)\n                return;\n            element = next;\n        }\n        return element;\n    }\n    querySelectorAll(selector, root) {\n        const parsed = this._parseSelector(selector);\n        if (!root['querySelectorAll'])\n            throw new Error('Node is not queryable.');\n        let set = new Set([root]);\n        for (const { engine, selector } of parsed) {\n            const newSet = new Set();\n            for (const prev of set) {\n                for (const next of engine.queryAll(prev.shadowRoot || prev, selector)) {\n                    if (newSet.has(next))\n                        continue;\n                    newSet.add(next);\n                }\n            }\n            set = newSet;\n        }\n        return Array.from(set);\n    }\n    _parseSelector(selector) {\n        let index = 0;\n        let quote;\n        let start = 0;\n        const result = [];\n        const append = () => {\n            const part = selector.substring(start, index);\n            const eqIndex = part.indexOf('=');\n            if (eqIndex === -1)\n                throw new Error(`Cannot parse selector ${selector}`);\n            const name = part.substring(0, eqIndex).trim();\n            const body = part.substring(eqIndex + 1);\n            const engine = this.engines.get(name.toLowerCase());\n            if (!engine)\n                throw new Error(`Unknown engine ${name} while parsing selector ${selector}`);\n            result.push({ engine, selector: body });\n        };\n        while (index < selector.length) {\n            const c = selector[index];\n            if (c === '\\\\' && index + 1 < selector.length) {\n                index += 2;\n            }\n            else if (c === quote) {\n                quote = undefined;\n                index++;\n            }\n            else if (!quote && c === '>' && selector[index + 1] === '>') {\n                append();\n                index += 2;\n                start = index;\n            }\n            else {\n                index++;\n            }\n        }\n        append();\n        return result;\n    }\n    isVisible(element) {\n        if (!element.ownerDocument || !element.ownerDocument.defaultView)\n            return true;\n        const style = element.ownerDocument.defaultView.getComputedStyle(element);\n        if (!style || style.visibility === 'hidden')\n            return false;\n        const rect = element.getBoundingClientRect();\n        return !!(rect.top || rect.bottom || rect.width || rect.height);\n    }\n    pollMutation(selector, predicate, timeout) {\n        let timedOut = false;\n        if (timeout)\n            setTimeout(() => timedOut = true, timeout);\n        const element = selector === undefined ? undefined : this.querySelector(selector, document);\n        const success = predicate(element);\n        if (success)\n            return Promise.resolve(success);\n        let fulfill;\n        const result = new Promise(x => fulfill = x);\n        const observer = new MutationObserver(() => {\n            if (timedOut) {\n                observer.disconnect();\n                fulfill();\n                return;\n            }\n            const element = selector === undefined ? undefined : this.querySelector(selector, document);\n            const success = predicate(element);\n            if (success) {\n                observer.disconnect();\n                fulfill(success);\n            }\n        });\n        observer.observe(document, {\n            childList: true,\n            subtree: true,\n            attributes: true\n        });\n        return result;\n    }\n    pollRaf(selector, predicate, timeout) {\n        let timedOut = false;\n        if (timeout)\n            setTimeout(() => timedOut = true, timeout);\n        let fulfill;\n        const result = new Promise(x => fulfill = x);\n        const onRaf = () => {\n            if (timedOut) {\n                fulfill();\n                return;\n            }\n            const element = selector === undefined ? undefined : this.querySelector(selector, document);\n            const success = predicate(element);\n            if (success)\n                fulfill(success);\n            else\n                requestAnimationFrame(onRaf);\n        };\n        onRaf();\n        return result;\n    }\n    pollInterval(selector, pollInterval, predicate, timeout) {\n        let timedOut = false;\n        if (timeout)\n            setTimeout(() => timedOut = true, timeout);\n        let fulfill;\n        const result = new Promise(x => fulfill = x);\n        const onTimeout = () => {\n            if (timedOut) {\n                fulfill();\n                return;\n            }\n            const element = selector === undefined ? undefined : this.querySelector(selector, document);\n            const success = predicate(element);\n            if (success)\n                fulfill(success);\n            else\n                setTimeout(onTimeout, pollInterval);\n        };\n        onTimeout();\n        return result;\n    }\n}\nexports.default = Injected;\n\n\n/***/ }),\n\n/***/ \""./src/injected/textSelectorEngine.ts\"":\n/*!********************************************!*\\\n  !*** ./src/injected/textSelectorEngine.ts ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\""use strict\"";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \""License\"");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \""AS IS\"" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \""__esModule\"", { value: true });\nexports.TextEngine = {\n    name: 'text',\n    create(root, targetElement, type) {\n        const document = root instanceof Document ? root : root.ownerDocument;\n        if (!document)\n            return;\n        for (let child = targetElement.firstChild; child; child = child.nextSibling) {\n            if (child.nodeType === 3 /* Node.TEXT_NODE */) {\n                const text = child.nodeValue;\n                if (!text)\n                    continue;\n                if (text.match(/^\\s*[a-zA-Z0-9]+\\s*$/) && exports.TextEngine.query(root, text.trim()) === targetElement)\n                    return text.trim();\n                if (exports.TextEngine.query(root, JSON.stringify(text)) === targetElement)\n                    return JSON.stringify(text);\n            }\n        }\n    },\n    query(root, selector) {\n        const document = root instanceof Document ? root : root.ownerDocument;\n        if (!document)\n            return;\n        const matcher = createMatcher(selector);\n        const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);\n        while (walker.nextNode()) {\n            const node = walker.currentNode;\n            const element = node.parentElement;\n            const text = node.nodeValue;\n            if (element && text && matcher(text))\n                return element;\n        }\n    },\n    queryAll(root, selector) {\n        const result = [];\n        const document = root instanceof Document ? root : root.ownerDocument;\n        if (!document)\n            return result;\n        const matcher = createMatcher(selector);\n        const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);\n        while (walker.nextNode()) {\n            const node = walker.currentNode;\n            const element = node.parentElement;\n            const text = node.nodeValue;\n            if (element && text && matcher(text))\n                result.push(element);\n        }\n        return result;\n    }\n};\nfunction createMatcher(selector) {\n    if (selector[0] === '\""' && selector[selector.length - 1] === '\""') {\n        const parsed = JSON.parse(selector);\n        return text => text === parsed;\n    }\n    if (selector[0] === '/' && selector.lastIndexOf('/') > 0) {\n        const lastSlash = selector.lastIndexOf('/');\n        const re = new RegExp(selector.substring(1, lastSlash), selector.substring(lastSlash + 1));\n        return text => re.test(text);\n    }\n    selector = selector.trim();\n    return text => text.trim() === selector;\n}\n\n\n/***/ }),\n\n/***/ \""./src/injected/utils.ts\"":\n/*!*******************************!*\\\n  !*** ./src/injected/utils.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\""use strict\"";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \""License\"");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \""AS IS\"" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \""__esModule\"", { value: true });\nclass Utils {\n    parentElementOrShadowHost(element) {\n        if (element.parentElement)\n            return element.parentElement;\n        if (!element.parentNode)\n            return;\n        if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n            return element.parentNode.host;\n    }\n    deepElementFromPoint(document, x, y) {\n        let container = document;\n        let element;\n        while (container) {\n            const innerElement = container.elementFromPoint(x, y);\n            if (!innerElement || element === innerElement)\n                break;\n            element = innerElement;\n            container = element.shadowRoot;\n        }\n        return element;\n    }\n}\nexports.Utils = Utils;\n\n\n/***/ }),\n\n/***/ \""./src/injected/xpathSelectorEngine.ts\"":\n/*!*********************************************!*\\\n  !*** ./src/injected/xpathSelectorEngine.ts ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\""use strict\"";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \""License\"");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \""AS IS\"" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \""__esModule\"", { value: true });\nconst maxTextLength = 80;\nconst minMeaningfulSelectorLegth = 100;\nexports.XPathEngine = {\n    name: 'xpath',\n    create(root, targetElement, type) {\n        const maybeDocument = root instanceof Document ? root : root.ownerDocument;\n        if (!maybeDocument)\n            return;\n        const document = maybeDocument;\n        const xpathCache = new Map();\n        if (type === 'notext')\n            return createNoText(root, targetElement);\n        const tokens = [];\n        function evaluateXPath(expression) {\n            let nodes = xpathCache.get(expression);\n            if (!nodes) {\n                nodes = [];\n                try {\n                    const result = document.evaluate(expression, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n                    for (let node = result.iterateNext(); node; node = result.iterateNext()) {\n                        if (node.nodeType === Node.ELEMENT_NODE)\n                            nodes.push(node);\n                    }\n                }\n                catch (e) {\n                }\n                xpathCache.set(expression, nodes);\n            }\n            return nodes;\n        }\n        function uniqueXPathSelector(prefix) {\n            const path = tokens.slice();\n            if (prefix)\n                path.unshift(prefix);\n            let selector = '//' + path.join('/');\n            while (selector.includes('///'))\n                selector = selector.replace('///', '//');\n            if (selector.endsWith('/'))\n                selector = selector.substring(0, selector.length - 1);\n            const nodes = evaluateXPath(selector);\n            if (nodes[nodes.length - 1] === targetElement)\n                return selector;\n            // If we are looking at a small set of elements with long selector, fall back to ordinal.\n            if (nodes.length < 5 && selector.length > minMeaningfulSelectorLegth) {\n                const index = nodes.indexOf(targetElement);\n                if (index !== -1)\n                    return `(${selector})[${index + 1}]`;\n            }\n            return undefined;\n        }\n        function escapeAndCap(text) {\n            text = text.substring(0, maxTextLength);\n            // XPath 1.0 does not support quote escaping.\n            // 1. If there are no single quotes - use them.\n            if (text.indexOf(`'`) === -1)\n                return `'${text}'`;\n            // 2. If there are no double quotes - use them to enclose text.\n            if (text.indexOf(`\""`) === -1)\n                return `\""${text}\""`;\n            // 3. Otherwise, use popular |concat| trick.\n            const Q = `'`;\n            return `concat(${text.split(Q).map(token => Q + token + Q).join(`, \""'\"", `)})`;\n        }\n        const defaultAttributes = new Set(['title', 'aria-label', 'disabled', 'role']);\n        const importantAttributes = new Map([\n            ['form', ['action']],\n            ['img', ['alt']],\n            ['input', ['placeholder', 'type', 'name', 'value']],\n        ]);\n        let usedTextConditions = false;\n        for (let element = targetElement; element && element !== root; element = element.parentElement) {\n            const nodeName = element.nodeName.toLowerCase();\n            const tag = nodeName === 'svg' ? '*' : nodeName;\n            const tagConditions = [];\n            if (nodeName === 'svg')\n                tagConditions.push('local-name()=\""svg\""');\n            const attrConditions = [];\n            const importantAttrs = [...defaultAttributes, ...(importantAttributes.get(tag) || [])];\n            for (const attr of importantAttrs) {\n                const value = element.getAttribute(attr);\n                if (value && value.length < maxTextLength)\n                    attrConditions.push(`normalize-space(@${attr})=${escapeAndCap(value)}`);\n                else if (value)\n                    attrConditions.push(`starts-with(normalize-space(@${attr}), ${escapeAndCap(value)})`);\n            }\n            const text = document.evaluate('normalize-space(.)', element).stringValue;\n            const textConditions = [];\n            if (tag !== 'select' && text.length && !usedTextConditions) {\n                if (text.length < maxTextLength)\n                    textConditions.push(`normalize-space(.)=${escapeAndCap(text)}`);\n                else\n                    textConditions.push(`starts-with(normalize-space(.), ${escapeAndCap(text)})`);\n                usedTextConditions = true;\n            }\n            // Always retain the last tag.\n            const conditions = [...tagConditions, ...textConditions, ...attrConditions];\n            const token = conditions.length ? `${tag}[${conditions.join(' and ')}]` : (tokens.length ? '' : tag);\n            const selector = uniqueXPathSelector(token);\n            if (selector)\n                return selector;\n            // Ordinal is the weakest signal.\n            const parent = element.parentElement;\n            let tagWithOrdinal = tag;\n            if (parent) {\n                const siblings = Array.from(parent.children);\n                const sameTagSiblings = siblings.filter(sibling => sibling.nodeName.toLowerCase() === nodeName);\n                if (sameTagSiblings.length > 1)\n                    tagWithOrdinal += `[${1 + siblings.indexOf(element)}]`;\n            }\n            // Do not include text into this token, only tag / attributes.\n            // Topmost node will get all the text.\n            const nonTextConditions = [...tagConditions, ...attrConditions];\n            const levelToken = nonTextConditions.length ? `${tagWithOrdinal}[${nonTextConditions.join(' and ')}]` : tokens.length ? '' : tagWithOrdinal;\n            tokens.unshift(levelToken);\n        }\n        return uniqueXPathSelector();\n    },\n    query(root, selector) {\n        const document = root instanceof Document ? root : root.ownerDocument;\n        if (!document)\n            return;\n        const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n        for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n            if (node.nodeType === Node.ELEMENT_NODE)\n                return node;\n        }\n    },\n    queryAll(root, selector) {\n        const result = [];\n        const document = root instanceof Document ? root : root.ownerDocument;\n        if (!document)\n            return result;\n        const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n        for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n            if (node.nodeType === Node.ELEMENT_NODE)\n                result.push(node);\n        }\n        return result;\n    }\n};\nfunction createNoText(root, targetElement) {\n    const steps = [];\n    for (let element = targetElement; element && element !== root; element = element.parentElement) {\n        if (element.getAttribute('id')) {\n            steps.unshift(`//*[@id=\""${element.getAttribute('id')}\""]`);\n            return steps.join('/');\n        }\n        const siblings = element.parentElement ? Array.from(element.parentElement.children) : [];\n        const similarElements = siblings.filter(sibling => element.nodeName === sibling.nodeName);\n        const index = similarElements.length === 1 ? 0 : similarElements.indexOf(element) + 1;\n        steps.unshift(index ? `${element.nodeName}[${index}]` : element.nodeName);\n    }\n    return '/' + steps.join('/');\n}\n\n\n/***/ })\n\n/******/ })).default";
        private readonly IExecutionContextDelegate _delegate;
        private int _injectedGeneration = -1;
        private Task<IJSHandle> _injectedTask;

        internal FrameExecutionContext(IExecutionContextDelegate executionContextDelegate, Frame frame)
        {
            _delegate = executionContextDelegate;
            Frame = frame;
        }

        public Frame Frame { get; set; }

        public Task<T> EvaluateAsync<T>(string script, params object[] args) => EvaluateAsync<T>(true, script, args);

        public async Task<T> EvaluateAsync<T>(bool returnByValue, string script, params object[] args)
        {
            Func<object, bool> needsAdoption = (object value) => value is ElementHandle elementHandle && elementHandle.Context != this;

            if (!args.Any(needsAdoption))
            {
                return await _delegate.EvaluateAsync<T>(this, returnByValue, script, args).ConfigureAwait(false);
            }

            List<Task<ElementHandle>> toDispose = new List<Task<ElementHandle>>();

            var adoptedTasks = args.Select<object, Task<object>>(arg =>
            {
                if (!needsAdoption(arg))
                {
                    return Task.FromResult(arg);
                }

                var adopted = Frame.Page.Delegate.AdoptElementHandleAsync(arg, this);
                toDispose.Add(adopted);
                return adopted.ContinueWith(t => (object)t.Result, TaskScheduler.Default);
            });

            await Task.WhenAll(adoptedTasks).ConfigureAwait(false);

            T result;
            try
            {
                result = await _delegate.EvaluateAsync<T>(this, returnByValue, script, adoptedTasks.Select(t => t.Result).ToArray()).ConfigureAwait(false);
            }
            finally
            {
                await Task.WhenAll(toDispose
                    .Select(handlePromise => handlePromise.ContinueWith(handleTask => handleTask.Result.DisposeAsync(), TaskScheduler.Default)))
                    .ConfigureAwait(false);
            }

            return result;
        }

        public Task<IJSHandle> EvaluateHandleAsync(string script, params object[] args) => EvaluateAsync<IJSHandle>(false, script, args);

        public Task<IElementHandle> QuerySelectorAsync(string selector)
        {
            throw new NotImplementedException();
        }

        public Task<IJSHandle> GetInjectedAsync()
        {
            var selectors = Selectors.Instance.Value;
            if (_injectedTask != null && selectors.Generation != _injectedGeneration)
            {
                _injectedTask.ContinueWith(handleTask => handleTask.Result.DisposeAsync(), TaskScheduler.Default);
                _injectedTask = null;
            }

            if (_injectedTask == null)
            {
                string source = $@"
                    new (${_injectedSource})([
                      ${string.Join(",\n", selectors.Sources)},
                    ])
                  ";
                _injectedTask = EvaluateHandleAsync(source);
                _injectedGeneration = selectors.Generation;
            }

            return _injectedTask;
        }

        internal JsonElement CreateHandle(JsonElement? remoteObject)
        {
            throw new NotImplementedException();
        }
    }
}
