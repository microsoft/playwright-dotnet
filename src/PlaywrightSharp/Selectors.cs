using System;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace PlaywrightSharp
{
    internal class Selectors
    {
        public Selectors()
        {
            // This could eventually be an embeeded resources downloaded from pw
            Sources = new[] { "(/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/injected/zsSelectorEngine.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/injected/zsSelectorEngine.ts\":\n/*!******************************************!*\\\n  !*** ./src/injected/zsSelectorEngine.ts ***!\n  \\******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction tokenize(selector) {\n    const tokens = [];\n    let pos = 0;\n    const skipWhitespace = () => {\n        while (pos < selector.length && selector[pos] === ' ')\n            pos++;\n    };\n    while (pos < selector.length) {\n        skipWhitespace();\n        if (pos === selector.length)\n            break;\n        if (!tokens.length && '^>~'.includes(selector[pos]))\n            return pos;\n        const token = { combinator: '' };\n        if (selector[pos] === '^') {\n            token.combinator = '^';\n            tokens.push(token);\n            pos++;\n            continue;\n        }\n        if (selector[pos] === '>') {\n            token.combinator = '>';\n            pos++;\n            skipWhitespace();\n            if (pos === selector.length)\n                return pos;\n        }\n        else if (selector[pos] === '~') {\n            token.combinator = '~';\n            pos++;\n            skipWhitespace();\n            if (pos === selector.length)\n                return pos;\n        }\n        let text = '';\n        let end = pos;\n        let stringQuote;\n        const isText = '`\"\\''.includes(selector[pos]);\n        while (end < selector.length) {\n            if (stringQuote) {\n                if (selector[end] === '\\\\' && end + 1 < selector.length) {\n                    if (!isText)\n                        text += selector[end];\n                    text += selector[end + 1];\n                    end += 2;\n                }\n                else if (selector[end] === stringQuote) {\n                    text += selector[end++];\n                    stringQuote = undefined;\n                    if (isText)\n                        break;\n                }\n                else {\n                    text += selector[end++];\n                }\n            }\n            else if (' >~^#'.includes(selector[end])) {\n                break;\n            }\n            else if ('`\"\\''.includes(selector[end])) {\n                stringQuote = selector[end];\n                text += selector[end++];\n            }\n            else {\n                text += selector[end++];\n            }\n        }\n        if (stringQuote)\n            return end;\n        if (isText)\n            token.text = JSON.stringify(text.substring(1, text.length - 1));\n        else\n            token.css = text;\n        pos = end;\n        if (pos < selector.length && selector[pos] === '#') {\n            pos++;\n            let end = pos;\n            while (end < selector.length && selector[end] >= '0' && selector[end] <= '9')\n                end++;\n            if (end === pos)\n                return pos;\n            const num = Number(selector.substring(pos, end));\n            if (isNaN(num))\n                return pos;\n            token.index = num;\n            pos = end;\n        }\n        tokens.push(token);\n    }\n    return tokens;\n}\nfunction pathFromRoot(root, targetElement) {\n    let target = targetElement;\n    const path = [target];\n    while (target !== root) {\n        if (!target.parentNode || target.parentNode.nodeType !== 1 /* Node.ELEMENT_NODE */ && target.parentNode.nodeType !== 11 /* Node.DOCUMENT_FRAGMENT_NODE */)\n            throw new Error('Target does not belong to the root subtree');\n        target = target.parentNode;\n        path.push(target);\n    }\n    path.reverse();\n    return path;\n}\nfunction detectLists(root, shouldConsider, getBox) {\n    const lists = new Map();\n    const add = (map, element, key) => {\n        let list = map.get(key);\n        if (!list) {\n            list = [];\n            map.set(key, list);\n        }\n        list.push(element);\n    };\n    const mark = (parent, map, used) => {\n        for (let list of map.values()) {\n            list = list.filter(item => !used.has(item));\n            if (list.length < 2)\n                continue;\n            let collection = lists.get(parent);\n            if (!collection) {\n                collection = [];\n                lists.set(parent, collection);\n            }\n            collection.push(list);\n            list.forEach(item => used.add(item));\n        }\n    };\n    // hashes list: s, vh, v, h\n    const kHashes = 4;\n    const visit = (element, produceHashes) => {\n        const consider = shouldConsider(element);\n        let size = 1;\n        let maps;\n        if (consider)\n            maps = new Array(kHashes).fill(0).map(_ => new Map());\n        let structure;\n        if (produceHashes)\n            structure = [element.nodeName];\n        for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n            const childResult = visit(child, consider);\n            size += childResult.size;\n            if (consider) {\n                for (let i = 0; i < childResult.hashes.length; i++) {\n                    if (childResult.hashes[i])\n                        add(maps[i], child, childResult.hashes[i]);\n                }\n            }\n            if (structure)\n                structure.push(child.nodeName);\n        }\n        if (consider) {\n            const used = new Set();\n            maps.forEach(map => mark(element, map, used));\n        }\n        let hashes;\n        if (produceHashes) {\n            const box = getBox(element);\n            hashes = [];\n            hashes.push((structure.length >= 4) || (size >= 10) ? structure.join('') : '');\n            hashes.push(`${element.nodeName},${(size / 3) | 0},${box.height | 0},${box.width | 0}`);\n            if (size <= 5)\n                hashes.push(`${element.nodeName},${(size / 3) | 0},${box.width | 0},${box.left | 0}`);\n            else\n                hashes.push(`${element.nodeName},${(size / 3) | 0},${box.width | 0},${box.left | 0},${2 * Math.log(box.height) | 0}`);\n            if (size <= 5)\n                hashes.push(`${element.nodeName},${(size / 3) | 0},${box.height | 0},${box.top | 0}`);\n            else\n                hashes.push(`${element.nodeName},${(size / 3) | 0},${box.height | 0},${box.top | 0},${2 * Math.log(box.width) | 0}`);\n        }\n        return { size, hashes };\n    };\n    visit(root, false);\n    return lists;\n}\nconst defaultOptions = {\n    genericTagScore: 10,\n    textScore: 1,\n    imgAltScore: 2,\n    ariaLabelScore: 2,\n    detectLists: true,\n    avoidShortText: false,\n    usePlaceholders: true,\n    debug: false,\n};\nfunction parentOrRoot(element) {\n    return element.parentNode;\n}\nclass Engine {\n    constructor(options = defaultOptions) {\n        this._cues = new Map();\n        this._metrics = new Map();\n        this.options = options;\n    }\n    query(root, selector, all) {\n        const tokens = tokenize(selector);\n        if (typeof tokens === 'number')\n            throw new Error('Cannot parse selector at position ' + tokens);\n        if (!tokens.length)\n            throw new Error('Empty selector');\n        if (!this._cues.has(root)) {\n            const cueMap = new Map();\n            const pathCues = this._preprocess(root, [root], Infinity).pathCues;\n            for (const [text, cue] of pathCues) {\n                cueMap.set(text, {\n                    type: cue.type,\n                    score: cue.score,\n                    elements: cue.elements[0]\n                });\n            }\n            this._cues.set(root, cueMap);\n        }\n        // Map from the element to the boundary used. We never go outside the boundary when doing '~'.\n        let currentStep = new Map();\n        currentStep.set(root, root);\n        for (const token of tokens) {\n            const nextStep = new Map();\n            for (let [element, boundary] of currentStep) {\n                let next = [];\n                if (token.combinator === '^') {\n                    if (element === boundary) {\n                        next = [];\n                    }\n                    else {\n                        const parent = parentOrRoot(element);\n                        next = parent ? [parent] : [];\n                    }\n                }\n                else if (token.combinator === '>') {\n                    boundary = element;\n                    next = this._matchChildren(element, token, all);\n                }\n                else if (token.combinator === '') {\n                    boundary = element;\n                    next = this._matchSubtree(element, token, all);\n                }\n                else if (token.combinator === '~') {\n                    while (true) {\n                        next = this._matchSubtree(element, token, all);\n                        if (next.length) {\n                            // Further '~' / '^' will not go outside of this boundary, which is\n                            // a container with both the cue and the target elements inside.\n                            boundary = element;\n                            break;\n                        }\n                        if (element === boundary)\n                            break;\n                        element = parentOrRoot(element);\n                    }\n                }\n                for (const nextElement of next) {\n                    if (!nextStep.has(nextElement))\n                        nextStep.set(nextElement, boundary);\n                }\n            }\n            currentStep = nextStep;\n        }\n        return Array.from(currentStep.keys()).filter(e => e.nodeType === 1 /* Node.ELEMENT_NODE */);\n    }\n    create(root, target, type) {\n        const path = pathFromRoot(root, target);\n        const maxCueCount = type === 'notext' ? 50 : 10;\n        const { pathCues, lcaMap } = this._preprocess(root, path, maxCueCount);\n        const lists = this.options.detectLists ?\n            this._buildLists(root, path) : undefined;\n        const queue = path.map(_ => new Map());\n        const startStep = {\n            token: { combinator: '' },\n            element: root,\n            depth: 0,\n            score: 0,\n            totalScore: 0\n        };\n        for (let stepDepth = -1; stepDepth < path.length; stepDepth++) {\n            const stepsMap = stepDepth === -1 ? new Map([[undefined, startStep]]) : queue[stepDepth];\n            const ancestorDepth = stepDepth === -1 ? 0 : stepDepth;\n            for (const [text, cue] of pathCues) {\n                const elements = cue.elements[ancestorDepth];\n                for (let index = 0; index < elements.length; index++) {\n                    const element = elements[index];\n                    const lca = lcaMap.get(element);\n                    const lcaDepth = lca.lcaDepth;\n                    // Always go deeper in the tree.\n                    if (lcaDepth <= stepDepth)\n                        continue;\n                    // 'notext' - do not use elements from the target's subtree.\n                    if (type === 'notext' && lcaDepth === path.length - 1 && lca.depth > 0)\n                        continue;\n                    // 'notext' - do not use target's own text.\n                    if (type === 'notext' && lcaDepth === path.length - 1 && !lca.depth && cue.type !== 'tag')\n                        continue;\n                    const targetAnchor = path[lcaDepth + 1];\n                    if (lists && lca.anchor && targetAnchor && lca.anchor !== targetAnchor) {\n                        const oldList = lists.get(lca.anchor);\n                        // Do not use cues from sibling list items (lca.anchor and targetAnchor).\n                        if (oldList && oldList === lists.get(targetAnchor))\n                            continue;\n                    }\n                    if (cue.type !== 'tag' && !this._isVisible(element))\n                        continue;\n                    const distanceToTarget = path.length - stepDepth;\n                    // Short text can be used more effectively in a smaller scope.\n                    let shortTextScore = 0;\n                    if (this.options.avoidShortText && cue.type === 'text')\n                        shortTextScore = Math.max(0, distanceToTarget - 2 * (text.length - 2));\n                    const score = (cue.score + shortTextScore) * (\n                    // Unique cues are heavily favored.\n                    1 * (index + elements.length * 1000) +\n                        // Larger text is preferred.\n                        5 * (cue.type === 'text' ? this._elementMetrics(element).fontMetric : 1) +\n                        // The closer to the target, the better.\n                        1 * lca.depth);\n                    for (const [anchor, step] of stepsMap) {\n                        // This ensures uniqueness when resolving the selector.\n                        if (anchor && (cue.anchorCount.get(anchor) || 0) > index)\n                            continue;\n                        let newStep = {\n                            token: {\n                                combinator: stepDepth === -1 ? '' : '~',\n                                text: cue.type === 'text' ? text : undefined,\n                                css: cue.type === 'text' ? undefined : text,\n                                index: index || undefined,\n                            },\n                            previous: step,\n                            depth: lca.depth,\n                            element,\n                            score,\n                            totalScore: step.totalScore + score\n                        };\n                        let nextStep = queue[lcaDepth].get(lca.anchor);\n                        if (!nextStep || nextStep.totalScore > newStep.totalScore)\n                            queue[lcaDepth].set(lca.anchor, newStep);\n                        // Try going to the ancestor.\n                        if (newStep.depth) {\n                            newStep = {\n                                token: { combinator: '^' },\n                                previous: newStep,\n                                depth: 0,\n                                element: lca.lca,\n                                score: 2000 * newStep.depth,\n                                totalScore: newStep.totalScore + 2000 * newStep.depth,\n                                repeat: newStep.depth\n                            };\n                            nextStep = queue[lcaDepth].get(undefined);\n                            if (!nextStep || nextStep.totalScore > newStep.totalScore)\n                                queue[lcaDepth].set(undefined, newStep);\n                        }\n                    }\n                }\n            }\n        }\n        let best;\n        for (const [, step] of queue[path.length - 1]) {\n            if (!best || step.totalScore < best.totalScore)\n                best = step;\n        }\n        if (!best)\n            return '';\n        const tokens = new Array(best.depth).fill({ combinator: '^' });\n        while (best && best !== startStep) {\n            for (let repeat = best.repeat || 1; repeat; repeat--)\n                tokens.push(best.token);\n            best = best.previous;\n        }\n        tokens.reverse();\n        return this._serialize(tokens);\n    }\n    _textMetric(text) {\n        // Text which looks like a float number or counter is most likely volatile.\n        if (/^\\$?[\\d,]+(\\.\\d+|(\\.\\d+)?[kKmMbBgG])?$/.test(text))\n            return 12;\n        const num = Number(text);\n        // Large numbers are likely volatile.\n        if (!isNaN(num) && (num >= 32 || num < 0))\n            return 6;\n        return 1;\n    }\n    _elementMetrics(element) {\n        let metrics = this._metrics.get(element);\n        if (!metrics) {\n            const style = element.ownerDocument ?\n                element.ownerDocument.defaultView.getComputedStyle(element) :\n                {};\n            const box = element.getBoundingClientRect();\n            const fontSize = (parseInt(style.fontSize || '', 10) || 12) / 12; // default 12 px\n            const fontWeight = (parseInt(style.fontWeight || '', 10) || 400) / 400; // default normal weight\n            let fontMetric = fontSize * (1 + (fontWeight - 1) / 5);\n            fontMetric = 1 / Math.exp(fontMetric - 1);\n            metrics = { box, style, fontMetric };\n            this._metrics.set(element, metrics);\n        }\n        return metrics;\n    }\n    _isVisible(element) {\n        const metrics = this._elementMetrics(element);\n        return metrics.box.width > 1 && metrics.box.height > 1;\n    }\n    _preprocess(root, path, maxCueCount) {\n        const pathCues = new Map();\n        const lcaMap = new Map();\n        const textScore = this.options.textScore || 1;\n        const appendCue = (text, type, score, element, lca, textValue) => {\n            let pathCue = pathCues.get(text);\n            if (!pathCue) {\n                pathCue = { type, score: (textValue ? this._textMetric(textValue) : 1) * score, elements: [], anchorCount: new Map() };\n                for (let i = 0; i < path.length; i++)\n                    pathCue.elements.push([]);\n                pathCues.set(text, pathCue);\n            }\n            for (let index = lca.lcaDepth; index >= 0; index--) {\n                const elements = pathCue.elements[index];\n                if (elements.length < maxCueCount)\n                    elements.push(element);\n            }\n            if (lca.anchor)\n                pathCue.anchorCount.set(lca.anchor, 1 + (pathCue.anchorCount.get(lca.anchor) || 0));\n        };\n        const appendElementCues = (element, lca, detached) => {\n            const nodeName = element.nodeName;\n            if (!detached && this.options.usePlaceholders && nodeName === 'INPUT') {\n                const placeholder = element.getAttribute('placeholder');\n                if (placeholder)\n                    appendCue(JSON.stringify(placeholder), 'text', textScore, element, lca, placeholder);\n            }\n            if (!detached && nodeName === 'INPUT' && element.getAttribute('type') === 'button') {\n                const value = element.getAttribute('value');\n                if (value)\n                    appendCue(JSON.stringify(value), 'text', textScore, element, lca, value);\n            }\n            if (!nodeName.startsWith('<pseudo') && !nodeName.startsWith('::'))\n                appendCue(nodeName, 'tag', this.options.genericTagScore, element, lca, '');\n            if (this.options.imgAltScore && nodeName === 'IMG') {\n                const alt = element.getAttribute('alt');\n                if (alt)\n                    appendCue(`img[alt=${JSON.stringify(alt)}]`, 'imgAlt', this.options.imgAltScore, element, lca, alt);\n            }\n            if (this.options.ariaLabelScore) {\n                const ariaLabel = element.getAttribute('aria-label');\n                if (ariaLabel)\n                    appendCue(JSON.stringify(`[aria-label=${JSON.stringify(ariaLabel)}]`), 'ariaLabel', this.options.ariaLabelScore, element, lca, ariaLabel);\n            }\n        };\n        const visit = (element, lca, depth) => {\n            // Check for elements STYLE, NOSCRIPT, SCRIPT, OPTION and other elements\n            // that have |display:none| behavior.\n            const detached = !element.offsetParent;\n            if (element.nodeType === 1 /* Node.ELEMENT_NODE */)\n                appendElementCues(element, lca, detached);\n            lcaMap.set(element, lca);\n            for (let childNode = element.firstChild; childNode; childNode = childNode.nextSibling) {\n                if (element.nodeType === 1 /* Node.ELEMENT_NODE */ && !detached && childNode.nodeType === 3 /* Node.TEXT_NODE */ && childNode.nodeValue) {\n                    const textValue = childNode.nodeValue.trim();\n                    if (textValue)\n                        appendCue(JSON.stringify(textValue), 'text', textScore, element, lca, textValue);\n                }\n                if (childNode.nodeType !== 1 /* Node.ELEMENT_NODE */)\n                    continue;\n                const childElement = childNode;\n                if (childElement.nodeName.startsWith('<pseudo:'))\n                    continue;\n                if (path[depth + 1] === childElement) {\n                    const childLca = { depth: 0, lca: childElement, lcaDepth: depth + 1, anchor: undefined };\n                    visit(childElement, childLca, depth + 1);\n                }\n                else {\n                    const childLca = { depth: lca.depth + 1, lca: lca.lca, lcaDepth: lca.lcaDepth, anchor: lca.anchor || element };\n                    visit(childElement, childLca, depth + 1);\n                }\n            }\n        };\n        visit(root, { depth: 0, lca: root, lcaDepth: 0, anchor: undefined }, 0);\n        return { pathCues: pathCues, lcaMap };\n    }\n    _filterCues(cues, root) {\n        const result = new Map();\n        for (const [text, cue] of cues) {\n            const filtered = cue.elements.filter(element => root.contains(element));\n            if (!filtered.length)\n                continue;\n            const newCue = { type: cue.type, score: cue.score, elements: filtered };\n            result.set(text, newCue);\n        }\n        return result;\n    }\n    _buildLists(root, path) {\n        const pathSet = new Set(path);\n        const map = detectLists(root, e => pathSet.has(e), e => this._elementMetrics(e).box);\n        const result = new Map();\n        let listNumber = 1;\n        for (const collection of map.values()) {\n            for (const list of collection) {\n                for (const child of list)\n                    result.set(child, listNumber);\n                ++listNumber;\n            }\n        }\n        return result;\n    }\n    _matchChildren(parent, token, all) {\n        const result = [];\n        if (token.index !== undefined)\n            all = false;\n        let index = token.index || 0;\n        if (token.css !== undefined) {\n            for (let child = parent.firstElementChild; child; child = child.nextElementSibling) {\n                if (child.matches(token.css) && (all || !index--)) {\n                    result.push(child);\n                    if (!all)\n                        return result;\n                }\n            }\n            return result;\n        }\n        if (token.text !== undefined) {\n            const cue = this._getCues(parent).get(token.text);\n            if (!cue || cue.type !== 'text')\n                return [];\n            for (const element of cue.elements) {\n                if (parentOrRoot(element) === parent && (all || !index--)) {\n                    result.push(element);\n                    if (!all)\n                        return result;\n                }\n            }\n            return result;\n        }\n        throw new Error('Unsupported token');\n    }\n    _matchSubtree(root, token, all) {\n        const result = [];\n        if (token.index !== undefined)\n            all = false;\n        let index = token.index || 0;\n        if (token.css !== undefined) {\n            if (root.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                const rootElement = root;\n                if (rootElement.matches(token.css) && (all || !index--)) {\n                    result.push(rootElement);\n                    if (!all)\n                        return result;\n                }\n            }\n            const queried = root.querySelectorAll(token.css);\n            if (all)\n                result.push(...Array.from(queried));\n            else if (queried.length > index)\n                result.push(queried.item(index));\n            return result;\n        }\n        if (token.text !== undefined) {\n            const texts = this._getCues(root);\n            const cue = texts.get(token.text);\n            if (!cue || cue.type !== 'text')\n                return result;\n            if (all)\n                return cue.elements;\n            if (index < cue.elements.length)\n                result.push(cue.elements[index]);\n            return result;\n        }\n        throw new Error('Unsupported token');\n    }\n    _getCues(element) {\n        if (!this._cues.has(element)) {\n            let parent = element;\n            while (!this._cues.has(parent))\n                parent = parentOrRoot(parent);\n            this._cues.set(element, this._filterCues(this._cues.get(parent), element));\n        }\n        return this._cues.get(element);\n    }\n    _serialize(tokens) {\n        const result = tokens.map(token => (token.combinator === '' ? ' ' : token.combinator) +\n            (token.text !== undefined ? token.text : '') +\n            (token.css !== undefined ? token.css : '') +\n            (token.index !== undefined ? '#' + token.index : '')).join('');\n        if (result[0] !== ' ')\n            throw new Error('First token is wrong');\n        return result.substring(1);\n    }\n}\nconst ZSSelectorEngine = {\n    name: 'zs',\n    create(root, element, type) {\n        return new Engine().create(root, element, type || 'default');\n    },\n    query(root, selector) {\n        return new Engine().query(root, selector, false /* all */)[0];\n    },\n    queryAll(root, selector) {\n        return new Engine().query(root, selector, true /* all */);\n    }\n};\nZSSelectorEngine.test = () => {\n    const elements = Array.from(document.querySelectorAll('*')).slice(1500, 2000);\n    console.time('test'); // eslint-disable-line no-console\n    const failures = elements.filter((e, index) => {\n        const name = e.tagName.toUpperCase();\n        if (name === 'SCRIPT' || name === 'STYLE' || name === 'NOSCRIPT' || name === 'META' || name === 'LINK' || name === 'OPTION')\n            return false;\n        if (index % 100 === 0)\n            console.log(`${index} / ${elements.length}`); // eslint-disable-line no-console\n        if (e.nodeName.toLowerCase().startsWith('<pseudo:'))\n            e = e.parentElement;\n        while (e && e.namespaceURI && e.namespaceURI.endsWith('svg') && e.nodeName.toLowerCase() !== 'svg')\n            e = e.parentElement;\n        try {\n            document.documentElement.style.outline = '1px solid red';\n            const selector = new Engine().create(document.documentElement, e, 'default');\n            document.documentElement.style.outline = '1px solid green';\n            const e2 = new Engine().query(document.documentElement, selector, false)[0];\n            return e !== e2;\n        }\n        catch (e) {\n            return false;\n        }\n    });\n    console.timeEnd('test'); // eslint-disable-line no-console\n    console.log(failures); // eslint-disable-line no-console\n};\nexports.default = ZSSelectorEngine;\n\n\n/***/ })\n\n/******/ })).default" };
        }

        public static Lazy<Selectors> Instance => new Lazy<Selectors>(() => new Selectors());

        public int Generation { get; set; }

        public string[] Sources { get; }

        private async Task<string> GetSources()
        {
            using var stream = typeof(Selectors).Assembly.GetManifestResourceStream("PlaywrightSharp.Resources.zsSelectorEngineSource.ts");
            using (var reader = new StreamReader(stream, Encoding.UTF8))
            {
                return await reader.ReadToEndAsync().ConfigureAwait(false);
            }
        }
    }
}