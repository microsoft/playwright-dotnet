//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

using System.Text.Json;

namespace PlaywrightSharp.Chromium.Protocol.Accessibility
{
/// <summary>
/// Enum of possible property types.
/// </summary>
internal enum AXValueType
{
[System.Runtime.Serialization.EnumMember(Value = "boolean")]Boolean,
[System.Runtime.Serialization.EnumMember(Value = "tristate")]Tristate,
[System.Runtime.Serialization.EnumMember(Value = "booleanOrUndefined")]BooleanOrUndefined,
[System.Runtime.Serialization.EnumMember(Value = "idref")]Idref,
[System.Runtime.Serialization.EnumMember(Value = "idrefList")]IdrefList,
[System.Runtime.Serialization.EnumMember(Value = "integer")]Integer,
[System.Runtime.Serialization.EnumMember(Value = "node")]Node,
[System.Runtime.Serialization.EnumMember(Value = "nodeList")]NodeList,
[System.Runtime.Serialization.EnumMember(Value = "number")]Number,
[System.Runtime.Serialization.EnumMember(Value = "string")]String,
[System.Runtime.Serialization.EnumMember(Value = "computedString")]ComputedString,
[System.Runtime.Serialization.EnumMember(Value = "token")]Token,
[System.Runtime.Serialization.EnumMember(Value = "tokenList")]TokenList,
[System.Runtime.Serialization.EnumMember(Value = "domRelation")]DomRelation,
[System.Runtime.Serialization.EnumMember(Value = "role")]Role,
[System.Runtime.Serialization.EnumMember(Value = "internalRole")]InternalRole,
[System.Runtime.Serialization.EnumMember(Value = "valueUndefined")]ValueUndefined}
/// <summary>
/// Enum of possible property sources.
/// </summary>
internal enum AXValueSourceType
{
[System.Runtime.Serialization.EnumMember(Value = "attribute")]Attribute,
[System.Runtime.Serialization.EnumMember(Value = "implicit")]Implicit,
[System.Runtime.Serialization.EnumMember(Value = "style")]Style,
[System.Runtime.Serialization.EnumMember(Value = "contents")]Contents,
[System.Runtime.Serialization.EnumMember(Value = "placeholder")]Placeholder,
[System.Runtime.Serialization.EnumMember(Value = "relatedElement")]RelatedElement}
/// <summary>
/// Enum of possible native property sources (as a subtype of a particular AXValueSourceType).
/// </summary>
internal enum AXValueNativeSourceType
{
[System.Runtime.Serialization.EnumMember(Value = "figcaption")]Figcaption,
[System.Runtime.Serialization.EnumMember(Value = "label")]Label,
[System.Runtime.Serialization.EnumMember(Value = "labelfor")]Labelfor,
[System.Runtime.Serialization.EnumMember(Value = "labelwrapped")]Labelwrapped,
[System.Runtime.Serialization.EnumMember(Value = "legend")]Legend,
[System.Runtime.Serialization.EnumMember(Value = "tablecaption")]Tablecaption,
[System.Runtime.Serialization.EnumMember(Value = "title")]Title,
[System.Runtime.Serialization.EnumMember(Value = "other")]Other}
/// <summary>
/// A single source for a computed AX property.
/// </summary>
internal class AXValueSource
{
/// <summary>
/// What type of source this is.
/// </summary>
public AXValueSourceType Type { get; set; }
/// <summary>
/// The value of this property source.
/// </summary>
public AXValue Value { get; set; }
/// <summary>
/// The name of the relevant attribute, if any.
/// </summary>
public string Attribute { get; set; }
/// <summary>
/// The value of the relevant attribute, if any.
/// </summary>
public AXValue AttributeValue { get; set; }
/// <summary>
/// Whether this source is superseded by a higher priority source.
/// </summary>
public bool Superseded { get; set; }
/// <summary>
/// The native markup source for this value, e.g. a &lt;label&gt; element.
/// </summary>
public AXValueNativeSourceType NativeSource { get; set; }
/// <summary>
/// The value, such as a node or node list, of the native source.
/// </summary>
public AXValue NativeSourceValue { get; set; }
/// <summary>
/// Whether the value for this property is invalid.
/// </summary>
public bool Invalid { get; set; }
/// <summary>
/// Reason for the value being invalid, if it is.
/// </summary>
public string InvalidReason { get; set; }}
/// <summary>
/// 
/// </summary>
internal class AXRelatedNode
{
/// <summary>
/// The BackendNodeId of the related DOM node.
/// </summary>
public int BackendDOMNodeId { get; set; }
/// <summary>
/// The IDRef value provided, if any.
/// </summary>
public string Idref { get; set; }
/// <summary>
/// The text alternative of this node in the current context.
/// </summary>
public string Text { get; set; }}
/// <summary>
/// 
/// </summary>
internal class AXProperty
{
/// <summary>
/// The name of this property.
/// </summary>
public AXPropertyName Name { get; set; }
/// <summary>
/// The value of this property.
/// </summary>
public AXValue Value { get; set; }}
/// <summary>
/// A single computed AX property.
/// </summary>
internal class AXValue
{
/// <summary>
/// The type of this value.
/// </summary>
public AXValueType Type { get; set; }
/// <summary>
/// The computed value of this property.
/// </summary>
public JsonElement? Value { get; set; }
/// <summary>
/// One or more related nodes, if applicable.
/// </summary>
public AXRelatedNode[] RelatedNodes { get; set; }
/// <summary>
/// The sources which contributed to the computation of this property.
/// </summary>
public AXValueSource[] Sources { get; set; }}
/// <summary>
/// Values of AXProperty name:
/// - from 'busy' to 'roledescription': states which apply to every AX node
/// - from 'live' to 'root': attributes which apply to nodes in live regions
/// - from 'autocomplete' to 'valuetext': attributes which apply to widgets
/// - from 'checked' to 'selected': states which apply to widgets
/// - from 'activedescendant' to 'owns' - relationships between elements other than parent/child/sibling.
/// </summary>
internal enum AXPropertyName
{
[System.Runtime.Serialization.EnumMember(Value = "busy")]Busy,
[System.Runtime.Serialization.EnumMember(Value = "disabled")]Disabled,
[System.Runtime.Serialization.EnumMember(Value = "editable")]Editable,
[System.Runtime.Serialization.EnumMember(Value = "focusable")]Focusable,
[System.Runtime.Serialization.EnumMember(Value = "focused")]Focused,
[System.Runtime.Serialization.EnumMember(Value = "hidden")]Hidden,
[System.Runtime.Serialization.EnumMember(Value = "hiddenRoot")]HiddenRoot,
[System.Runtime.Serialization.EnumMember(Value = "invalid")]Invalid,
[System.Runtime.Serialization.EnumMember(Value = "keyshortcuts")]Keyshortcuts,
[System.Runtime.Serialization.EnumMember(Value = "settable")]Settable,
[System.Runtime.Serialization.EnumMember(Value = "roledescription")]Roledescription,
[System.Runtime.Serialization.EnumMember(Value = "live")]Live,
[System.Runtime.Serialization.EnumMember(Value = "atomic")]Atomic,
[System.Runtime.Serialization.EnumMember(Value = "relevant")]Relevant,
[System.Runtime.Serialization.EnumMember(Value = "root")]Root,
[System.Runtime.Serialization.EnumMember(Value = "autocomplete")]Autocomplete,
[System.Runtime.Serialization.EnumMember(Value = "hasPopup")]HasPopup,
[System.Runtime.Serialization.EnumMember(Value = "level")]Level,
[System.Runtime.Serialization.EnumMember(Value = "multiselectable")]Multiselectable,
[System.Runtime.Serialization.EnumMember(Value = "orientation")]Orientation,
[System.Runtime.Serialization.EnumMember(Value = "multiline")]Multiline,
[System.Runtime.Serialization.EnumMember(Value = "readonly")]Readonly,
[System.Runtime.Serialization.EnumMember(Value = "required")]Required,
[System.Runtime.Serialization.EnumMember(Value = "valuemin")]Valuemin,
[System.Runtime.Serialization.EnumMember(Value = "valuemax")]Valuemax,
[System.Runtime.Serialization.EnumMember(Value = "valuetext")]Valuetext,
[System.Runtime.Serialization.EnumMember(Value = "checked")]Checked,
[System.Runtime.Serialization.EnumMember(Value = "expanded")]Expanded,
[System.Runtime.Serialization.EnumMember(Value = "modal")]Modal,
[System.Runtime.Serialization.EnumMember(Value = "pressed")]Pressed,
[System.Runtime.Serialization.EnumMember(Value = "selected")]Selected,
[System.Runtime.Serialization.EnumMember(Value = "activedescendant")]Activedescendant,
[System.Runtime.Serialization.EnumMember(Value = "controls")]Controls,
[System.Runtime.Serialization.EnumMember(Value = "describedby")]Describedby,
[System.Runtime.Serialization.EnumMember(Value = "details")]Details,
[System.Runtime.Serialization.EnumMember(Value = "errormessage")]Errormessage,
[System.Runtime.Serialization.EnumMember(Value = "flowto")]Flowto,
[System.Runtime.Serialization.EnumMember(Value = "labelledby")]Labelledby,
[System.Runtime.Serialization.EnumMember(Value = "owns")]Owns}
/// <summary>
/// A node in the accessibility tree.
/// </summary>
internal class AXNode
{
/// <summary>
/// Unique identifier for this node.
/// </summary>
public string NodeId { get; set; }
/// <summary>
/// Whether this node is ignored for accessibility
/// </summary>
public bool Ignored { get; set; }
/// <summary>
/// Collection of reasons why this node is hidden.
/// </summary>
public AXProperty[] IgnoredReasons { get; set; }
/// <summary>
/// This `Node`'s role, whether explicit or implicit.
/// </summary>
public AXValue Role { get; set; }
/// <summary>
/// The accessible name for this `Node`.
/// </summary>
public AXValue Name { get; set; }
/// <summary>
/// The accessible description for this `Node`.
/// </summary>
public AXValue Description { get; set; }
/// <summary>
/// The value for this `Node`.
/// </summary>
public AXValue Value { get; set; }
/// <summary>
/// All other properties
/// </summary>
public AXProperty[] Properties { get; set; }
/// <summary>
/// IDs for each of this node's child nodes.
/// </summary>
public string[] ChildIds { get; set; }
/// <summary>
/// The backend ID for the associated DOM node, if any.
/// </summary>
public int BackendDOMNodeId { get; set; }}
/// <summary>
/// Disables the accessibility domain.
/// </summary>
/// <remarks>
/// Will send the command <c>Accessibility.disable</c>
/// </remarks>
internal class AccessibilityDisableRequest : IChromiumRequest<AccessibilityDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Accessibility.disable";
}
/// <summary>
/// Response from <see cref="AccessibilityDisableRequest"/>
/// </summary>
internal class AccessibilityDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
/// This turns on accessibility for the page, which can impact performance until accessibility is disabled.
/// </summary>
/// <remarks>
/// Will send the command <c>Accessibility.enable</c>
/// </remarks>
internal class AccessibilityEnableRequest : IChromiumRequest<AccessibilityEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Accessibility.enable";
}
/// <summary>
/// Response from <see cref="AccessibilityEnableRequest"/>
/// </summary>
internal class AccessibilityEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
/// </summary>
/// <remarks>
/// Will send the command <c>Accessibility.getPartialAXTree</c>
/// </remarks>
internal class AccessibilityGetPartialAXTreeRequest : IChromiumRequest<AccessibilityGetPartialAXTreeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Accessibility.getPartialAXTree";
/// <summary>
/// Identifier of the node to get the partial accessibility tree for.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Identifier of the backend node to get the partial accessibility tree for.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// JavaScript object id of the node wrapper to get the partial accessibility tree for.
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// Whether to fetch this nodes ancestors, siblings and children. Defaults to true.
/// </summary>
public bool FetchRelatives { get; set; }}
/// <summary>
/// Response from <see cref="AccessibilityGetPartialAXTreeRequest"/>
/// </summary>
internal class AccessibilityGetPartialAXTreeResponse : IChromiumResponse
{
/// <summary>
/// The `Accessibility.AXNode` for this DOM node, if it exists, plus its ancestors, siblings and
/// children, if requested.
/// </summary>
public AXNode[] Nodes { get; set; }}
/// <summary>
/// Fetches the entire accessibility tree
/// </summary>
/// <remarks>
/// Will send the command <c>Accessibility.getFullAXTree</c>
/// </remarks>
internal class AccessibilityGetFullAXTreeRequest : IChromiumRequest<AccessibilityGetFullAXTreeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Accessibility.getFullAXTree";
}
/// <summary>
/// Response from <see cref="AccessibilityGetFullAXTreeRequest"/>
/// </summary>
internal class AccessibilityGetFullAXTreeResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public AXNode[] Nodes { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Animation
{
/// <summary>
/// Animation instance.
/// </summary>
internal class Animation
{
/// <summary>
/// `Animation`'s id.
/// </summary>
public string Id { get; set; }
/// <summary>
/// `Animation`'s name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// `Animation`'s internal paused state.
/// </summary>
public bool PausedState { get; set; }
/// <summary>
/// `Animation`'s play state.
/// </summary>
public string PlayState { get; set; }
/// <summary>
/// `Animation`'s playback rate.
/// </summary>
public double PlaybackRate { get; set; }
/// <summary>
/// `Animation`'s start time.
/// </summary>
public double StartTime { get; set; }
/// <summary>
/// `Animation`'s current time.
/// </summary>
public double CurrentTime { get; set; }
/// <summary>
/// Animation type of `Animation`.
/// </summary>
public string Type { get; set; }
/// <summary>
/// `Animation`'s source animation node.
/// </summary>
public AnimationEffect Source { get; set; }
/// <summary>
/// A unique ID for `Animation` representing the sources that triggered this CSS
/// animation/transition.
/// </summary>
public string CssId { get; set; }}
/// <summary>
/// AnimationEffect instance
/// </summary>
internal class AnimationEffect
{
/// <summary>
/// `AnimationEffect`'s delay.
/// </summary>
public double Delay { get; set; }
/// <summary>
/// `AnimationEffect`'s end delay.
/// </summary>
public double EndDelay { get; set; }
/// <summary>
/// `AnimationEffect`'s iteration start.
/// </summary>
public double IterationStart { get; set; }
/// <summary>
/// `AnimationEffect`'s iterations.
/// </summary>
public double Iterations { get; set; }
/// <summary>
/// `AnimationEffect`'s iteration duration.
/// </summary>
public double Duration { get; set; }
/// <summary>
/// `AnimationEffect`'s playback direction.
/// </summary>
public string Direction { get; set; }
/// <summary>
/// `AnimationEffect`'s fill mode.
/// </summary>
public string Fill { get; set; }
/// <summary>
/// `AnimationEffect`'s target node.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// `AnimationEffect`'s keyframes.
/// </summary>
public KeyframesRule KeyframesRule { get; set; }
/// <summary>
/// `AnimationEffect`'s timing function.
/// </summary>
public string Easing { get; set; }}
/// <summary>
/// Keyframes Rule
/// </summary>
internal class KeyframesRule
{
/// <summary>
/// CSS keyframed animation's name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// List of animation keyframes.
/// </summary>
public KeyframeStyle[] Keyframes { get; set; }}
/// <summary>
/// Keyframe Style
/// </summary>
internal class KeyframeStyle
{
/// <summary>
/// Keyframe's time offset.
/// </summary>
public string Offset { get; set; }
/// <summary>
/// `AnimationEffect`'s timing function.
/// </summary>
public string Easing { get; set; }}
/// <summary>
/// Disables animation domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Animation.disable</c>
/// </remarks>
internal class AnimationDisableRequest : IChromiumRequest<AnimationDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Animation.disable";
}
/// <summary>
/// Response from <see cref="AnimationDisableRequest"/>
/// </summary>
internal class AnimationDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables animation domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Animation.enable</c>
/// </remarks>
internal class AnimationEnableRequest : IChromiumRequest<AnimationEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Animation.enable";
}
/// <summary>
/// Response from <see cref="AnimationEnableRequest"/>
/// </summary>
internal class AnimationEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Returns the current time of the an animation.
/// </summary>
/// <remarks>
/// Will send the command <c>Animation.getCurrentTime</c>
/// </remarks>
internal class AnimationGetCurrentTimeRequest : IChromiumRequest<AnimationGetCurrentTimeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Animation.getCurrentTime";
/// <summary>
/// Id of animation.
/// </summary>
public string Id { get; set; }}
/// <summary>
/// Response from <see cref="AnimationGetCurrentTimeRequest"/>
/// </summary>
internal class AnimationGetCurrentTimeResponse : IChromiumResponse
{
/// <summary>
/// Current time of the page.
/// </summary>
public double CurrentTime { get; set; }}
/// <summary>
/// Gets the playback rate of the document timeline.
/// </summary>
/// <remarks>
/// Will send the command <c>Animation.getPlaybackRate</c>
/// </remarks>
internal class AnimationGetPlaybackRateRequest : IChromiumRequest<AnimationGetPlaybackRateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Animation.getPlaybackRate";
}
/// <summary>
/// Response from <see cref="AnimationGetPlaybackRateRequest"/>
/// </summary>
internal class AnimationGetPlaybackRateResponse : IChromiumResponse
{
/// <summary>
/// Playback rate for animations on page.
/// </summary>
public double PlaybackRate { get; set; }}
/// <summary>
/// Releases a set of animations to no longer be manipulated.
/// </summary>
/// <remarks>
/// Will send the command <c>Animation.releaseAnimations</c>
/// </remarks>
internal class AnimationReleaseAnimationsRequest : IChromiumRequest<AnimationReleaseAnimationsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Animation.releaseAnimations";
/// <summary>
/// List of animation ids to seek.
/// </summary>
public string[] Animations { get; set; }}
/// <summary>
/// Response from <see cref="AnimationReleaseAnimationsRequest"/>
/// </summary>
internal class AnimationReleaseAnimationsResponse : IChromiumResponse
{
}
/// <summary>
/// Gets the remote object of the Animation.
/// </summary>
/// <remarks>
/// Will send the command <c>Animation.resolveAnimation</c>
/// </remarks>
internal class AnimationResolveAnimationRequest : IChromiumRequest<AnimationResolveAnimationResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Animation.resolveAnimation";
/// <summary>
/// Animation id.
/// </summary>
public string AnimationId { get; set; }}
/// <summary>
/// Response from <see cref="AnimationResolveAnimationRequest"/>
/// </summary>
internal class AnimationResolveAnimationResponse : IChromiumResponse
{
/// <summary>
/// Corresponding remote object.
/// </summary>
public Runtime.RemoteObject RemoteObject { get; set; }}
/// <summary>
/// Seek a set of animations to a particular time within each animation.
/// </summary>
/// <remarks>
/// Will send the command <c>Animation.seekAnimations</c>
/// </remarks>
internal class AnimationSeekAnimationsRequest : IChromiumRequest<AnimationSeekAnimationsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Animation.seekAnimations";
/// <summary>
/// List of animation ids to seek.
/// </summary>
public string[] Animations { get; set; }
/// <summary>
/// Set the current time of each animation.
/// </summary>
public double CurrentTime { get; set; }}
/// <summary>
/// Response from <see cref="AnimationSeekAnimationsRequest"/>
/// </summary>
internal class AnimationSeekAnimationsResponse : IChromiumResponse
{
}
/// <summary>
/// Sets the paused state of a set of animations.
/// </summary>
/// <remarks>
/// Will send the command <c>Animation.setPaused</c>
/// </remarks>
internal class AnimationSetPausedRequest : IChromiumRequest<AnimationSetPausedResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Animation.setPaused";
/// <summary>
/// Animations to set the pause state of.
/// </summary>
public string[] Animations { get; set; }
/// <summary>
/// Paused state to set to.
/// </summary>
public bool Paused { get; set; }}
/// <summary>
/// Response from <see cref="AnimationSetPausedRequest"/>
/// </summary>
internal class AnimationSetPausedResponse : IChromiumResponse
{
}
/// <summary>
/// Sets the playback rate of the document timeline.
/// </summary>
/// <remarks>
/// Will send the command <c>Animation.setPlaybackRate</c>
/// </remarks>
internal class AnimationSetPlaybackRateRequest : IChromiumRequest<AnimationSetPlaybackRateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Animation.setPlaybackRate";
/// <summary>
/// Playback rate for animations on page
/// </summary>
public double PlaybackRate { get; set; }}
/// <summary>
/// Response from <see cref="AnimationSetPlaybackRateRequest"/>
/// </summary>
internal class AnimationSetPlaybackRateResponse : IChromiumResponse
{
}
/// <summary>
/// Sets the timing of an animation node.
/// </summary>
/// <remarks>
/// Will send the command <c>Animation.setTiming</c>
/// </remarks>
internal class AnimationSetTimingRequest : IChromiumRequest<AnimationSetTimingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Animation.setTiming";
/// <summary>
/// Animation id.
/// </summary>
public string AnimationId { get; set; }
/// <summary>
/// Duration of the animation.
/// </summary>
public double Duration { get; set; }
/// <summary>
/// Delay of the animation.
/// </summary>
public double Delay { get; set; }}
/// <summary>
/// Response from <see cref="AnimationSetTimingRequest"/>
/// </summary>
internal class AnimationSetTimingResponse : IChromiumResponse
{
}
/// <summary>
/// Event for when an animation has been cancelled.
/// </summary>
/// <remarks>
/// Matches on the event <c>Animation.animationCanceled</c>
/// </remarks>
internal class AnimationAnimationCanceledChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Animation.animationCanceled";
/// <summary>
/// Id of the animation that was cancelled.
/// </summary>
public string Id { get; set; }}
/// <summary>
/// Event for each animation that has been created.
/// </summary>
/// <remarks>
/// Matches on the event <c>Animation.animationCreated</c>
/// </remarks>
internal class AnimationAnimationCreatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Animation.animationCreated";
/// <summary>
/// Id of the animation that was created.
/// </summary>
public string Id { get; set; }}
/// <summary>
/// Event for animation that has been started.
/// </summary>
/// <remarks>
/// Matches on the event <c>Animation.animationStarted</c>
/// </remarks>
internal class AnimationAnimationStartedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Animation.animationStarted";
/// <summary>
/// Animation that was started.
/// </summary>
public Animation Animation { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.ApplicationCache
{
/// <summary>
/// Detailed application cache resource information.
/// </summary>
internal class ApplicationCacheResource
{
/// <summary>
/// Resource url.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Resource size.
/// </summary>
public int Size { get; set; }
/// <summary>
/// Resource type.
/// </summary>
public string Type { get; set; }}
/// <summary>
/// Detailed application cache information.
/// </summary>
internal class ApplicationCache
{
/// <summary>
/// Manifest URL.
/// </summary>
public string ManifestURL { get; set; }
/// <summary>
/// Application cache size.
/// </summary>
public double Size { get; set; }
/// <summary>
/// Application cache creation time.
/// </summary>
public double CreationTime { get; set; }
/// <summary>
/// Application cache update time.
/// </summary>
public double UpdateTime { get; set; }
/// <summary>
/// Application cache resources.
/// </summary>
public ApplicationCacheResource[] Resources { get; set; }}
/// <summary>
/// Frame identifier - manifest URL pair.
/// </summary>
internal class FrameWithManifest
{
/// <summary>
/// Frame identifier.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Manifest URL.
/// </summary>
public string ManifestURL { get; set; }
/// <summary>
/// Application cache status.
/// </summary>
public int Status { get; set; }}
/// <summary>
/// Enables application cache domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>ApplicationCache.enable</c>
/// </remarks>
internal class ApplicationCacheEnableRequest : IChromiumRequest<ApplicationCacheEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ApplicationCache.enable";
}
/// <summary>
/// Response from <see cref="ApplicationCacheEnableRequest"/>
/// </summary>
internal class ApplicationCacheEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Returns relevant application cache data for the document in given frame.
/// </summary>
/// <remarks>
/// Will send the command <c>ApplicationCache.getApplicationCacheForFrame</c>
/// </remarks>
internal class ApplicationCacheGetApplicationCacheForFrameRequest : IChromiumRequest<ApplicationCacheGetApplicationCacheForFrameResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ApplicationCache.getApplicationCacheForFrame";
/// <summary>
/// Identifier of the frame containing document whose application cache is retrieved.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Response from <see cref="ApplicationCacheGetApplicationCacheForFrameRequest"/>
/// </summary>
internal class ApplicationCacheGetApplicationCacheForFrameResponse : IChromiumResponse
{
/// <summary>
/// Relevant application cache data for the document in given frame.
/// </summary>
public ApplicationCache ApplicationCache { get; set; }}
/// <summary>
/// Returns array of frame identifiers with manifest urls for each frame containing a document
/// associated with some application cache.
/// </summary>
/// <remarks>
/// Will send the command <c>ApplicationCache.getFramesWithManifests</c>
/// </remarks>
internal class ApplicationCacheGetFramesWithManifestsRequest : IChromiumRequest<ApplicationCacheGetFramesWithManifestsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ApplicationCache.getFramesWithManifests";
}
/// <summary>
/// Response from <see cref="ApplicationCacheGetFramesWithManifestsRequest"/>
/// </summary>
internal class ApplicationCacheGetFramesWithManifestsResponse : IChromiumResponse
{
/// <summary>
/// Array of frame identifiers with manifest urls for each frame containing a document
/// associated with some application cache.
/// </summary>
public FrameWithManifest[] FrameIds { get; set; }}
/// <summary>
/// Returns manifest URL for document in the given frame.
/// </summary>
/// <remarks>
/// Will send the command <c>ApplicationCache.getManifestForFrame</c>
/// </remarks>
internal class ApplicationCacheGetManifestForFrameRequest : IChromiumRequest<ApplicationCacheGetManifestForFrameResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ApplicationCache.getManifestForFrame";
/// <summary>
/// Identifier of the frame containing document whose manifest is retrieved.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Response from <see cref="ApplicationCacheGetManifestForFrameRequest"/>
/// </summary>
internal class ApplicationCacheGetManifestForFrameResponse : IChromiumResponse
{
/// <summary>
/// Manifest URL for document in the given frame.
/// </summary>
public string ManifestURL { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>ApplicationCache.applicationCacheStatusUpdated</c>
/// </remarks>
internal class ApplicationCacheApplicationCacheStatusUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "ApplicationCache.applicationCacheStatusUpdated";
/// <summary>
/// Identifier of the frame containing document whose application cache updated status.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Manifest URL.
/// </summary>
public string ManifestURL { get; set; }
/// <summary>
/// Updated application cache status.
/// </summary>
public int Status { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>ApplicationCache.networkStateUpdated</c>
/// </remarks>
internal class ApplicationCacheNetworkStateUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "ApplicationCache.networkStateUpdated";
/// <summary>
/// 
/// </summary>
public bool IsNowOnline { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Audits
{
/// <summary>
/// Returns the response body and size if it were re-encoded with the specified settings. Only
/// applies to images.
/// </summary>
/// <remarks>
/// Will send the command <c>Audits.getEncodedResponse</c>
/// </remarks>
internal class AuditsGetEncodedResponseRequest : IChromiumRequest<AuditsGetEncodedResponseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Audits.getEncodedResponse";
/// <summary>
/// Identifier of the network request to get content for.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// The encoding to use.
/// </summary>
public string Encoding { get; set; }
/// <summary>
/// The quality of the encoding (0-1). (defaults to 1)
/// </summary>
public double Quality { get; set; }
/// <summary>
/// Whether to only return the size information (defaults to false).
/// </summary>
public bool SizeOnly { get; set; }}
/// <summary>
/// Response from <see cref="AuditsGetEncodedResponseRequest"/>
/// </summary>
internal class AuditsGetEncodedResponseResponse : IChromiumResponse
{
/// <summary>
/// The encoded body as a base64 string. Omitted if sizeOnly is true.
/// </summary>
public byte[] Body { get; set; }
/// <summary>
/// Size before re-encoding.
/// </summary>
public int OriginalSize { get; set; }
/// <summary>
/// Size after re-encoding.
/// </summary>
public int EncodedSize { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.BackgroundService
{
/// <summary>
/// The Background Service that will be associated with the commands/events.
/// Every Background Service operates independently, but they share the same
/// API.
/// </summary>
internal enum ServiceName
{
[System.Runtime.Serialization.EnumMember(Value = "backgroundFetch")]BackgroundFetch,
[System.Runtime.Serialization.EnumMember(Value = "backgroundSync")]BackgroundSync,
[System.Runtime.Serialization.EnumMember(Value = "pushMessaging")]PushMessaging,
[System.Runtime.Serialization.EnumMember(Value = "notifications")]Notifications,
[System.Runtime.Serialization.EnumMember(Value = "paymentHandler")]PaymentHandler,
[System.Runtime.Serialization.EnumMember(Value = "periodicBackgroundSync")]PeriodicBackgroundSync}
/// <summary>
/// A key-value pair for additional event information to pass along.
/// </summary>
internal class EventMetadata
{
/// <summary>
/// 
/// </summary>
public string Key { get; set; }
/// <summary>
/// 
/// </summary>
public string Value { get; set; }}
/// <summary>
/// 
/// </summary>
internal class BackgroundServiceEvent
{
/// <summary>
/// Timestamp of the event (in seconds).
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// The origin this event belongs to.
/// </summary>
public string Origin { get; set; }
/// <summary>
/// The Service Worker ID that initiated the event.
/// </summary>
public string ServiceWorkerRegistrationId { get; set; }
/// <summary>
/// The Background Service this event belongs to.
/// </summary>
public ServiceName Service { get; set; }
/// <summary>
/// A description of the event.
/// </summary>
public string EventName { get; set; }
/// <summary>
/// An identifier that groups related events together.
/// </summary>
public string InstanceId { get; set; }
/// <summary>
/// A list of event-specific information.
/// </summary>
public EventMetadata[] EventMetadata { get; set; }}
/// <summary>
/// Enables event updates for the service.
/// </summary>
/// <remarks>
/// Will send the command <c>BackgroundService.startObserving</c>
/// </remarks>
internal class BackgroundServiceStartObservingRequest : IChromiumRequest<BackgroundServiceStartObservingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "BackgroundService.startObserving";
/// <summary>
/// 
/// </summary>
public ServiceName Service { get; set; }}
/// <summary>
/// Response from <see cref="BackgroundServiceStartObservingRequest"/>
/// </summary>
internal class BackgroundServiceStartObservingResponse : IChromiumResponse
{
}
/// <summary>
/// Disables event updates for the service.
/// </summary>
/// <remarks>
/// Will send the command <c>BackgroundService.stopObserving</c>
/// </remarks>
internal class BackgroundServiceStopObservingRequest : IChromiumRequest<BackgroundServiceStopObservingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "BackgroundService.stopObserving";
/// <summary>
/// 
/// </summary>
public ServiceName Service { get; set; }}
/// <summary>
/// Response from <see cref="BackgroundServiceStopObservingRequest"/>
/// </summary>
internal class BackgroundServiceStopObservingResponse : IChromiumResponse
{
}
/// <summary>
/// Set the recording state for the service.
/// </summary>
/// <remarks>
/// Will send the command <c>BackgroundService.setRecording</c>
/// </remarks>
internal class BackgroundServiceSetRecordingRequest : IChromiumRequest<BackgroundServiceSetRecordingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "BackgroundService.setRecording";
/// <summary>
/// 
/// </summary>
public bool ShouldRecord { get; set; }
/// <summary>
/// 
/// </summary>
public ServiceName Service { get; set; }}
/// <summary>
/// Response from <see cref="BackgroundServiceSetRecordingRequest"/>
/// </summary>
internal class BackgroundServiceSetRecordingResponse : IChromiumResponse
{
}
/// <summary>
/// Clears all stored data for the service.
/// </summary>
/// <remarks>
/// Will send the command <c>BackgroundService.clearEvents</c>
/// </remarks>
internal class BackgroundServiceClearEventsRequest : IChromiumRequest<BackgroundServiceClearEventsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "BackgroundService.clearEvents";
/// <summary>
/// 
/// </summary>
public ServiceName Service { get; set; }}
/// <summary>
/// Response from <see cref="BackgroundServiceClearEventsRequest"/>
/// </summary>
internal class BackgroundServiceClearEventsResponse : IChromiumResponse
{
}
/// <summary>
/// Called when the recording state for the service has been updated.
/// </summary>
/// <remarks>
/// Matches on the event <c>BackgroundService.recordingStateChanged</c>
/// </remarks>
internal class BackgroundServiceRecordingStateChangedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "BackgroundService.recordingStateChanged";
/// <summary>
/// 
/// </summary>
public bool IsRecording { get; set; }
/// <summary>
/// 
/// </summary>
public ServiceName Service { get; set; }}
/// <summary>
/// Called with all existing backgroundServiceEvents when enabled, and all new
/// events afterwards if enabled and recording.
/// </summary>
/// <remarks>
/// Matches on the event <c>BackgroundService.backgroundServiceEventReceived</c>
/// </remarks>
internal class BackgroundServiceBackgroundServiceEventReceivedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "BackgroundService.backgroundServiceEventReceived";
/// <summary>
/// 
/// </summary>
public BackgroundServiceEvent BackgroundServiceEvent { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Browser
{
/// <summary>
/// The state of the browser window.
/// </summary>
internal enum WindowState
{
[System.Runtime.Serialization.EnumMember(Value = "normal")]Normal,
[System.Runtime.Serialization.EnumMember(Value = "minimized")]Minimized,
[System.Runtime.Serialization.EnumMember(Value = "maximized")]Maximized,
[System.Runtime.Serialization.EnumMember(Value = "fullscreen")]Fullscreen}
/// <summary>
/// Browser window bounds information
/// </summary>
internal class Bounds
{
/// <summary>
/// The offset from the left edge of the screen to the window in pixels.
/// </summary>
public int Left { get; set; }
/// <summary>
/// The offset from the top edge of the screen to the window in pixels.
/// </summary>
public int Top { get; set; }
/// <summary>
/// The window width in pixels.
/// </summary>
public int Width { get; set; }
/// <summary>
/// The window height in pixels.
/// </summary>
public int Height { get; set; }
/// <summary>
/// The window state. Default to normal.
/// </summary>
public WindowState WindowState { get; set; }}
/// <summary>
/// 
/// </summary>
internal enum PermissionType
{
[System.Runtime.Serialization.EnumMember(Value = "accessibilityEvents")]AccessibilityEvents,
[System.Runtime.Serialization.EnumMember(Value = "audioCapture")]AudioCapture,
[System.Runtime.Serialization.EnumMember(Value = "backgroundSync")]BackgroundSync,
[System.Runtime.Serialization.EnumMember(Value = "backgroundFetch")]BackgroundFetch,
[System.Runtime.Serialization.EnumMember(Value = "clipboardReadWrite")]ClipboardReadWrite,
[System.Runtime.Serialization.EnumMember(Value = "clipboardSanitizedWrite")]ClipboardSanitizedWrite,
[System.Runtime.Serialization.EnumMember(Value = "durableStorage")]DurableStorage,
[System.Runtime.Serialization.EnumMember(Value = "flash")]Flash,
[System.Runtime.Serialization.EnumMember(Value = "geolocation")]Geolocation,
[System.Runtime.Serialization.EnumMember(Value = "midi")]Midi,
[System.Runtime.Serialization.EnumMember(Value = "midiSysex")]MidiSysex,
[System.Runtime.Serialization.EnumMember(Value = "nfc")]Nfc,
[System.Runtime.Serialization.EnumMember(Value = "notifications")]Notifications,
[System.Runtime.Serialization.EnumMember(Value = "paymentHandler")]PaymentHandler,
[System.Runtime.Serialization.EnumMember(Value = "periodicBackgroundSync")]PeriodicBackgroundSync,
[System.Runtime.Serialization.EnumMember(Value = "protectedMediaIdentifier")]ProtectedMediaIdentifier,
[System.Runtime.Serialization.EnumMember(Value = "sensors")]Sensors,
[System.Runtime.Serialization.EnumMember(Value = "videoCapture")]VideoCapture,
[System.Runtime.Serialization.EnumMember(Value = "idleDetection")]IdleDetection,
[System.Runtime.Serialization.EnumMember(Value = "wakeLockScreen")]WakeLockScreen,
[System.Runtime.Serialization.EnumMember(Value = "wakeLockSystem")]WakeLockSystem}
/// <summary>
/// 
/// </summary>
internal enum PermissionSetting
{
[System.Runtime.Serialization.EnumMember(Value = "granted")]Granted,
[System.Runtime.Serialization.EnumMember(Value = "denied")]Denied,
[System.Runtime.Serialization.EnumMember(Value = "prompt")]Prompt}
/// <summary>
/// Definition of PermissionDescriptor defined in the Permissions API:
/// https://w3c.github.io/permissions/#dictdef-permissiondescriptor.
/// </summary>
internal class PermissionDescriptor
{
/// <summary>
/// Name of permission.
/// See https://cs.chromium.org/chromium/src/third_party/blink/renderer/modules/permissions/permission_descriptor.idl for valid permission names.
/// </summary>
public string Name { get; set; }
/// <summary>
/// For "midi" permission, may also specify sysex control.
/// </summary>
public bool Sysex { get; set; }
/// <summary>
/// For "push" permission, may specify userVisibleOnly.
/// Note that userVisibleOnly = true is the only currently supported type.
/// </summary>
public bool UserVisibleOnly { get; set; }
/// <summary>
/// For "wake-lock" permission, must specify type as either "screen" or "system".
/// </summary>
public string Type { get; set; }
/// <summary>
/// For "clipboard" permission, may specify allowWithoutSanitization.
/// </summary>
public bool AllowWithoutSanitization { get; set; }}
/// <summary>
/// Chrome histogram bucket.
/// </summary>
internal class Bucket
{
/// <summary>
/// Minimum value (inclusive).
/// </summary>
public int Low { get; set; }
/// <summary>
/// Maximum value (exclusive).
/// </summary>
public int High { get; set; }
/// <summary>
/// Number of samples.
/// </summary>
public int Count { get; set; }}
/// <summary>
/// Chrome histogram.
/// </summary>
internal class Histogram
{
/// <summary>
/// Name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Sum of sample values.
/// </summary>
public int Sum { get; set; }
/// <summary>
/// Total number of samples.
/// </summary>
public int Count { get; set; }
/// <summary>
/// Buckets.
/// </summary>
public Bucket[] Buckets { get; set; }}
/// <summary>
/// Set permission settings for given origin.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.setPermission</c>
/// </remarks>
internal class BrowserSetPermissionRequest : IChromiumRequest<BrowserSetPermissionResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.setPermission";
/// <summary>
/// Origin the permission applies to.
/// </summary>
public string Origin { get; set; }
/// <summary>
/// Descriptor of permission to override.
/// </summary>
public PermissionDescriptor Permission { get; set; }
/// <summary>
/// Setting of the permission.
/// </summary>
public PermissionSetting Setting { get; set; }
/// <summary>
/// Context to override. When omitted, default browser context is used.
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// Response from <see cref="BrowserSetPermissionRequest"/>
/// </summary>
internal class BrowserSetPermissionResponse : IChromiumResponse
{
}
/// <summary>
/// Grant specific permissions to the given origin and reject all others.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.grantPermissions</c>
/// </remarks>
internal class BrowserGrantPermissionsRequest : IChromiumRequest<BrowserGrantPermissionsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.grantPermissions";
/// <summary>
/// 
/// </summary>
public string Origin { get; set; }
/// <summary>
/// 
/// </summary>
public PermissionType[] Permissions { get; set; }
/// <summary>
/// BrowserContext to override permissions. When omitted, default browser context is used.
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// Response from <see cref="BrowserGrantPermissionsRequest"/>
/// </summary>
internal class BrowserGrantPermissionsResponse : IChromiumResponse
{
}
/// <summary>
/// Reset all permission management for all origins.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.resetPermissions</c>
/// </remarks>
internal class BrowserResetPermissionsRequest : IChromiumRequest<BrowserResetPermissionsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.resetPermissions";
/// <summary>
/// BrowserContext to reset permissions. When omitted, default browser context is used.
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// Response from <see cref="BrowserResetPermissionsRequest"/>
/// </summary>
internal class BrowserResetPermissionsResponse : IChromiumResponse
{
}
/// <summary>
/// Close browser gracefully.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.close</c>
/// </remarks>
internal class BrowserCloseRequest : IChromiumRequest<BrowserCloseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.close";
}
/// <summary>
/// Response from <see cref="BrowserCloseRequest"/>
/// </summary>
internal class BrowserCloseResponse : IChromiumResponse
{
}
/// <summary>
/// Crashes browser on the main thread.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.crash</c>
/// </remarks>
internal class BrowserCrashRequest : IChromiumRequest<BrowserCrashResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.crash";
}
/// <summary>
/// Response from <see cref="BrowserCrashRequest"/>
/// </summary>
internal class BrowserCrashResponse : IChromiumResponse
{
}
/// <summary>
/// Crashes GPU process.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.crashGpuProcess</c>
/// </remarks>
internal class BrowserCrashGpuProcessRequest : IChromiumRequest<BrowserCrashGpuProcessResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.crashGpuProcess";
}
/// <summary>
/// Response from <see cref="BrowserCrashGpuProcessRequest"/>
/// </summary>
internal class BrowserCrashGpuProcessResponse : IChromiumResponse
{
}
/// <summary>
/// Returns version information.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.getVersion</c>
/// </remarks>
internal class BrowserGetVersionRequest : IChromiumRequest<BrowserGetVersionResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.getVersion";
}
/// <summary>
/// Response from <see cref="BrowserGetVersionRequest"/>
/// </summary>
internal class BrowserGetVersionResponse : IChromiumResponse
{
/// <summary>
/// Protocol version.
/// </summary>
public string ProtocolVersion { get; set; }
/// <summary>
/// Product name.
/// </summary>
public string Product { get; set; }
/// <summary>
/// Product revision.
/// </summary>
public string Revision { get; set; }
/// <summary>
/// User-Agent.
/// </summary>
public string UserAgent { get; set; }
/// <summary>
/// V8 version.
/// </summary>
public string JsVersion { get; set; }}
/// <summary>
/// Returns the command line switches for the browser process if, and only if
/// --enable-automation is on the commandline.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.getBrowserCommandLine</c>
/// </remarks>
internal class BrowserGetBrowserCommandLineRequest : IChromiumRequest<BrowserGetBrowserCommandLineResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.getBrowserCommandLine";
}
/// <summary>
/// Response from <see cref="BrowserGetBrowserCommandLineRequest"/>
/// </summary>
internal class BrowserGetBrowserCommandLineResponse : IChromiumResponse
{
/// <summary>
/// Commandline parameters
/// </summary>
public string[] Arguments { get; set; }}
/// <summary>
/// Get Chrome histograms.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.getHistograms</c>
/// </remarks>
internal class BrowserGetHistogramsRequest : IChromiumRequest<BrowserGetHistogramsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.getHistograms";
/// <summary>
/// Requested substring in name. Only histograms which have query as a
/// substring in their name are extracted. An empty or absent query returns
/// all histograms.
/// </summary>
public string Query { get; set; }
/// <summary>
/// If true, retrieve delta since last call.
/// </summary>
public bool Delta { get; set; }}
/// <summary>
/// Response from <see cref="BrowserGetHistogramsRequest"/>
/// </summary>
internal class BrowserGetHistogramsResponse : IChromiumResponse
{
/// <summary>
/// Histograms.
/// </summary>
public Histogram[] Histograms { get; set; }}
/// <summary>
/// Get a Chrome histogram by name.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.getHistogram</c>
/// </remarks>
internal class BrowserGetHistogramRequest : IChromiumRequest<BrowserGetHistogramResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.getHistogram";
/// <summary>
/// Requested histogram name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// If true, retrieve delta since last call.
/// </summary>
public bool Delta { get; set; }}
/// <summary>
/// Response from <see cref="BrowserGetHistogramRequest"/>
/// </summary>
internal class BrowserGetHistogramResponse : IChromiumResponse
{
/// <summary>
/// Histogram.
/// </summary>
public Histogram Histogram { get; set; }}
/// <summary>
/// Get position and size of the browser window.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.getWindowBounds</c>
/// </remarks>
internal class BrowserGetWindowBoundsRequest : IChromiumRequest<BrowserGetWindowBoundsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.getWindowBounds";
/// <summary>
/// Browser window id.
/// </summary>
public int WindowId { get; set; }}
/// <summary>
/// Response from <see cref="BrowserGetWindowBoundsRequest"/>
/// </summary>
internal class BrowserGetWindowBoundsResponse : IChromiumResponse
{
/// <summary>
/// Bounds information of the window. When window state is 'minimized', the restored window
/// position and size are returned.
/// </summary>
public Bounds Bounds { get; set; }}
/// <summary>
/// Get the browser window that contains the devtools target.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.getWindowForTarget</c>
/// </remarks>
internal class BrowserGetWindowForTargetRequest : IChromiumRequest<BrowserGetWindowForTargetResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.getWindowForTarget";
/// <summary>
/// Devtools agent host id. If called as a part of the session, associated targetId is used.
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// Response from <see cref="BrowserGetWindowForTargetRequest"/>
/// </summary>
internal class BrowserGetWindowForTargetResponse : IChromiumResponse
{
/// <summary>
/// Browser window id.
/// </summary>
public int WindowId { get; set; }
/// <summary>
/// Bounds information of the window. When window state is 'minimized', the restored window
/// position and size are returned.
/// </summary>
public Bounds Bounds { get; set; }}
/// <summary>
/// Set position and/or size of the browser window.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.setWindowBounds</c>
/// </remarks>
internal class BrowserSetWindowBoundsRequest : IChromiumRequest<BrowserSetWindowBoundsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.setWindowBounds";
/// <summary>
/// Browser window id.
/// </summary>
public int WindowId { get; set; }
/// <summary>
/// New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combined
/// with 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged.
/// </summary>
public Bounds Bounds { get; set; }}
/// <summary>
/// Response from <see cref="BrowserSetWindowBoundsRequest"/>
/// </summary>
internal class BrowserSetWindowBoundsResponse : IChromiumResponse
{
}
/// <summary>
/// Set dock tile details, platform-specific.
/// </summary>
/// <remarks>
/// Will send the command <c>Browser.setDockTile</c>
/// </remarks>
internal class BrowserSetDockTileRequest : IChromiumRequest<BrowserSetDockTileResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Browser.setDockTile";
/// <summary>
/// 
/// </summary>
public string BadgeLabel { get; set; }
/// <summary>
/// Png encoded image.
/// </summary>
public byte[] Image { get; set; }}
/// <summary>
/// Response from <see cref="BrowserSetDockTileRequest"/>
/// </summary>
internal class BrowserSetDockTileResponse : IChromiumResponse
{
}
}
namespace PlaywrightSharp.Chromium.Protocol.CSS
{
/// <summary>
/// Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent
/// stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via
/// inspector" rules), "regular" for regular stylesheets.
/// </summary>
internal enum StyleSheetOrigin
{
[System.Runtime.Serialization.EnumMember(Value = "injected")]Injected,
[System.Runtime.Serialization.EnumMember(Value = "user-agent")]UserAgent,
[System.Runtime.Serialization.EnumMember(Value = "inspector")]Inspector,
[System.Runtime.Serialization.EnumMember(Value = "regular")]Regular}
/// <summary>
/// CSS rule collection for a single pseudo style.
/// </summary>
internal class PseudoElementMatches
{
/// <summary>
/// Pseudo element type.
/// </summary>
public DOM.PseudoType PseudoType { get; set; }
/// <summary>
/// Matches of CSS rules applicable to the pseudo style.
/// </summary>
public RuleMatch[] Matches { get; set; }}
/// <summary>
/// Inherited CSS rule collection from ancestor node.
/// </summary>
internal class InheritedStyleEntry
{
/// <summary>
/// The ancestor node's inline style, if any, in the style inheritance chain.
/// </summary>
public CSSStyle InlineStyle { get; set; }
/// <summary>
/// Matches of CSS rules matching the ancestor node in the style inheritance chain.
/// </summary>
public RuleMatch[] MatchedCSSRules { get; set; }}
/// <summary>
/// Match data for a CSS rule.
/// </summary>
internal class RuleMatch
{
/// <summary>
/// CSS rule in the match.
/// </summary>
public CSSRule Rule { get; set; }
/// <summary>
/// Matching selector indices in the rule's selectorList selectors (0-based).
/// </summary>
public int[] MatchingSelectors { get; set; }}
/// <summary>
/// Data for a simple selector (these are delimited by commas in a selector list).
/// </summary>
internal class Value
{
/// <summary>
/// Value text.
/// </summary>
public string Text { get; set; }
/// <summary>
/// Value range in the underlying resource (if available).
/// </summary>
public SourceRange Range { get; set; }}
/// <summary>
/// Selector list data.
/// </summary>
internal class SelectorList
{
/// <summary>
/// Selectors in the list.
/// </summary>
public Value[] Selectors { get; set; }
/// <summary>
/// Rule selector text.
/// </summary>
public string Text { get; set; }}
/// <summary>
/// CSS stylesheet metainformation.
/// </summary>
internal class CSSStyleSheetHeader
{
/// <summary>
/// The stylesheet identifier.
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// Owner frame identifier.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Stylesheet resource URL.
/// </summary>
public string SourceURL { get; set; }
/// <summary>
/// URL of source map associated with the stylesheet (if any).
/// </summary>
public string SourceMapURL { get; set; }
/// <summary>
/// Stylesheet origin.
/// </summary>
public StyleSheetOrigin Origin { get; set; }
/// <summary>
/// Stylesheet title.
/// </summary>
public string Title { get; set; }
/// <summary>
/// The backend id for the owner node of the stylesheet.
/// </summary>
public int OwnerNode { get; set; }
/// <summary>
/// Denotes whether the stylesheet is disabled.
/// </summary>
public bool Disabled { get; set; }
/// <summary>
/// Whether the sourceURL field value comes from the sourceURL comment.
/// </summary>
public bool HasSourceURL { get; set; }
/// <summary>
/// Whether this stylesheet is created for STYLE tag by parser. This flag is not set for
/// document.written STYLE tags.
/// </summary>
public bool IsInline { get; set; }
/// <summary>
/// Line offset of the stylesheet within the resource (zero based).
/// </summary>
public double StartLine { get; set; }
/// <summary>
/// Column offset of the stylesheet within the resource (zero based).
/// </summary>
public double StartColumn { get; set; }
/// <summary>
/// Size of the content (in characters).
/// </summary>
public double Length { get; set; }
/// <summary>
/// Line offset of the end of the stylesheet within the resource (zero based).
/// </summary>
public double EndLine { get; set; }
/// <summary>
/// Column offset of the end of the stylesheet within the resource (zero based).
/// </summary>
public double EndColumn { get; set; }}
/// <summary>
/// CSS rule representation.
/// </summary>
internal class CSSRule
{
/// <summary>
/// The css style sheet identifier (absent for user agent stylesheet and user-specified
/// stylesheet rules) this rule came from.
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// Rule selector data.
/// </summary>
public SelectorList SelectorList { get; set; }
/// <summary>
/// Parent stylesheet's origin.
/// </summary>
public StyleSheetOrigin Origin { get; set; }
/// <summary>
/// Associated style declaration.
/// </summary>
public CSSStyle Style { get; set; }
/// <summary>
/// Media list array (for rules involving media queries). The array enumerates media queries
/// starting with the innermost one, going outwards.
/// </summary>
public CSSMedia[] Media { get; set; }}
/// <summary>
/// CSS coverage information.
/// </summary>
internal class RuleUsage
{
/// <summary>
/// The css style sheet identifier (absent for user agent stylesheet and user-specified
/// stylesheet rules) this rule came from.
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// Offset of the start of the rule (including selector) from the beginning of the stylesheet.
/// </summary>
public double StartOffset { get; set; }
/// <summary>
/// Offset of the end of the rule body from the beginning of the stylesheet.
/// </summary>
public double EndOffset { get; set; }
/// <summary>
/// Indicates whether the rule was actually used by some element in the page.
/// </summary>
public bool Used { get; set; }}
/// <summary>
/// Text range within a resource. All numbers are zero-based.
/// </summary>
internal class SourceRange
{
/// <summary>
/// Start line of range.
/// </summary>
public int StartLine { get; set; }
/// <summary>
/// Start column of range (inclusive).
/// </summary>
public int StartColumn { get; set; }
/// <summary>
/// End line of range
/// </summary>
public int EndLine { get; set; }
/// <summary>
/// End column of range (exclusive).
/// </summary>
public int EndColumn { get; set; }}
/// <summary>
/// 
/// </summary>
internal class ShorthandEntry
{
/// <summary>
/// Shorthand name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Shorthand value.
/// </summary>
public string Value { get; set; }
/// <summary>
/// Whether the property has "!important" annotation (implies `false` if absent).
/// </summary>
public bool Important { get; set; }}
/// <summary>
/// 
/// </summary>
internal class CSSComputedStyleProperty
{
/// <summary>
/// Computed style property name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Computed style property value.
/// </summary>
public string Value { get; set; }}
/// <summary>
/// CSS style representation.
/// </summary>
internal class CSSStyle
{
/// <summary>
/// The css style sheet identifier (absent for user agent stylesheet and user-specified
/// stylesheet rules) this rule came from.
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// CSS properties in the style.
/// </summary>
public CSSProperty[] CssProperties { get; set; }
/// <summary>
/// Computed values for all shorthands found in the style.
/// </summary>
public ShorthandEntry[] ShorthandEntries { get; set; }
/// <summary>
/// Style declaration text (if available).
/// </summary>
public string CssText { get; set; }
/// <summary>
/// Style declaration range in the enclosing stylesheet (if available).
/// </summary>
public SourceRange Range { get; set; }}
/// <summary>
/// CSS property declaration data.
/// </summary>
internal class CSSProperty
{
/// <summary>
/// The property name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// The property value.
/// </summary>
public string Value { get; set; }
/// <summary>
/// Whether the property has "!important" annotation (implies `false` if absent).
/// </summary>
public bool Important { get; set; }
/// <summary>
/// Whether the property is implicit (implies `false` if absent).
/// </summary>
public bool Implicit { get; set; }
/// <summary>
/// The full property text as specified in the style.
/// </summary>
public string Text { get; set; }
/// <summary>
/// Whether the property is understood by the browser (implies `true` if absent).
/// </summary>
public bool ParsedOk { get; set; }
/// <summary>
/// Whether the property is disabled by the user (present for source-based properties only).
/// </summary>
public bool Disabled { get; set; }
/// <summary>
/// The entire property range in the enclosing style declaration (if available).
/// </summary>
public SourceRange Range { get; set; }}
/// <summary>
/// CSS media rule descriptor.
/// </summary>
internal class CSSMedia
{
/// <summary>
/// Media query text.
/// </summary>
public string Text { get; set; }
/// <summary>
/// Source of the media query: "mediaRule" if specified by a @media rule, "importRule" if
/// specified by an @import rule, "linkedSheet" if specified by a "media" attribute in a linked
/// stylesheet's LINK tag, "inlineSheet" if specified by a "media" attribute in an inline
/// stylesheet's STYLE tag.
/// </summary>
public string Source { get; set; }
/// <summary>
/// URL of the document containing the media query description.
/// </summary>
public string SourceURL { get; set; }
/// <summary>
/// The associated rule (@media or @import) header range in the enclosing stylesheet (if
/// available).
/// </summary>
public SourceRange Range { get; set; }
/// <summary>
/// Identifier of the stylesheet containing this object (if exists).
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// Array of media queries.
/// </summary>
public MediaQuery[] MediaList { get; set; }}
/// <summary>
/// Media query descriptor.
/// </summary>
internal class MediaQuery
{
/// <summary>
/// Array of media query expressions.
/// </summary>
public MediaQueryExpression[] Expressions { get; set; }
/// <summary>
/// Whether the media query condition is satisfied.
/// </summary>
public bool Active { get; set; }}
/// <summary>
/// Media query expression descriptor.
/// </summary>
internal class MediaQueryExpression
{
/// <summary>
/// Media query expression value.
/// </summary>
public double Value { get; set; }
/// <summary>
/// Media query expression units.
/// </summary>
public string Unit { get; set; }
/// <summary>
/// Media query expression feature.
/// </summary>
public string Feature { get; set; }
/// <summary>
/// The associated range of the value text in the enclosing stylesheet (if available).
/// </summary>
public SourceRange ValueRange { get; set; }
/// <summary>
/// Computed length of media query expression (if applicable).
/// </summary>
public double ComputedLength { get; set; }}
/// <summary>
/// Information about amount of glyphs that were rendered with given font.
/// </summary>
internal class PlatformFontUsage
{
/// <summary>
/// Font's family name reported by platform.
/// </summary>
public string FamilyName { get; set; }
/// <summary>
/// Indicates if the font was downloaded or resolved locally.
/// </summary>
public bool IsCustomFont { get; set; }
/// <summary>
/// Amount of glyphs that were rendered with this font.
/// </summary>
public double GlyphCount { get; set; }}
/// <summary>
/// Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions
/// </summary>
internal class FontFace
{
/// <summary>
/// The font-family.
/// </summary>
public string FontFamily { get; set; }
/// <summary>
/// The font-style.
/// </summary>
public string FontStyle { get; set; }
/// <summary>
/// The font-variant.
/// </summary>
public string FontVariant { get; set; }
/// <summary>
/// The font-weight.
/// </summary>
public string FontWeight { get; set; }
/// <summary>
/// The font-stretch.
/// </summary>
public string FontStretch { get; set; }
/// <summary>
/// The unicode-range.
/// </summary>
public string UnicodeRange { get; set; }
/// <summary>
/// The src.
/// </summary>
public string Src { get; set; }
/// <summary>
/// The resolved platform font family
/// </summary>
public string PlatformFontFamily { get; set; }}
/// <summary>
/// CSS keyframes rule representation.
/// </summary>
internal class CSSKeyframesRule
{
/// <summary>
/// Animation name.
/// </summary>
public Value AnimationName { get; set; }
/// <summary>
/// List of keyframes.
/// </summary>
public CSSKeyframeRule[] Keyframes { get; set; }}
/// <summary>
/// CSS keyframe rule representation.
/// </summary>
internal class CSSKeyframeRule
{
/// <summary>
/// The css style sheet identifier (absent for user agent stylesheet and user-specified
/// stylesheet rules) this rule came from.
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// Parent stylesheet's origin.
/// </summary>
public StyleSheetOrigin Origin { get; set; }
/// <summary>
/// Associated key text.
/// </summary>
public Value KeyText { get; set; }
/// <summary>
/// Associated style declaration.
/// </summary>
public CSSStyle Style { get; set; }}
/// <summary>
/// A descriptor of operation to mutate style declaration text.
/// </summary>
internal class StyleDeclarationEdit
{
/// <summary>
/// The css style sheet identifier.
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// The range of the style text in the enclosing stylesheet.
/// </summary>
public SourceRange Range { get; set; }
/// <summary>
/// New style text.
/// </summary>
public string Text { get; set; }}
/// <summary>
/// Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
/// position specified by `location`.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.addRule</c>
/// </remarks>
internal class CSSAddRuleRequest : IChromiumRequest<CSSAddRuleResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.addRule";
/// <summary>
/// The css style sheet identifier where a new rule should be inserted.
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// The text of a new rule.
/// </summary>
public string RuleText { get; set; }
/// <summary>
/// Text position of a new rule in the target style sheet.
/// </summary>
public SourceRange Location { get; set; }}
/// <summary>
/// Response from <see cref="CSSAddRuleRequest"/>
/// </summary>
internal class CSSAddRuleResponse : IChromiumResponse
{
/// <summary>
/// The newly created rule.
/// </summary>
public CSSRule Rule { get; set; }}
/// <summary>
/// Returns all class names from specified stylesheet.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.collectClassNames</c>
/// </remarks>
internal class CSSCollectClassNamesRequest : IChromiumRequest<CSSCollectClassNamesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.collectClassNames";
/// <summary>
/// 
/// </summary>
public string StyleSheetId { get; set; }}
/// <summary>
/// Response from <see cref="CSSCollectClassNamesRequest"/>
/// </summary>
internal class CSSCollectClassNamesResponse : IChromiumResponse
{
/// <summary>
/// Class name list.
/// </summary>
public string[] ClassNames { get; set; }}
/// <summary>
/// Creates a new special "via-inspector" stylesheet in the frame with given `frameId`.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.createStyleSheet</c>
/// </remarks>
internal class CSSCreateStyleSheetRequest : IChromiumRequest<CSSCreateStyleSheetResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.createStyleSheet";
/// <summary>
/// Identifier of the frame where "via-inspector" stylesheet should be created.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Response from <see cref="CSSCreateStyleSheetRequest"/>
/// </summary>
internal class CSSCreateStyleSheetResponse : IChromiumResponse
{
/// <summary>
/// Identifier of the created "via-inspector" stylesheet.
/// </summary>
public string StyleSheetId { get; set; }}
/// <summary>
/// Disables the CSS agent for the given page.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.disable</c>
/// </remarks>
internal class CSSDisableRequest : IChromiumRequest<CSSDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.disable";
}
/// <summary>
/// Response from <see cref="CSSDisableRequest"/>
/// </summary>
internal class CSSDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
/// enabled until the result of this command is received.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.enable</c>
/// </remarks>
internal class CSSEnableRequest : IChromiumRequest<CSSEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.enable";
}
/// <summary>
/// Response from <see cref="CSSEnableRequest"/>
/// </summary>
internal class CSSEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Ensures that the given node will have specified pseudo-classes whenever its style is computed by
/// the browser.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.forcePseudoState</c>
/// </remarks>
internal class CSSForcePseudoStateRequest : IChromiumRequest<CSSForcePseudoStateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.forcePseudoState";
/// <summary>
/// The element id for which to force the pseudo state.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Element pseudo classes to force when computing the element's style.
/// </summary>
public string[] ForcedPseudoClasses { get; set; }}
/// <summary>
/// Response from <see cref="CSSForcePseudoStateRequest"/>
/// </summary>
internal class CSSForcePseudoStateResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getBackgroundColors</c>
/// </remarks>
internal class CSSGetBackgroundColorsRequest : IChromiumRequest<CSSGetBackgroundColorsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getBackgroundColors";
/// <summary>
/// Id of the node to get background colors for.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Response from <see cref="CSSGetBackgroundColorsRequest"/>
/// </summary>
internal class CSSGetBackgroundColorsResponse : IChromiumResponse
{
/// <summary>
/// The range of background colors behind this element, if it contains any visible text. If no
/// visible text is present, this will be undefined. In the case of a flat background color,
/// this will consist of simply that color. In the case of a gradient, this will consist of each
/// of the color stops. For anything more complicated, this will be an empty array. Images will
/// be ignored (as if the image had failed to load).
/// </summary>
public string[] BackgroundColors { get; set; }
/// <summary>
/// The computed font size for this node, as a CSS computed value string (e.g. '12px').
/// </summary>
public string ComputedFontSize { get; set; }
/// <summary>
/// The computed font weight for this node, as a CSS computed value string (e.g. 'normal' or
/// '100').
/// </summary>
public string ComputedFontWeight { get; set; }}
/// <summary>
/// Returns the computed style for a DOM node identified by `nodeId`.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getComputedStyleForNode</c>
/// </remarks>
internal class CSSGetComputedStyleForNodeRequest : IChromiumRequest<CSSGetComputedStyleForNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getComputedStyleForNode";
/// <summary>
/// 
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Response from <see cref="CSSGetComputedStyleForNodeRequest"/>
/// </summary>
internal class CSSGetComputedStyleForNodeResponse : IChromiumResponse
{
/// <summary>
/// Computed style for the specified DOM node.
/// </summary>
public CSSComputedStyleProperty[] ComputedStyle { get; set; }}
/// <summary>
/// Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
/// attributes) for a DOM node identified by `nodeId`.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getInlineStylesForNode</c>
/// </remarks>
internal class CSSGetInlineStylesForNodeRequest : IChromiumRequest<CSSGetInlineStylesForNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getInlineStylesForNode";
/// <summary>
/// 
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Response from <see cref="CSSGetInlineStylesForNodeRequest"/>
/// </summary>
internal class CSSGetInlineStylesForNodeResponse : IChromiumResponse
{
/// <summary>
/// Inline style for the specified DOM node.
/// </summary>
public CSSStyle InlineStyle { get; set; }
/// <summary>
/// Attribute-defined element style (e.g. resulting from "width=20 height=100%").
/// </summary>
public CSSStyle AttributesStyle { get; set; }}
/// <summary>
/// Returns requested styles for a DOM node identified by `nodeId`.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getMatchedStylesForNode</c>
/// </remarks>
internal class CSSGetMatchedStylesForNodeRequest : IChromiumRequest<CSSGetMatchedStylesForNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getMatchedStylesForNode";
/// <summary>
/// 
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Response from <see cref="CSSGetMatchedStylesForNodeRequest"/>
/// </summary>
internal class CSSGetMatchedStylesForNodeResponse : IChromiumResponse
{
/// <summary>
/// Inline style for the specified DOM node.
/// </summary>
public CSSStyle InlineStyle { get; set; }
/// <summary>
/// Attribute-defined element style (e.g. resulting from "width=20 height=100%").
/// </summary>
public CSSStyle AttributesStyle { get; set; }
/// <summary>
/// CSS rules matching this node, from all applicable stylesheets.
/// </summary>
public RuleMatch[] MatchedCSSRules { get; set; }
/// <summary>
/// Pseudo style matches for this node.
/// </summary>
public PseudoElementMatches[] PseudoElements { get; set; }
/// <summary>
/// A chain of inherited styles (from the immediate node parent up to the DOM tree root).
/// </summary>
public InheritedStyleEntry[] Inherited { get; set; }
/// <summary>
/// A list of CSS keyframed animations matching this node.
/// </summary>
public CSSKeyframesRule[] CssKeyframesRules { get; set; }}
/// <summary>
/// Returns all media queries parsed by the rendering engine.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getMediaQueries</c>
/// </remarks>
internal class CSSGetMediaQueriesRequest : IChromiumRequest<CSSGetMediaQueriesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getMediaQueries";
}
/// <summary>
/// Response from <see cref="CSSGetMediaQueriesRequest"/>
/// </summary>
internal class CSSGetMediaQueriesResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public CSSMedia[] Medias { get; set; }}
/// <summary>
/// Requests information about platform fonts which we used to render child TextNodes in the given
/// node.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getPlatformFontsForNode</c>
/// </remarks>
internal class CSSGetPlatformFontsForNodeRequest : IChromiumRequest<CSSGetPlatformFontsForNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getPlatformFontsForNode";
/// <summary>
/// 
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Response from <see cref="CSSGetPlatformFontsForNodeRequest"/>
/// </summary>
internal class CSSGetPlatformFontsForNodeResponse : IChromiumResponse
{
/// <summary>
/// Usage statistics for every employed platform font.
/// </summary>
public PlatformFontUsage[] Fonts { get; set; }}
/// <summary>
/// Returns the current textual content for a stylesheet.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.getStyleSheetText</c>
/// </remarks>
internal class CSSGetStyleSheetTextRequest : IChromiumRequest<CSSGetStyleSheetTextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.getStyleSheetText";
/// <summary>
/// 
/// </summary>
public string StyleSheetId { get; set; }}
/// <summary>
/// Response from <see cref="CSSGetStyleSheetTextRequest"/>
/// </summary>
internal class CSSGetStyleSheetTextResponse : IChromiumResponse
{
/// <summary>
/// The stylesheet text.
/// </summary>
public string Text { get; set; }}
/// <summary>
/// Find a rule with the given active property for the given node and set the new value for this
/// property
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.setEffectivePropertyValueForNode</c>
/// </remarks>
internal class CSSSetEffectivePropertyValueForNodeRequest : IChromiumRequest<CSSSetEffectivePropertyValueForNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.setEffectivePropertyValueForNode";
/// <summary>
/// The element id for which to set property.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// 
/// </summary>
public string PropertyName { get; set; }
/// <summary>
/// 
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Response from <see cref="CSSSetEffectivePropertyValueForNodeRequest"/>
/// </summary>
internal class CSSSetEffectivePropertyValueForNodeResponse : IChromiumResponse
{
}
/// <summary>
/// Modifies the keyframe rule key text.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.setKeyframeKey</c>
/// </remarks>
internal class CSSSetKeyframeKeyRequest : IChromiumRequest<CSSSetKeyframeKeyResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.setKeyframeKey";
/// <summary>
/// 
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// 
/// </summary>
public SourceRange Range { get; set; }
/// <summary>
/// 
/// </summary>
public string KeyText { get; set; }}
/// <summary>
/// Response from <see cref="CSSSetKeyframeKeyRequest"/>
/// </summary>
internal class CSSSetKeyframeKeyResponse : IChromiumResponse
{
/// <summary>
/// The resulting key text after modification.
/// </summary>
public Value KeyText { get; set; }}
/// <summary>
/// Modifies the rule selector.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.setMediaText</c>
/// </remarks>
internal class CSSSetMediaTextRequest : IChromiumRequest<CSSSetMediaTextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.setMediaText";
/// <summary>
/// 
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// 
/// </summary>
public SourceRange Range { get; set; }
/// <summary>
/// 
/// </summary>
public string Text { get; set; }}
/// <summary>
/// Response from <see cref="CSSSetMediaTextRequest"/>
/// </summary>
internal class CSSSetMediaTextResponse : IChromiumResponse
{
/// <summary>
/// The resulting CSS media rule after modification.
/// </summary>
public CSSMedia Media { get; set; }}
/// <summary>
/// Modifies the rule selector.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.setRuleSelector</c>
/// </remarks>
internal class CSSSetRuleSelectorRequest : IChromiumRequest<CSSSetRuleSelectorResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.setRuleSelector";
/// <summary>
/// 
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// 
/// </summary>
public SourceRange Range { get; set; }
/// <summary>
/// 
/// </summary>
public string Selector { get; set; }}
/// <summary>
/// Response from <see cref="CSSSetRuleSelectorRequest"/>
/// </summary>
internal class CSSSetRuleSelectorResponse : IChromiumResponse
{
/// <summary>
/// The resulting selector list after modification.
/// </summary>
public SelectorList SelectorList { get; set; }}
/// <summary>
/// Sets the new stylesheet text.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.setStyleSheetText</c>
/// </remarks>
internal class CSSSetStyleSheetTextRequest : IChromiumRequest<CSSSetStyleSheetTextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.setStyleSheetText";
/// <summary>
/// 
/// </summary>
public string StyleSheetId { get; set; }
/// <summary>
/// 
/// </summary>
public string Text { get; set; }}
/// <summary>
/// Response from <see cref="CSSSetStyleSheetTextRequest"/>
/// </summary>
internal class CSSSetStyleSheetTextResponse : IChromiumResponse
{
/// <summary>
/// URL of source map associated with script (if any).
/// </summary>
public string SourceMapURL { get; set; }}
/// <summary>
/// Applies specified style edits one after another in the given order.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.setStyleTexts</c>
/// </remarks>
internal class CSSSetStyleTextsRequest : IChromiumRequest<CSSSetStyleTextsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.setStyleTexts";
/// <summary>
/// 
/// </summary>
public StyleDeclarationEdit[] Edits { get; set; }}
/// <summary>
/// Response from <see cref="CSSSetStyleTextsRequest"/>
/// </summary>
internal class CSSSetStyleTextsResponse : IChromiumResponse
{
/// <summary>
/// The resulting styles after modification.
/// </summary>
public CSSStyle[] Styles { get; set; }}
/// <summary>
/// Enables the selector recording.
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.startRuleUsageTracking</c>
/// </remarks>
internal class CSSStartRuleUsageTrackingRequest : IChromiumRequest<CSSStartRuleUsageTrackingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.startRuleUsageTracking";
}
/// <summary>
/// Response from <see cref="CSSStartRuleUsageTrackingRequest"/>
/// </summary>
internal class CSSStartRuleUsageTrackingResponse : IChromiumResponse
{
}
/// <summary>
/// Stop tracking rule usage and return the list of rules that were used since last call to
/// `takeCoverageDelta` (or since start of coverage instrumentation)
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.stopRuleUsageTracking</c>
/// </remarks>
internal class CSSStopRuleUsageTrackingRequest : IChromiumRequest<CSSStopRuleUsageTrackingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.stopRuleUsageTracking";
}
/// <summary>
/// Response from <see cref="CSSStopRuleUsageTrackingRequest"/>
/// </summary>
internal class CSSStopRuleUsageTrackingResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public RuleUsage[] RuleUsage { get; set; }}
/// <summary>
/// Obtain list of rules that became used since last call to this method (or since start of coverage
/// instrumentation)
/// </summary>
/// <remarks>
/// Will send the command <c>CSS.takeCoverageDelta</c>
/// </remarks>
internal class CSSTakeCoverageDeltaRequest : IChromiumRequest<CSSTakeCoverageDeltaResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CSS.takeCoverageDelta";
}
/// <summary>
/// Response from <see cref="CSSTakeCoverageDeltaRequest"/>
/// </summary>
internal class CSSTakeCoverageDeltaResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public RuleUsage[] Coverage { get; set; }
/// <summary>
/// Monotonically increasing time, in seconds.
/// </summary>
public double Timestamp { get; set; }}
/// <summary>
/// Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
/// web font
/// </summary>
/// <remarks>
/// Matches on the event <c>CSS.fontsUpdated</c>
/// </remarks>
internal class CSSFontsUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "CSS.fontsUpdated";
/// <summary>
/// The web font that has loaded.
/// </summary>
public FontFace Font { get; set; }}
/// <summary>
/// Fires whenever a MediaQuery result changes (for example, after a browser window has been
/// resized.) The current implementation considers only viewport-dependent media features.
/// </summary>
/// <remarks>
/// Matches on the event <c>CSS.mediaQueryResultChanged</c>
/// </remarks>
internal class CSSMediaQueryResultChangedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "CSS.mediaQueryResultChanged";
}
/// <summary>
/// Fired whenever an active document stylesheet is added.
/// </summary>
/// <remarks>
/// Matches on the event <c>CSS.styleSheetAdded</c>
/// </remarks>
internal class CSSStyleSheetAddedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "CSS.styleSheetAdded";
/// <summary>
/// Added stylesheet metainfo.
/// </summary>
public CSSStyleSheetHeader Header { get; set; }}
/// <summary>
/// Fired whenever a stylesheet is changed as a result of the client operation.
/// </summary>
/// <remarks>
/// Matches on the event <c>CSS.styleSheetChanged</c>
/// </remarks>
internal class CSSStyleSheetChangedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "CSS.styleSheetChanged";
/// <summary>
/// 
/// </summary>
public string StyleSheetId { get; set; }}
/// <summary>
/// Fired whenever an active document stylesheet is removed.
/// </summary>
/// <remarks>
/// Matches on the event <c>CSS.styleSheetRemoved</c>
/// </remarks>
internal class CSSStyleSheetRemovedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "CSS.styleSheetRemoved";
/// <summary>
/// Identifier of the removed stylesheet.
/// </summary>
public string StyleSheetId { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.CacheStorage
{
/// <summary>
/// type of HTTP response cached
/// </summary>
internal enum CachedResponseType
{
[System.Runtime.Serialization.EnumMember(Value = "basic")]Basic,
[System.Runtime.Serialization.EnumMember(Value = "cors")]Cors,
[System.Runtime.Serialization.EnumMember(Value = "default")]Default,
[System.Runtime.Serialization.EnumMember(Value = "error")]Error,
[System.Runtime.Serialization.EnumMember(Value = "opaqueResponse")]OpaqueResponse,
[System.Runtime.Serialization.EnumMember(Value = "opaqueRedirect")]OpaqueRedirect}
/// <summary>
/// Data entry.
/// </summary>
internal class DataEntry
{
/// <summary>
/// Request URL.
/// </summary>
public string RequestURL { get; set; }
/// <summary>
/// Request method.
/// </summary>
public string RequestMethod { get; set; }
/// <summary>
/// Request headers
/// </summary>
public Header[] RequestHeaders { get; set; }
/// <summary>
/// Number of seconds since epoch.
/// </summary>
public double ResponseTime { get; set; }
/// <summary>
/// HTTP response status code.
/// </summary>
public int ResponseStatus { get; set; }
/// <summary>
/// HTTP response status text.
/// </summary>
public string ResponseStatusText { get; set; }
/// <summary>
/// HTTP response type
/// </summary>
public CachedResponseType ResponseType { get; set; }
/// <summary>
/// Response headers
/// </summary>
public Header[] ResponseHeaders { get; set; }}
/// <summary>
/// Cache identifier.
/// </summary>
internal class Cache
{
/// <summary>
/// An opaque unique id of the cache.
/// </summary>
public string CacheId { get; set; }
/// <summary>
/// Security origin of the cache.
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// The name of the cache.
/// </summary>
public string CacheName { get; set; }}
/// <summary>
/// 
/// </summary>
internal class Header
{
/// <summary>
/// 
/// </summary>
public string Name { get; set; }
/// <summary>
/// 
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Cached response
/// </summary>
internal class CachedResponse
{
/// <summary>
/// Entry content, base64-encoded.
/// </summary>
public byte[] Body { get; set; }}
/// <summary>
/// Deletes a cache.
/// </summary>
/// <remarks>
/// Will send the command <c>CacheStorage.deleteCache</c>
/// </remarks>
internal class CacheStorageDeleteCacheRequest : IChromiumRequest<CacheStorageDeleteCacheResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CacheStorage.deleteCache";
/// <summary>
/// Id of cache for deletion.
/// </summary>
public string CacheId { get; set; }}
/// <summary>
/// Response from <see cref="CacheStorageDeleteCacheRequest"/>
/// </summary>
internal class CacheStorageDeleteCacheResponse : IChromiumResponse
{
}
/// <summary>
/// Deletes a cache entry.
/// </summary>
/// <remarks>
/// Will send the command <c>CacheStorage.deleteEntry</c>
/// </remarks>
internal class CacheStorageDeleteEntryRequest : IChromiumRequest<CacheStorageDeleteEntryResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CacheStorage.deleteEntry";
/// <summary>
/// Id of cache where the entry will be deleted.
/// </summary>
public string CacheId { get; set; }
/// <summary>
/// URL spec of the request.
/// </summary>
public string Request { get; set; }}
/// <summary>
/// Response from <see cref="CacheStorageDeleteEntryRequest"/>
/// </summary>
internal class CacheStorageDeleteEntryResponse : IChromiumResponse
{
}
/// <summary>
/// Requests cache names.
/// </summary>
/// <remarks>
/// Will send the command <c>CacheStorage.requestCacheNames</c>
/// </remarks>
internal class CacheStorageRequestCacheNamesRequest : IChromiumRequest<CacheStorageRequestCacheNamesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CacheStorage.requestCacheNames";
/// <summary>
/// Security origin.
/// </summary>
public string SecurityOrigin { get; set; }}
/// <summary>
/// Response from <see cref="CacheStorageRequestCacheNamesRequest"/>
/// </summary>
internal class CacheStorageRequestCacheNamesResponse : IChromiumResponse
{
/// <summary>
/// Caches for the security origin.
/// </summary>
public Cache[] Caches { get; set; }}
/// <summary>
/// Fetches cache entry.
/// </summary>
/// <remarks>
/// Will send the command <c>CacheStorage.requestCachedResponse</c>
/// </remarks>
internal class CacheStorageRequestCachedResponseRequest : IChromiumRequest<CacheStorageRequestCachedResponseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CacheStorage.requestCachedResponse";
/// <summary>
/// Id of cache that contains the entry.
/// </summary>
public string CacheId { get; set; }
/// <summary>
/// URL spec of the request.
/// </summary>
public string RequestURL { get; set; }
/// <summary>
/// headers of the request.
/// </summary>
public Header[] RequestHeaders { get; set; }}
/// <summary>
/// Response from <see cref="CacheStorageRequestCachedResponseRequest"/>
/// </summary>
internal class CacheStorageRequestCachedResponseResponse : IChromiumResponse
{
/// <summary>
/// Response read from the cache.
/// </summary>
public CachedResponse Response { get; set; }}
/// <summary>
/// Requests data from cache.
/// </summary>
/// <remarks>
/// Will send the command <c>CacheStorage.requestEntries</c>
/// </remarks>
internal class CacheStorageRequestEntriesRequest : IChromiumRequest<CacheStorageRequestEntriesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "CacheStorage.requestEntries";
/// <summary>
/// ID of cache to get entries from.
/// </summary>
public string CacheId { get; set; }
/// <summary>
/// Number of records to skip.
/// </summary>
public int SkipCount { get; set; }
/// <summary>
/// Number of records to fetch.
/// </summary>
public int PageSize { get; set; }
/// <summary>
/// If present, only return the entries containing this substring in the path
/// </summary>
public string PathFilter { get; set; }}
/// <summary>
/// Response from <see cref="CacheStorageRequestEntriesRequest"/>
/// </summary>
internal class CacheStorageRequestEntriesResponse : IChromiumResponse
{
/// <summary>
/// Array of object store data entries.
/// </summary>
public DataEntry[] CacheDataEntries { get; set; }
/// <summary>
/// Count of returned entries from this storage. If pathFilter is empty, it
/// is the count of all entries from this storage.
/// </summary>
public double ReturnCount { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Cast
{
/// <summary>
/// 
/// </summary>
internal class Sink
{
/// <summary>
/// 
/// </summary>
public string Name { get; set; }
/// <summary>
/// 
/// </summary>
public string Id { get; set; }
/// <summary>
/// Text describing the current session. Present only if there is an active
/// session on the sink.
/// </summary>
public string Session { get; set; }}
/// <summary>
/// Starts observing for sinks that can be used for tab mirroring, and if set,
/// sinks compatible with |presentationUrl| as well. When sinks are found, a
/// |sinksUpdated| event is fired.
/// Also starts observing for issue messages. When an issue is added or removed,
/// an |issueUpdated| event is fired.
/// </summary>
/// <remarks>
/// Will send the command <c>Cast.enable</c>
/// </remarks>
internal class CastEnableRequest : IChromiumRequest<CastEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Cast.enable";
/// <summary>
/// 
/// </summary>
public string PresentationUrl { get; set; }}
/// <summary>
/// Response from <see cref="CastEnableRequest"/>
/// </summary>
internal class CastEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Stops observing for sinks and issues.
/// </summary>
/// <remarks>
/// Will send the command <c>Cast.disable</c>
/// </remarks>
internal class CastDisableRequest : IChromiumRequest<CastDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Cast.disable";
}
/// <summary>
/// Response from <see cref="CastDisableRequest"/>
/// </summary>
internal class CastDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Sets a sink to be used when the web page requests the browser to choose a
/// sink via Presentation API, Remote Playback API, or Cast SDK.
/// </summary>
/// <remarks>
/// Will send the command <c>Cast.setSinkToUse</c>
/// </remarks>
internal class CastSetSinkToUseRequest : IChromiumRequest<CastSetSinkToUseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Cast.setSinkToUse";
/// <summary>
/// 
/// </summary>
public string SinkName { get; set; }}
/// <summary>
/// Response from <see cref="CastSetSinkToUseRequest"/>
/// </summary>
internal class CastSetSinkToUseResponse : IChromiumResponse
{
}
/// <summary>
/// Starts mirroring the tab to the sink.
/// </summary>
/// <remarks>
/// Will send the command <c>Cast.startTabMirroring</c>
/// </remarks>
internal class CastStartTabMirroringRequest : IChromiumRequest<CastStartTabMirroringResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Cast.startTabMirroring";
/// <summary>
/// 
/// </summary>
public string SinkName { get; set; }}
/// <summary>
/// Response from <see cref="CastStartTabMirroringRequest"/>
/// </summary>
internal class CastStartTabMirroringResponse : IChromiumResponse
{
}
/// <summary>
/// Stops the active Cast session on the sink.
/// </summary>
/// <remarks>
/// Will send the command <c>Cast.stopCasting</c>
/// </remarks>
internal class CastStopCastingRequest : IChromiumRequest<CastStopCastingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Cast.stopCasting";
/// <summary>
/// 
/// </summary>
public string SinkName { get; set; }}
/// <summary>
/// Response from <see cref="CastStopCastingRequest"/>
/// </summary>
internal class CastStopCastingResponse : IChromiumResponse
{
}
/// <summary>
/// This is fired whenever the list of available sinks changes. A sink is a
/// device or a software surface that you can cast to.
/// </summary>
/// <remarks>
/// Matches on the event <c>Cast.sinksUpdated</c>
/// </remarks>
internal class CastSinksUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Cast.sinksUpdated";
/// <summary>
/// 
/// </summary>
public Sink[] Sinks { get; set; }}
/// <summary>
/// This is fired whenever the outstanding issue/error message changes.
/// |issueMessage| is empty if there is no issue.
/// </summary>
/// <remarks>
/// Matches on the event <c>Cast.issueUpdated</c>
/// </remarks>
internal class CastIssueUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Cast.issueUpdated";
/// <summary>
/// 
/// </summary>
public string IssueMessage { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.DOM
{
/// <summary>
/// Backend node with a friendly name.
/// </summary>
internal class BackendNode
{
/// <summary>
/// `Node`'s nodeType.
/// </summary>
public int NodeType { get; set; }
/// <summary>
/// `Node`'s nodeName.
/// </summary>
public string NodeName { get; set; }
/// <summary>
/// 
/// </summary>
public int BackendNodeId { get; set; }}
/// <summary>
/// Pseudo element type.
/// </summary>
internal enum PseudoType
{
[System.Runtime.Serialization.EnumMember(Value = "first-line")]FirstLine,
[System.Runtime.Serialization.EnumMember(Value = "first-letter")]FirstLetter,
[System.Runtime.Serialization.EnumMember(Value = "before")]Before,
[System.Runtime.Serialization.EnumMember(Value = "after")]After,
[System.Runtime.Serialization.EnumMember(Value = "marker")]Marker,
[System.Runtime.Serialization.EnumMember(Value = "backdrop")]Backdrop,
[System.Runtime.Serialization.EnumMember(Value = "selection")]Selection,
[System.Runtime.Serialization.EnumMember(Value = "first-line-inherited")]FirstLineInherited,
[System.Runtime.Serialization.EnumMember(Value = "scrollbar")]Scrollbar,
[System.Runtime.Serialization.EnumMember(Value = "scrollbar-thumb")]ScrollbarThumb,
[System.Runtime.Serialization.EnumMember(Value = "scrollbar-button")]ScrollbarButton,
[System.Runtime.Serialization.EnumMember(Value = "scrollbar-track")]ScrollbarTrack,
[System.Runtime.Serialization.EnumMember(Value = "scrollbar-track-piece")]ScrollbarTrackPiece,
[System.Runtime.Serialization.EnumMember(Value = "scrollbar-corner")]ScrollbarCorner,
[System.Runtime.Serialization.EnumMember(Value = "resizer")]Resizer,
[System.Runtime.Serialization.EnumMember(Value = "input-list-button")]InputListButton}
/// <summary>
/// Shadow root type.
/// </summary>
internal enum ShadowRootType
{
[System.Runtime.Serialization.EnumMember(Value = "user-agent")]UserAgent,
[System.Runtime.Serialization.EnumMember(Value = "open")]Open,
[System.Runtime.Serialization.EnumMember(Value = "closed")]Closed}
/// <summary>
/// DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
/// DOMNode is a base node mirror type.
/// </summary>
internal class Node
{
/// <summary>
/// Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend
/// will only push node with given `id` once. It is aware of all requested nodes and will only
/// fire DOM events for nodes known to the client.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// The id of the parent node if any.
/// </summary>
public int ParentId { get; set; }
/// <summary>
/// The BackendNodeId for this node.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// `Node`'s nodeType.
/// </summary>
public int NodeType { get; set; }
/// <summary>
/// `Node`'s nodeName.
/// </summary>
public string NodeName { get; set; }
/// <summary>
/// `Node`'s localName.
/// </summary>
public string LocalName { get; set; }
/// <summary>
/// `Node`'s nodeValue.
/// </summary>
public string NodeValue { get; set; }
/// <summary>
/// Child count for `Container` nodes.
/// </summary>
public int ChildNodeCount { get; set; }
/// <summary>
/// Child nodes of this node when requested with children.
/// </summary>
public Node[] Children { get; set; }
/// <summary>
/// Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`.
/// </summary>
public string[] Attributes { get; set; }
/// <summary>
/// Document URL that `Document` or `FrameOwner` node points to.
/// </summary>
public string DocumentURL { get; set; }
/// <summary>
/// Base URL that `Document` or `FrameOwner` node uses for URL completion.
/// </summary>
public string BaseURL { get; set; }
/// <summary>
/// `DocumentType`'s publicId.
/// </summary>
public string PublicId { get; set; }
/// <summary>
/// `DocumentType`'s systemId.
/// </summary>
public string SystemId { get; set; }
/// <summary>
/// `DocumentType`'s internalSubset.
/// </summary>
public string InternalSubset { get; set; }
/// <summary>
/// `Document`'s XML version in case of XML documents.
/// </summary>
public string XmlVersion { get; set; }
/// <summary>
/// `Attr`'s name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// `Attr`'s value.
/// </summary>
public string Value { get; set; }
/// <summary>
/// Pseudo element type for this node.
/// </summary>
public PseudoType PseudoType { get; set; }
/// <summary>
/// Shadow root type.
/// </summary>
public ShadowRootType ShadowRootType { get; set; }
/// <summary>
/// Frame ID for frame owner elements.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Content document for frame owner elements.
/// </summary>
public Node ContentDocument { get; set; }
/// <summary>
/// Shadow root list for given element host.
/// </summary>
public Node[] ShadowRoots { get; set; }
/// <summary>
/// Content document fragment for template elements.
/// </summary>
public Node TemplateContent { get; set; }
/// <summary>
/// Pseudo elements associated with this node.
/// </summary>
public Node[] PseudoElements { get; set; }
/// <summary>
/// Import document for the HTMLImport links.
/// </summary>
public Node ImportedDocument { get; set; }
/// <summary>
/// Distributed nodes for given insertion point.
/// </summary>
public BackendNode[] DistributedNodes { get; set; }
/// <summary>
/// Whether the node is SVG.
/// </summary>
public bool IsSVG { get; set; }}
/// <summary>
/// A structure holding an RGBA color.
/// </summary>
internal class RGBA
{
/// <summary>
/// The red component, in the [0-255] range.
/// </summary>
public int R { get; set; }
/// <summary>
/// The green component, in the [0-255] range.
/// </summary>
public int G { get; set; }
/// <summary>
/// The blue component, in the [0-255] range.
/// </summary>
public int B { get; set; }
/// <summary>
/// The alpha component, in the [0-1] range (default: 1).
/// </summary>
public double A { get; set; }}
/// <summary>
/// Box model.
/// </summary>
internal class BoxModel
{
/// <summary>
/// Content box
/// </summary>
public double[] Content { get; set; }
/// <summary>
/// Padding box
/// </summary>
public double[] Padding { get; set; }
/// <summary>
/// Border box
/// </summary>
public double[] Border { get; set; }
/// <summary>
/// Margin box
/// </summary>
public double[] Margin { get; set; }
/// <summary>
/// Node width
/// </summary>
public int Width { get; set; }
/// <summary>
/// Node height
/// </summary>
public int Height { get; set; }
/// <summary>
/// Shape outside coordinates
/// </summary>
public ShapeOutsideInfo ShapeOutside { get; set; }}
/// <summary>
/// CSS Shape Outside details.
/// </summary>
internal class ShapeOutsideInfo
{
/// <summary>
/// Shape bounds
/// </summary>
public double[] Bounds { get; set; }
/// <summary>
/// Shape coordinate details
/// </summary>
public JsonElement?[] Shape { get; set; }
/// <summary>
/// Margin shape bounds
/// </summary>
public JsonElement?[] MarginShape { get; set; }}
/// <summary>
/// Rectangle.
/// </summary>
internal class Rect
{
/// <summary>
/// X coordinate
/// </summary>
public double X { get; set; }
/// <summary>
/// Y coordinate
/// </summary>
public double Y { get; set; }
/// <summary>
/// Rectangle width
/// </summary>
public double Width { get; set; }
/// <summary>
/// Rectangle height
/// </summary>
public double Height { get; set; }}
/// <summary>
/// Collects class names for the node with given id and all of it's child nodes.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.collectClassNamesFromSubtree</c>
/// </remarks>
internal class DOMCollectClassNamesFromSubtreeRequest : IChromiumRequest<DOMCollectClassNamesFromSubtreeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.collectClassNamesFromSubtree";
/// <summary>
/// Id of the node to collect class names.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMCollectClassNamesFromSubtreeRequest"/>
/// </summary>
internal class DOMCollectClassNamesFromSubtreeResponse : IChromiumResponse
{
/// <summary>
/// Class name list.
/// </summary>
public string[] ClassNames { get; set; }}
/// <summary>
/// Creates a deep copy of the specified node and places it into the target container before the
/// given anchor.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.copyTo</c>
/// </remarks>
internal class DOMCopyToRequest : IChromiumRequest<DOMCopyToResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.copyTo";
/// <summary>
/// Id of the node to copy.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Id of the element to drop the copy into.
/// </summary>
public int TargetNodeId { get; set; }
/// <summary>
/// Drop the copy before this node (if absent, the copy becomes the last child of
/// `targetNodeId`).
/// </summary>
public int InsertBeforeNodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMCopyToRequest"/>
/// </summary>
internal class DOMCopyToResponse : IChromiumResponse
{
/// <summary>
/// Id of the node clone.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Describes node given its id, does not require domain to be enabled. Does not start tracking any
/// objects, can be used for automation.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.describeNode</c>
/// </remarks>
internal class DOMDescribeNodeRequest : IChromiumRequest<DOMDescribeNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.describeNode";
/// <summary>
/// Identifier of the node.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Identifier of the backend node.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// JavaScript object id of the node wrapper.
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
/// entire subtree or provide an integer larger than 0.
/// </summary>
public int Depth { get; set; }
/// <summary>
/// Whether or not iframes and shadow roots should be traversed when returning the subtree
/// (default is false).
/// </summary>
public bool Pierce { get; set; }}
/// <summary>
/// Response from <see cref="DOMDescribeNodeRequest"/>
/// </summary>
internal class DOMDescribeNodeResponse : IChromiumResponse
{
/// <summary>
/// Node description.
/// </summary>
public Node Node { get; set; }}
/// <summary>
/// Disables DOM agent for the given page.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.disable</c>
/// </remarks>
internal class DOMDisableRequest : IChromiumRequest<DOMDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.disable";
}
/// <summary>
/// Response from <see cref="DOMDisableRequest"/>
/// </summary>
internal class DOMDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Discards search results from the session with the given id. `getSearchResults` should no longer
/// be called for that search.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.discardSearchResults</c>
/// </remarks>
internal class DOMDiscardSearchResultsRequest : IChromiumRequest<DOMDiscardSearchResultsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.discardSearchResults";
/// <summary>
/// Unique search session identifier.
/// </summary>
public string SearchId { get; set; }}
/// <summary>
/// Response from <see cref="DOMDiscardSearchResultsRequest"/>
/// </summary>
internal class DOMDiscardSearchResultsResponse : IChromiumResponse
{
}
/// <summary>
/// Enables DOM agent for the given page.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.enable</c>
/// </remarks>
internal class DOMEnableRequest : IChromiumRequest<DOMEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.enable";
}
/// <summary>
/// Response from <see cref="DOMEnableRequest"/>
/// </summary>
internal class DOMEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Focuses the given element.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.focus</c>
/// </remarks>
internal class DOMFocusRequest : IChromiumRequest<DOMFocusResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.focus";
/// <summary>
/// Identifier of the node.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Identifier of the backend node.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// JavaScript object id of the node wrapper.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="DOMFocusRequest"/>
/// </summary>
internal class DOMFocusResponse : IChromiumResponse
{
}
/// <summary>
/// Returns attributes for the specified node.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getAttributes</c>
/// </remarks>
internal class DOMGetAttributesRequest : IChromiumRequest<DOMGetAttributesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getAttributes";
/// <summary>
/// Id of the node to retrieve attibutes for.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetAttributesRequest"/>
/// </summary>
internal class DOMGetAttributesResponse : IChromiumResponse
{
/// <summary>
/// An interleaved array of node attribute names and values.
/// </summary>
public string[] Attributes { get; set; }}
/// <summary>
/// Returns boxes for the given node.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getBoxModel</c>
/// </remarks>
internal class DOMGetBoxModelRequest : IChromiumRequest<DOMGetBoxModelResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getBoxModel";
/// <summary>
/// Identifier of the node.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Identifier of the backend node.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// JavaScript object id of the node wrapper.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetBoxModelRequest"/>
/// </summary>
internal class DOMGetBoxModelResponse : IChromiumResponse
{
/// <summary>
/// Box model for the node.
/// </summary>
public BoxModel Model { get; set; }}
/// <summary>
/// Returns quads that describe node position on the page. This method
/// might return multiple quads for inline nodes.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getContentQuads</c>
/// </remarks>
internal class DOMGetContentQuadsRequest : IChromiumRequest<DOMGetContentQuadsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getContentQuads";
/// <summary>
/// Identifier of the node.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Identifier of the backend node.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// JavaScript object id of the node wrapper.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetContentQuadsRequest"/>
/// </summary>
internal class DOMGetContentQuadsResponse : IChromiumResponse
{
/// <summary>
/// Quads that describe node layout relative to viewport.
/// </summary>
public double[][] Quads { get; set; }}
/// <summary>
/// Returns the root DOM node (and optionally the subtree) to the caller.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getDocument</c>
/// </remarks>
internal class DOMGetDocumentRequest : IChromiumRequest<DOMGetDocumentResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getDocument";
/// <summary>
/// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
/// entire subtree or provide an integer larger than 0.
/// </summary>
public int Depth { get; set; }
/// <summary>
/// Whether or not iframes and shadow roots should be traversed when returning the subtree
/// (default is false).
/// </summary>
public bool Pierce { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetDocumentRequest"/>
/// </summary>
internal class DOMGetDocumentResponse : IChromiumResponse
{
/// <summary>
/// Resulting node.
/// </summary>
public Node Root { get; set; }}
/// <summary>
/// Returns the root DOM node (and optionally the subtree) to the caller.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getFlattenedDocument</c>
/// </remarks>
internal class DOMGetFlattenedDocumentRequest : IChromiumRequest<DOMGetFlattenedDocumentResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getFlattenedDocument";
/// <summary>
/// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
/// entire subtree or provide an integer larger than 0.
/// </summary>
public int Depth { get; set; }
/// <summary>
/// Whether or not iframes and shadow roots should be traversed when returning the subtree
/// (default is false).
/// </summary>
public bool Pierce { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetFlattenedDocumentRequest"/>
/// </summary>
internal class DOMGetFlattenedDocumentResponse : IChromiumResponse
{
/// <summary>
/// Resulting node.
/// </summary>
public Node[] Nodes { get; set; }}
/// <summary>
/// Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
/// either returned or not.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getNodeForLocation</c>
/// </remarks>
internal class DOMGetNodeForLocationRequest : IChromiumRequest<DOMGetNodeForLocationResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getNodeForLocation";
/// <summary>
/// X coordinate.
/// </summary>
public int X { get; set; }
/// <summary>
/// Y coordinate.
/// </summary>
public int Y { get; set; }
/// <summary>
/// False to skip to the nearest non-UA shadow root ancestor (default: false).
/// </summary>
public bool IncludeUserAgentShadowDOM { get; set; }
/// <summary>
/// Whether to ignore pointer-events: none on elements and hit test them.
/// </summary>
public bool IgnorePointerEventsNone { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetNodeForLocationRequest"/>
/// </summary>
internal class DOMGetNodeForLocationResponse : IChromiumResponse
{
/// <summary>
/// Resulting node.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// Frame this node belongs to.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Id of the node at given coordinates, only when enabled and requested document.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Returns node's HTML markup.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getOuterHTML</c>
/// </remarks>
internal class DOMGetOuterHTMLRequest : IChromiumRequest<DOMGetOuterHTMLResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getOuterHTML";
/// <summary>
/// Identifier of the node.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Identifier of the backend node.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// JavaScript object id of the node wrapper.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetOuterHTMLRequest"/>
/// </summary>
internal class DOMGetOuterHTMLResponse : IChromiumResponse
{
/// <summary>
/// Outer HTML markup.
/// </summary>
public string OuterHTML { get; set; }}
/// <summary>
/// Returns the id of the nearest ancestor that is a relayout boundary.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getRelayoutBoundary</c>
/// </remarks>
internal class DOMGetRelayoutBoundaryRequest : IChromiumRequest<DOMGetRelayoutBoundaryResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getRelayoutBoundary";
/// <summary>
/// Id of the node.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetRelayoutBoundaryRequest"/>
/// </summary>
internal class DOMGetRelayoutBoundaryResponse : IChromiumResponse
{
/// <summary>
/// Relayout boundary node id for the given node.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Returns search results from given `fromIndex` to given `toIndex` from the search with the given
/// identifier.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getSearchResults</c>
/// </remarks>
internal class DOMGetSearchResultsRequest : IChromiumRequest<DOMGetSearchResultsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getSearchResults";
/// <summary>
/// Unique search session identifier.
/// </summary>
public string SearchId { get; set; }
/// <summary>
/// Start index of the search result to be returned.
/// </summary>
public int FromIndex { get; set; }
/// <summary>
/// End index of the search result to be returned.
/// </summary>
public int ToIndex { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetSearchResultsRequest"/>
/// </summary>
internal class DOMGetSearchResultsResponse : IChromiumResponse
{
/// <summary>
/// Ids of the search result nodes.
/// </summary>
public int[] NodeIds { get; set; }}
/// <summary>
/// Hides any highlight.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.hideHighlight</c>
/// </remarks>
internal class DOMHideHighlightRequest : IChromiumRequest<DOMHideHighlightResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.hideHighlight";
}
/// <summary>
/// Response from <see cref="DOMHideHighlightRequest"/>
/// </summary>
internal class DOMHideHighlightResponse : IChromiumResponse
{
}
/// <summary>
/// Highlights DOM node.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.highlightNode</c>
/// </remarks>
internal class DOMHighlightNodeRequest : IChromiumRequest<DOMHighlightNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.highlightNode";
}
/// <summary>
/// Response from <see cref="DOMHighlightNodeRequest"/>
/// </summary>
internal class DOMHighlightNodeResponse : IChromiumResponse
{
}
/// <summary>
/// Highlights given rectangle.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.highlightRect</c>
/// </remarks>
internal class DOMHighlightRectRequest : IChromiumRequest<DOMHighlightRectResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.highlightRect";
}
/// <summary>
/// Response from <see cref="DOMHighlightRectRequest"/>
/// </summary>
internal class DOMHighlightRectResponse : IChromiumResponse
{
}
/// <summary>
/// Marks last undoable state.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.markUndoableState</c>
/// </remarks>
internal class DOMMarkUndoableStateRequest : IChromiumRequest<DOMMarkUndoableStateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.markUndoableState";
}
/// <summary>
/// Response from <see cref="DOMMarkUndoableStateRequest"/>
/// </summary>
internal class DOMMarkUndoableStateResponse : IChromiumResponse
{
}
/// <summary>
/// Moves node into the new container, places it before the given anchor.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.moveTo</c>
/// </remarks>
internal class DOMMoveToRequest : IChromiumRequest<DOMMoveToResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.moveTo";
/// <summary>
/// Id of the node to move.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Id of the element to drop the moved node into.
/// </summary>
public int TargetNodeId { get; set; }
/// <summary>
/// Drop node before this one (if absent, the moved node becomes the last child of
/// `targetNodeId`).
/// </summary>
public int InsertBeforeNodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMMoveToRequest"/>
/// </summary>
internal class DOMMoveToResponse : IChromiumResponse
{
/// <summary>
/// New id of the moved node.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
/// `cancelSearch` to end this search session.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.performSearch</c>
/// </remarks>
internal class DOMPerformSearchRequest : IChromiumRequest<DOMPerformSearchResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.performSearch";
/// <summary>
/// Plain text or query selector or XPath search query.
/// </summary>
public string Query { get; set; }
/// <summary>
/// True to search in user agent shadow DOM.
/// </summary>
public bool IncludeUserAgentShadowDOM { get; set; }}
/// <summary>
/// Response from <see cref="DOMPerformSearchRequest"/>
/// </summary>
internal class DOMPerformSearchResponse : IChromiumResponse
{
/// <summary>
/// Unique search session identifier.
/// </summary>
public string SearchId { get; set; }
/// <summary>
/// Number of search results.
/// </summary>
public int ResultCount { get; set; }}
/// <summary>
/// Requests that the node is sent to the caller given its path. // FIXME, use XPath
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.pushNodeByPathToFrontend</c>
/// </remarks>
internal class DOMPushNodeByPathToFrontendRequest : IChromiumRequest<DOMPushNodeByPathToFrontendResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.pushNodeByPathToFrontend";
/// <summary>
/// Path to node in the proprietary format.
/// </summary>
public string Path { get; set; }}
/// <summary>
/// Response from <see cref="DOMPushNodeByPathToFrontendRequest"/>
/// </summary>
internal class DOMPushNodeByPathToFrontendResponse : IChromiumResponse
{
/// <summary>
/// Id of the node for given path.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Requests that a batch of nodes is sent to the caller given their backend node ids.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.pushNodesByBackendIdsToFrontend</c>
/// </remarks>
internal class DOMPushNodesByBackendIdsToFrontendRequest : IChromiumRequest<DOMPushNodesByBackendIdsToFrontendResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.pushNodesByBackendIdsToFrontend";
/// <summary>
/// The array of backend node ids.
/// </summary>
public int[] BackendNodeIds { get; set; }}
/// <summary>
/// Response from <see cref="DOMPushNodesByBackendIdsToFrontendRequest"/>
/// </summary>
internal class DOMPushNodesByBackendIdsToFrontendResponse : IChromiumResponse
{
/// <summary>
/// The array of ids of pushed nodes that correspond to the backend ids specified in
/// backendNodeIds.
/// </summary>
public int[] NodeIds { get; set; }}
/// <summary>
/// Executes `querySelector` on a given node.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.querySelector</c>
/// </remarks>
internal class DOMQuerySelectorRequest : IChromiumRequest<DOMQuerySelectorResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.querySelector";
/// <summary>
/// Id of the node to query upon.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Selector string.
/// </summary>
public string Selector { get; set; }}
/// <summary>
/// Response from <see cref="DOMQuerySelectorRequest"/>
/// </summary>
internal class DOMQuerySelectorResponse : IChromiumResponse
{
/// <summary>
/// Query selector result.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Executes `querySelectorAll` on a given node.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.querySelectorAll</c>
/// </remarks>
internal class DOMQuerySelectorAllRequest : IChromiumRequest<DOMQuerySelectorAllResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.querySelectorAll";
/// <summary>
/// Id of the node to query upon.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Selector string.
/// </summary>
public string Selector { get; set; }}
/// <summary>
/// Response from <see cref="DOMQuerySelectorAllRequest"/>
/// </summary>
internal class DOMQuerySelectorAllResponse : IChromiumResponse
{
/// <summary>
/// Query selector result.
/// </summary>
public int[] NodeIds { get; set; }}
/// <summary>
/// Re-does the last undone action.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.redo</c>
/// </remarks>
internal class DOMRedoRequest : IChromiumRequest<DOMRedoResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.redo";
}
/// <summary>
/// Response from <see cref="DOMRedoRequest"/>
/// </summary>
internal class DOMRedoResponse : IChromiumResponse
{
}
/// <summary>
/// Removes attribute with given name from an element with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.removeAttribute</c>
/// </remarks>
internal class DOMRemoveAttributeRequest : IChromiumRequest<DOMRemoveAttributeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.removeAttribute";
/// <summary>
/// Id of the element to remove attribute from.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Name of the attribute to remove.
/// </summary>
public string Name { get; set; }}
/// <summary>
/// Response from <see cref="DOMRemoveAttributeRequest"/>
/// </summary>
internal class DOMRemoveAttributeResponse : IChromiumResponse
{
}
/// <summary>
/// Removes node with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.removeNode</c>
/// </remarks>
internal class DOMRemoveNodeRequest : IChromiumRequest<DOMRemoveNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.removeNode";
/// <summary>
/// Id of the node to remove.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMRemoveNodeRequest"/>
/// </summary>
internal class DOMRemoveNodeResponse : IChromiumResponse
{
}
/// <summary>
/// Requests that children of the node with given id are returned to the caller in form of
/// `setChildNodes` events where not only immediate children are retrieved, but all children down to
/// the specified depth.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.requestChildNodes</c>
/// </remarks>
internal class DOMRequestChildNodesRequest : IChromiumRequest<DOMRequestChildNodesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.requestChildNodes";
/// <summary>
/// Id of the node to get children for.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
/// entire subtree or provide an integer larger than 0.
/// </summary>
public int Depth { get; set; }
/// <summary>
/// Whether or not iframes and shadow roots should be traversed when returning the sub-tree
/// (default is false).
/// </summary>
public bool Pierce { get; set; }}
/// <summary>
/// Response from <see cref="DOMRequestChildNodesRequest"/>
/// </summary>
internal class DOMRequestChildNodesResponse : IChromiumResponse
{
}
/// <summary>
/// Requests that the node is sent to the caller given the JavaScript node object reference. All
/// nodes that form the path from the node to the root are also sent to the client as a series of
/// `setChildNodes` notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.requestNode</c>
/// </remarks>
internal class DOMRequestNodeRequest : IChromiumRequest<DOMRequestNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.requestNode";
/// <summary>
/// JavaScript object id to convert into node.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="DOMRequestNodeRequest"/>
/// </summary>
internal class DOMRequestNodeResponse : IChromiumResponse
{
/// <summary>
/// Node id for given object.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Resolves the JavaScript node object for a given NodeId or BackendNodeId.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.resolveNode</c>
/// </remarks>
internal class DOMResolveNodeRequest : IChromiumRequest<DOMResolveNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.resolveNode";
/// <summary>
/// Id of the node to resolve.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Backend identifier of the node to resolve.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// Symbolic group name that can be used to release multiple objects.
/// </summary>
public string ObjectGroup { get; set; }
/// <summary>
/// Execution context in which to resolve the node.
/// </summary>
public int ExecutionContextId { get; set; }}
/// <summary>
/// Response from <see cref="DOMResolveNodeRequest"/>
/// </summary>
internal class DOMResolveNodeResponse : IChromiumResponse
{
/// <summary>
/// JavaScript object wrapper for given node.
/// </summary>
public Runtime.RemoteObject Object { get; set; }}
/// <summary>
/// Sets attribute for an element with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setAttributeValue</c>
/// </remarks>
internal class DOMSetAttributeValueRequest : IChromiumRequest<DOMSetAttributeValueResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setAttributeValue";
/// <summary>
/// Id of the element to set attribute for.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Attribute name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Attribute value.
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetAttributeValueRequest"/>
/// </summary>
internal class DOMSetAttributeValueResponse : IChromiumResponse
{
}
/// <summary>
/// Sets attributes on element with given id. This method is useful when user edits some existing
/// attribute value and types in several attribute name/value pairs.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setAttributesAsText</c>
/// </remarks>
internal class DOMSetAttributesAsTextRequest : IChromiumRequest<DOMSetAttributesAsTextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setAttributesAsText";
/// <summary>
/// Id of the element to set attributes for.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Text with a number of attributes. Will parse this text using HTML parser.
/// </summary>
public string Text { get; set; }
/// <summary>
/// Attribute name to replace with new attributes derived from text in case text parsed
/// successfully.
/// </summary>
public string Name { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetAttributesAsTextRequest"/>
/// </summary>
internal class DOMSetAttributesAsTextResponse : IChromiumResponse
{
}
/// <summary>
/// Sets files for the given file input element.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setFileInputFiles</c>
/// </remarks>
internal class DOMSetFileInputFilesRequest : IChromiumRequest<DOMSetFileInputFilesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setFileInputFiles";
/// <summary>
/// Array of file paths to set.
/// </summary>
public string[] Files { get; set; }
/// <summary>
/// Identifier of the node.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Identifier of the backend node.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// JavaScript object id of the node wrapper.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetFileInputFilesRequest"/>
/// </summary>
internal class DOMSetFileInputFilesResponse : IChromiumResponse
{
}
/// <summary>
/// Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setNodeStackTracesEnabled</c>
/// </remarks>
internal class DOMSetNodeStackTracesEnabledRequest : IChromiumRequest<DOMSetNodeStackTracesEnabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setNodeStackTracesEnabled";
/// <summary>
/// Enable or disable.
/// </summary>
public bool Enable { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetNodeStackTracesEnabledRequest"/>
/// </summary>
internal class DOMSetNodeStackTracesEnabledResponse : IChromiumResponse
{
}
/// <summary>
/// Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getNodeStackTraces</c>
/// </remarks>
internal class DOMGetNodeStackTracesRequest : IChromiumRequest<DOMGetNodeStackTracesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getNodeStackTraces";
/// <summary>
/// Id of the node to get stack traces for.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetNodeStackTracesRequest"/>
/// </summary>
internal class DOMGetNodeStackTracesResponse : IChromiumResponse
{
/// <summary>
/// Creation stack trace, if available.
/// </summary>
public Runtime.StackTrace Creation { get; set; }}
/// <summary>
/// Returns file information for the given
/// File wrapper.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getFileInfo</c>
/// </remarks>
internal class DOMGetFileInfoRequest : IChromiumRequest<DOMGetFileInfoResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getFileInfo";
/// <summary>
/// JavaScript object id of the node wrapper.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetFileInfoRequest"/>
/// </summary>
internal class DOMGetFileInfoResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public string Path { get; set; }}
/// <summary>
/// Enables console to refer to the node with given id via $x (see Command Line API for more details
/// $x functions).
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setInspectedNode</c>
/// </remarks>
internal class DOMSetInspectedNodeRequest : IChromiumRequest<DOMSetInspectedNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setInspectedNode";
/// <summary>
/// DOM node id to be accessible by means of $x command line API.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetInspectedNodeRequest"/>
/// </summary>
internal class DOMSetInspectedNodeResponse : IChromiumResponse
{
}
/// <summary>
/// Sets node name for a node with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setNodeName</c>
/// </remarks>
internal class DOMSetNodeNameRequest : IChromiumRequest<DOMSetNodeNameResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setNodeName";
/// <summary>
/// Id of the node to set name for.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// New node's name.
/// </summary>
public string Name { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetNodeNameRequest"/>
/// </summary>
internal class DOMSetNodeNameResponse : IChromiumResponse
{
/// <summary>
/// New node's id.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Sets node value for a node with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setNodeValue</c>
/// </remarks>
internal class DOMSetNodeValueRequest : IChromiumRequest<DOMSetNodeValueResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setNodeValue";
/// <summary>
/// Id of the node to set value for.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// New node's value.
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetNodeValueRequest"/>
/// </summary>
internal class DOMSetNodeValueResponse : IChromiumResponse
{
}
/// <summary>
/// Sets node HTML markup, returns new node id.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.setOuterHTML</c>
/// </remarks>
internal class DOMSetOuterHTMLRequest : IChromiumRequest<DOMSetOuterHTMLResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.setOuterHTML";
/// <summary>
/// Id of the node to set markup for.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Outer HTML markup to set.
/// </summary>
public string OuterHTML { get; set; }}
/// <summary>
/// Response from <see cref="DOMSetOuterHTMLRequest"/>
/// </summary>
internal class DOMSetOuterHTMLResponse : IChromiumResponse
{
}
/// <summary>
/// Undoes the last performed action.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.undo</c>
/// </remarks>
internal class DOMUndoRequest : IChromiumRequest<DOMUndoResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.undo";
}
/// <summary>
/// Response from <see cref="DOMUndoRequest"/>
/// </summary>
internal class DOMUndoResponse : IChromiumResponse
{
}
/// <summary>
/// Returns iframe node that owns iframe with the given domain.
/// </summary>
/// <remarks>
/// Will send the command <c>DOM.getFrameOwner</c>
/// </remarks>
internal class DOMGetFrameOwnerRequest : IChromiumRequest<DOMGetFrameOwnerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOM.getFrameOwner";
/// <summary>
/// 
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Response from <see cref="DOMGetFrameOwnerRequest"/>
/// </summary>
internal class DOMGetFrameOwnerResponse : IChromiumResponse
{
/// <summary>
/// Resulting node.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// Id of the node at given coordinates, only when enabled and requested document.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Fired when `Element`'s attribute is modified.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.attributeModified</c>
/// </remarks>
internal class DOMAttributeModifiedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOM.attributeModified";
/// <summary>
/// Id of the node that has changed.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Attribute name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Attribute value.
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Fired when `Element`'s attribute is removed.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.attributeRemoved</c>
/// </remarks>
internal class DOMAttributeRemovedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOM.attributeRemoved";
/// <summary>
/// Id of the node that has changed.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// A ttribute name.
/// </summary>
public string Name { get; set; }}
/// <summary>
/// Mirrors `DOMCharacterDataModified` event.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.characterDataModified</c>
/// </remarks>
internal class DOMCharacterDataModifiedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOM.characterDataModified";
/// <summary>
/// Id of the node that has changed.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// New text value.
/// </summary>
public string CharacterData { get; set; }}
/// <summary>
/// Fired when `Container`'s child node count has changed.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.childNodeCountUpdated</c>
/// </remarks>
internal class DOMChildNodeCountUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOM.childNodeCountUpdated";
/// <summary>
/// Id of the node that has changed.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// New node count.
/// </summary>
public int ChildNodeCount { get; set; }}
/// <summary>
/// Mirrors `DOMNodeInserted` event.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.childNodeInserted</c>
/// </remarks>
internal class DOMChildNodeInsertedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOM.childNodeInserted";
/// <summary>
/// Id of the node that has changed.
/// </summary>
public int ParentNodeId { get; set; }
/// <summary>
/// If of the previous siblint.
/// </summary>
public int PreviousNodeId { get; set; }
/// <summary>
/// Inserted node data.
/// </summary>
public Node Node { get; set; }}
/// <summary>
/// Mirrors `DOMNodeRemoved` event.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.childNodeRemoved</c>
/// </remarks>
internal class DOMChildNodeRemovedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOM.childNodeRemoved";
/// <summary>
/// Parent id.
/// </summary>
public int ParentNodeId { get; set; }
/// <summary>
/// Id of the node that has been removed.
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Called when distrubution is changed.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.distributedNodesUpdated</c>
/// </remarks>
internal class DOMDistributedNodesUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOM.distributedNodesUpdated";
/// <summary>
/// Insertion point where distrubuted nodes were updated.
/// </summary>
public int InsertionPointId { get; set; }
/// <summary>
/// Distributed nodes for given insertion point.
/// </summary>
public BackendNode[] DistributedNodes { get; set; }}
/// <summary>
/// Fired when `Document` has been totally updated. Node ids are no longer valid.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.documentUpdated</c>
/// </remarks>
internal class DOMDocumentUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOM.documentUpdated";
}
/// <summary>
/// Fired when `Element`'s inline style is modified via a CSS property modification.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.inlineStyleInvalidated</c>
/// </remarks>
internal class DOMInlineStyleInvalidatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOM.inlineStyleInvalidated";
/// <summary>
/// Ids of the nodes for which the inline styles have been invalidated.
/// </summary>
public int[] NodeIds { get; set; }}
/// <summary>
/// Called when a pseudo element is added to an element.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.pseudoElementAdded</c>
/// </remarks>
internal class DOMPseudoElementAddedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOM.pseudoElementAdded";
/// <summary>
/// Pseudo element's parent element id.
/// </summary>
public int ParentId { get; set; }
/// <summary>
/// The added pseudo element.
/// </summary>
public Node PseudoElement { get; set; }}
/// <summary>
/// Called when a pseudo element is removed from an element.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.pseudoElementRemoved</c>
/// </remarks>
internal class DOMPseudoElementRemovedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOM.pseudoElementRemoved";
/// <summary>
/// Pseudo element's parent element id.
/// </summary>
public int ParentId { get; set; }
/// <summary>
/// The removed pseudo element id.
/// </summary>
public int PseudoElementId { get; set; }}
/// <summary>
/// Fired when backend wants to provide client with the missing DOM structure. This happens upon
/// most of the calls requesting node ids.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.setChildNodes</c>
/// </remarks>
internal class DOMSetChildNodesChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOM.setChildNodes";
/// <summary>
/// Parent node id to populate with children.
/// </summary>
public int ParentId { get; set; }
/// <summary>
/// Child nodes array.
/// </summary>
public Node[] Nodes { get; set; }}
/// <summary>
/// Called when shadow root is popped from the element.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.shadowRootPopped</c>
/// </remarks>
internal class DOMShadowRootPoppedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOM.shadowRootPopped";
/// <summary>
/// Host element id.
/// </summary>
public int HostId { get; set; }
/// <summary>
/// Shadow root id.
/// </summary>
public int RootId { get; set; }}
/// <summary>
/// Called when shadow root is pushed into the element.
/// </summary>
/// <remarks>
/// Matches on the event <c>DOM.shadowRootPushed</c>
/// </remarks>
internal class DOMShadowRootPushedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOM.shadowRootPushed";
/// <summary>
/// Host element id.
/// </summary>
public int HostId { get; set; }
/// <summary>
/// Shadow root.
/// </summary>
public Node Root { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.DOMDebugger
{
/// <summary>
/// DOM breakpoint type.
/// </summary>
internal enum DOMBreakpointType
{
[System.Runtime.Serialization.EnumMember(Value = "subtree-modified")]SubtreeModified,
[System.Runtime.Serialization.EnumMember(Value = "attribute-modified")]AttributeModified,
[System.Runtime.Serialization.EnumMember(Value = "node-removed")]NodeRemoved}
/// <summary>
/// Object event listener.
/// </summary>
internal class EventListener
{
/// <summary>
/// `EventListener`'s type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// `EventListener`'s useCapture.
/// </summary>
public bool UseCapture { get; set; }
/// <summary>
/// `EventListener`'s passive flag.
/// </summary>
public bool Passive { get; set; }
/// <summary>
/// `EventListener`'s once flag.
/// </summary>
public bool Once { get; set; }
/// <summary>
/// Script id of the handler code.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// Line number in the script (0-based).
/// </summary>
public int LineNumber { get; set; }
/// <summary>
/// Column number in the script (0-based).
/// </summary>
public int ColumnNumber { get; set; }
/// <summary>
/// Event handler function value.
/// </summary>
public Runtime.RemoteObject Handler { get; set; }
/// <summary>
/// Event original handler function value.
/// </summary>
public Runtime.RemoteObject OriginalHandler { get; set; }
/// <summary>
/// Node the listener is added to (if any).
/// </summary>
public int BackendNodeId { get; set; }}
/// <summary>
/// Returns event listeners of the given object.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.getEventListeners</c>
/// </remarks>
internal class DOMDebuggerGetEventListenersRequest : IChromiumRequest<DOMDebuggerGetEventListenersResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.getEventListeners";
/// <summary>
/// Identifier of the object to return listeners for.
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for the
/// entire subtree or provide an integer larger than 0.
/// </summary>
public int Depth { get; set; }
/// <summary>
/// Whether or not iframes and shadow roots should be traversed when returning the subtree
/// (default is false). Reports listeners for all contexts if pierce is enabled.
/// </summary>
public bool Pierce { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerGetEventListenersRequest"/>
/// </summary>
internal class DOMDebuggerGetEventListenersResponse : IChromiumResponse
{
/// <summary>
/// Array of relevant listeners.
/// </summary>
public EventListener[] Listeners { get; set; }}
/// <summary>
/// Removes DOM breakpoint that was set using `setDOMBreakpoint`.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.removeDOMBreakpoint</c>
/// </remarks>
internal class DOMDebuggerRemoveDOMBreakpointRequest : IChromiumRequest<DOMDebuggerRemoveDOMBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.removeDOMBreakpoint";
/// <summary>
/// Identifier of the node to remove breakpoint from.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Type of the breakpoint to remove.
/// </summary>
public DOMBreakpointType Type { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerRemoveDOMBreakpointRequest"/>
/// </summary>
internal class DOMDebuggerRemoveDOMBreakpointResponse : IChromiumResponse
{
}
/// <summary>
/// Removes breakpoint on particular DOM event.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.removeEventListenerBreakpoint</c>
/// </remarks>
internal class DOMDebuggerRemoveEventListenerBreakpointRequest : IChromiumRequest<DOMDebuggerRemoveEventListenerBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.removeEventListenerBreakpoint";
/// <summary>
/// Event name.
/// </summary>
public string EventName { get; set; }
/// <summary>
/// EventTarget interface name.
/// </summary>
public string TargetName { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerRemoveEventListenerBreakpointRequest"/>
/// </summary>
internal class DOMDebuggerRemoveEventListenerBreakpointResponse : IChromiumResponse
{
}
/// <summary>
/// Removes breakpoint on particular native event.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.removeInstrumentationBreakpoint</c>
/// </remarks>
internal class DOMDebuggerRemoveInstrumentationBreakpointRequest : IChromiumRequest<DOMDebuggerRemoveInstrumentationBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.removeInstrumentationBreakpoint";
/// <summary>
/// Instrumentation name to stop on.
/// </summary>
public string EventName { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerRemoveInstrumentationBreakpointRequest"/>
/// </summary>
internal class DOMDebuggerRemoveInstrumentationBreakpointResponse : IChromiumResponse
{
}
/// <summary>
/// Removes breakpoint from XMLHttpRequest.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.removeXHRBreakpoint</c>
/// </remarks>
internal class DOMDebuggerRemoveXHRBreakpointRequest : IChromiumRequest<DOMDebuggerRemoveXHRBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.removeXHRBreakpoint";
/// <summary>
/// Resource URL substring.
/// </summary>
public string Url { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerRemoveXHRBreakpointRequest"/>
/// </summary>
internal class DOMDebuggerRemoveXHRBreakpointResponse : IChromiumResponse
{
}
/// <summary>
/// Sets breakpoint on particular operation with DOM.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.setDOMBreakpoint</c>
/// </remarks>
internal class DOMDebuggerSetDOMBreakpointRequest : IChromiumRequest<DOMDebuggerSetDOMBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.setDOMBreakpoint";
/// <summary>
/// Identifier of the node to set breakpoint on.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Type of the operation to stop upon.
/// </summary>
public DOMBreakpointType Type { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerSetDOMBreakpointRequest"/>
/// </summary>
internal class DOMDebuggerSetDOMBreakpointResponse : IChromiumResponse
{
}
/// <summary>
/// Sets breakpoint on particular DOM event.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.setEventListenerBreakpoint</c>
/// </remarks>
internal class DOMDebuggerSetEventListenerBreakpointRequest : IChromiumRequest<DOMDebuggerSetEventListenerBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.setEventListenerBreakpoint";
/// <summary>
/// DOM Event name to stop on (any DOM event will do).
/// </summary>
public string EventName { get; set; }
/// <summary>
/// EventTarget interface name to stop on. If equal to `"*"` or not provided, will stop on any
/// EventTarget.
/// </summary>
public string TargetName { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerSetEventListenerBreakpointRequest"/>
/// </summary>
internal class DOMDebuggerSetEventListenerBreakpointResponse : IChromiumResponse
{
}
/// <summary>
/// Sets breakpoint on particular native event.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.setInstrumentationBreakpoint</c>
/// </remarks>
internal class DOMDebuggerSetInstrumentationBreakpointRequest : IChromiumRequest<DOMDebuggerSetInstrumentationBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.setInstrumentationBreakpoint";
/// <summary>
/// Instrumentation name to stop on.
/// </summary>
public string EventName { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerSetInstrumentationBreakpointRequest"/>
/// </summary>
internal class DOMDebuggerSetInstrumentationBreakpointResponse : IChromiumResponse
{
}
/// <summary>
/// Sets breakpoint on XMLHttpRequest.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMDebugger.setXHRBreakpoint</c>
/// </remarks>
internal class DOMDebuggerSetXHRBreakpointRequest : IChromiumRequest<DOMDebuggerSetXHRBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMDebugger.setXHRBreakpoint";
/// <summary>
/// Resource URL substring. All XHRs having this substring in the URL will get stopped upon.
/// </summary>
public string Url { get; set; }}
/// <summary>
/// Response from <see cref="DOMDebuggerSetXHRBreakpointRequest"/>
/// </summary>
internal class DOMDebuggerSetXHRBreakpointResponse : IChromiumResponse
{
}
}
namespace PlaywrightSharp.Chromium.Protocol.DOMSnapshot
{
/// <summary>
/// A Node in the DOM tree.
/// </summary>
internal class DOMNode
{
/// <summary>
/// `Node`'s nodeType.
/// </summary>
public int NodeType { get; set; }
/// <summary>
/// `Node`'s nodeName.
/// </summary>
public string NodeName { get; set; }
/// <summary>
/// `Node`'s nodeValue.
/// </summary>
public string NodeValue { get; set; }
/// <summary>
/// Only set for textarea elements, contains the text value.
/// </summary>
public string TextValue { get; set; }
/// <summary>
/// Only set for input elements, contains the input's associated text value.
/// </summary>
public string InputValue { get; set; }
/// <summary>
/// Only set for radio and checkbox input elements, indicates if the element has been checked
/// </summary>
public bool InputChecked { get; set; }
/// <summary>
/// Only set for option elements, indicates if the element has been selected
/// </summary>
public bool OptionSelected { get; set; }
/// <summary>
/// `Node`'s id, corresponds to DOM.Node.backendNodeId.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// The indexes of the node's child nodes in the `domNodes` array returned by `getSnapshot`, if
/// any.
/// </summary>
public int[] ChildNodeIndexes { get; set; }
/// <summary>
/// Attributes of an `Element` node.
/// </summary>
public NameValue[] Attributes { get; set; }
/// <summary>
/// Indexes of pseudo elements associated with this node in the `domNodes` array returned by
/// `getSnapshot`, if any.
/// </summary>
public int[] PseudoElementIndexes { get; set; }
/// <summary>
/// The index of the node's related layout tree node in the `layoutTreeNodes` array returned by
/// `getSnapshot`, if any.
/// </summary>
public int LayoutNodeIndex { get; set; }
/// <summary>
/// Document URL that `Document` or `FrameOwner` node points to.
/// </summary>
public string DocumentURL { get; set; }
/// <summary>
/// Base URL that `Document` or `FrameOwner` node uses for URL completion.
/// </summary>
public string BaseURL { get; set; }
/// <summary>
/// Only set for documents, contains the document's content language.
/// </summary>
public string ContentLanguage { get; set; }
/// <summary>
/// Only set for documents, contains the document's character set encoding.
/// </summary>
public string DocumentEncoding { get; set; }
/// <summary>
/// `DocumentType` node's publicId.
/// </summary>
public string PublicId { get; set; }
/// <summary>
/// `DocumentType` node's systemId.
/// </summary>
public string SystemId { get; set; }
/// <summary>
/// Frame ID for frame owner elements and also for the document node.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// The index of a frame owner element's content document in the `domNodes` array returned by
/// `getSnapshot`, if any.
/// </summary>
public int ContentDocumentIndex { get; set; }
/// <summary>
/// Type of a pseudo element node.
/// </summary>
public DOM.PseudoType PseudoType { get; set; }
/// <summary>
/// Shadow root type.
/// </summary>
public DOM.ShadowRootType ShadowRootType { get; set; }
/// <summary>
/// Whether this DOM node responds to mouse clicks. This includes nodes that have had click
/// event listeners attached via JavaScript as well as anchor tags that naturally navigate when
/// clicked.
/// </summary>
public bool IsClickable { get; set; }
/// <summary>
/// Details of the node's event listeners, if any.
/// </summary>
public DOMDebugger.EventListener[] EventListeners { get; set; }
/// <summary>
/// The selected url for nodes with a srcset attribute.
/// </summary>
public string CurrentSourceURL { get; set; }
/// <summary>
/// The url of the script (if any) that generates this node.
/// </summary>
public string OriginURL { get; set; }
/// <summary>
/// Scroll offsets, set when this node is a Document.
/// </summary>
public double ScrollOffsetX { get; set; }
/// <summary>
/// 
/// </summary>
public double ScrollOffsetY { get; set; }}
/// <summary>
/// Details of post layout rendered text positions. The exact layout should not be regarded as
/// stable and may change between versions.
/// </summary>
internal class InlineTextBox
{
/// <summary>
/// The bounding box in document coordinates. Note that scroll offset of the document is ignored.
/// </summary>
public DOM.Rect BoundingBox { get; set; }
/// <summary>
/// The starting index in characters, for this post layout textbox substring. Characters that
/// would be represented as a surrogate pair in UTF-16 have length 2.
/// </summary>
public int StartCharacterIndex { get; set; }
/// <summary>
/// The number of characters in this post layout textbox substring. Characters that would be
/// represented as a surrogate pair in UTF-16 have length 2.
/// </summary>
public int NumCharacters { get; set; }}
/// <summary>
/// Details of an element in the DOM tree with a LayoutObject.
/// </summary>
internal class LayoutTreeNode
{
/// <summary>
/// The index of the related DOM node in the `domNodes` array returned by `getSnapshot`.
/// </summary>
public int DomNodeIndex { get; set; }
/// <summary>
/// The bounding box in document coordinates. Note that scroll offset of the document is ignored.
/// </summary>
public DOM.Rect BoundingBox { get; set; }
/// <summary>
/// Contents of the LayoutText, if any.
/// </summary>
public string LayoutText { get; set; }
/// <summary>
/// The post-layout inline text nodes, if any.
/// </summary>
public InlineTextBox[] InlineTextNodes { get; set; }
/// <summary>
/// Index into the `computedStyles` array returned by `getSnapshot`.
/// </summary>
public int StyleIndex { get; set; }
/// <summary>
/// Global paint order index, which is determined by the stacking order of the nodes. Nodes
/// that are painted together will have the same index. Only provided if includePaintOrder in
/// getSnapshot was true.
/// </summary>
public int PaintOrder { get; set; }
/// <summary>
/// Set to true to indicate the element begins a new stacking context.
/// </summary>
public bool IsStackingContext { get; set; }}
/// <summary>
/// A subset of the full ComputedStyle as defined by the request whitelist.
/// </summary>
internal class ComputedStyle
{
/// <summary>
/// Name/value pairs of computed style properties.
/// </summary>
public NameValue[] Properties { get; set; }}
/// <summary>
/// A name/value pair.
/// </summary>
internal class NameValue
{
/// <summary>
/// Attribute/property name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Attribute/property value.
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Data that is only present on rare nodes.
/// </summary>
internal class RareStringData
{
/// <summary>
/// 
/// </summary>
public int[] Index { get; set; }
/// <summary>
/// 
/// </summary>
public int[] Value { get; set; }}
/// <summary>
/// 
/// </summary>
internal class RareBooleanData
{
/// <summary>
/// 
/// </summary>
public int[] Index { get; set; }}
/// <summary>
/// 
/// </summary>
internal class RareIntegerData
{
/// <summary>
/// 
/// </summary>
public int[] Index { get; set; }
/// <summary>
/// 
/// </summary>
public int[] Value { get; set; }}
/// <summary>
/// Document snapshot.
/// </summary>
internal class DocumentSnapshot
{
/// <summary>
/// Document URL that `Document` or `FrameOwner` node points to.
/// </summary>
public int DocumentURL { get; set; }
/// <summary>
/// Document title.
/// </summary>
public int Title { get; set; }
/// <summary>
/// Base URL that `Document` or `FrameOwner` node uses for URL completion.
/// </summary>
public int BaseURL { get; set; }
/// <summary>
/// Contains the document's content language.
/// </summary>
public int ContentLanguage { get; set; }
/// <summary>
/// Contains the document's character set encoding.
/// </summary>
public int EncodingName { get; set; }
/// <summary>
/// `DocumentType` node's publicId.
/// </summary>
public int PublicId { get; set; }
/// <summary>
/// `DocumentType` node's systemId.
/// </summary>
public int SystemId { get; set; }
/// <summary>
/// Frame ID for frame owner elements and also for the document node.
/// </summary>
public int FrameId { get; set; }
/// <summary>
/// A table with dom nodes.
/// </summary>
public NodeTreeSnapshot Nodes { get; set; }
/// <summary>
/// The nodes in the layout tree.
/// </summary>
public LayoutTreeSnapshot Layout { get; set; }
/// <summary>
/// The post-layout inline text nodes.
/// </summary>
public TextBoxSnapshot TextBoxes { get; set; }
/// <summary>
/// Horizontal scroll offset.
/// </summary>
public double ScrollOffsetX { get; set; }
/// <summary>
/// Vertical scroll offset.
/// </summary>
public double ScrollOffsetY { get; set; }
/// <summary>
/// Document content width.
/// </summary>
public double ContentWidth { get; set; }
/// <summary>
/// Document content height.
/// </summary>
public double ContentHeight { get; set; }}
/// <summary>
/// Table containing nodes.
/// </summary>
internal class NodeTreeSnapshot
{
/// <summary>
/// Parent node index.
/// </summary>
public int[] ParentIndex { get; set; }
/// <summary>
/// `Node`'s nodeType.
/// </summary>
public int[] NodeType { get; set; }
/// <summary>
/// `Node`'s nodeName.
/// </summary>
public int[] NodeName { get; set; }
/// <summary>
/// `Node`'s nodeValue.
/// </summary>
public int[] NodeValue { get; set; }
/// <summary>
/// `Node`'s id, corresponds to DOM.Node.backendNodeId.
/// </summary>
public int[] BackendNodeId { get; set; }
/// <summary>
/// Attributes of an `Element` node. Flatten name, value pairs.
/// </summary>
public int[][] Attributes { get; set; }
/// <summary>
/// Only set for textarea elements, contains the text value.
/// </summary>
public RareStringData TextValue { get; set; }
/// <summary>
/// Only set for input elements, contains the input's associated text value.
/// </summary>
public RareStringData InputValue { get; set; }
/// <summary>
/// Only set for radio and checkbox input elements, indicates if the element has been checked
/// </summary>
public RareBooleanData InputChecked { get; set; }
/// <summary>
/// Only set for option elements, indicates if the element has been selected
/// </summary>
public RareBooleanData OptionSelected { get; set; }
/// <summary>
/// The index of the document in the list of the snapshot documents.
/// </summary>
public RareIntegerData ContentDocumentIndex { get; set; }
/// <summary>
/// Type of a pseudo element node.
/// </summary>
public RareStringData PseudoType { get; set; }
/// <summary>
/// Whether this DOM node responds to mouse clicks. This includes nodes that have had click
/// event listeners attached via JavaScript as well as anchor tags that naturally navigate when
/// clicked.
/// </summary>
public RareBooleanData IsClickable { get; set; }
/// <summary>
/// The selected url for nodes with a srcset attribute.
/// </summary>
public RareStringData CurrentSourceURL { get; set; }
/// <summary>
/// The url of the script (if any) that generates this node.
/// </summary>
public RareStringData OriginURL { get; set; }}
/// <summary>
/// Table of details of an element in the DOM tree with a LayoutObject.
/// </summary>
internal class LayoutTreeSnapshot
{
/// <summary>
/// Index of the corresponding node in the `NodeTreeSnapshot` array returned by `captureSnapshot`.
/// </summary>
public int[] NodeIndex { get; set; }
/// <summary>
/// Array of indexes specifying computed style strings, filtered according to the `computedStyles` parameter passed to `captureSnapshot`.
/// </summary>
public int[][] Styles { get; set; }
/// <summary>
/// The absolute position bounding box.
/// </summary>
public double[][] Bounds { get; set; }
/// <summary>
/// Contents of the LayoutText, if any.
/// </summary>
public int[] Text { get; set; }
/// <summary>
/// Stacking context information.
/// </summary>
public RareBooleanData StackingContexts { get; set; }
/// <summary>
/// Global paint order index, which is determined by the stacking order of the nodes. Nodes
/// that are painted together will have the same index. Only provided if includePaintOrder in
/// captureSnapshot was true.
/// </summary>
public int[] PaintOrders { get; set; }
/// <summary>
/// The offset rect of nodes. Only available when includeDOMRects is set to true
/// </summary>
public double[][] OffsetRects { get; set; }
/// <summary>
/// The scroll rect of nodes. Only available when includeDOMRects is set to true
/// </summary>
public double[][] ScrollRects { get; set; }
/// <summary>
/// The client rect of nodes. Only available when includeDOMRects is set to true
/// </summary>
public double[][] ClientRects { get; set; }}
/// <summary>
/// Table of details of the post layout rendered text positions. The exact layout should not be regarded as
/// stable and may change between versions.
/// </summary>
internal class TextBoxSnapshot
{
/// <summary>
/// Index of the layout tree node that owns this box collection.
/// </summary>
public int[] LayoutIndex { get; set; }
/// <summary>
/// The absolute position bounding box.
/// </summary>
public double[][] Bounds { get; set; }
/// <summary>
/// The starting index in characters, for this post layout textbox substring. Characters that
/// would be represented as a surrogate pair in UTF-16 have length 2.
/// </summary>
public int[] Start { get; set; }
/// <summary>
/// The number of characters in this post layout textbox substring. Characters that would be
/// represented as a surrogate pair in UTF-16 have length 2.
/// </summary>
public int[] Length { get; set; }}
/// <summary>
/// Disables DOM snapshot agent for the given page.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMSnapshot.disable</c>
/// </remarks>
internal class DOMSnapshotDisableRequest : IChromiumRequest<DOMSnapshotDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMSnapshot.disable";
}
/// <summary>
/// Response from <see cref="DOMSnapshotDisableRequest"/>
/// </summary>
internal class DOMSnapshotDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables DOM snapshot agent for the given page.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMSnapshot.enable</c>
/// </remarks>
internal class DOMSnapshotEnableRequest : IChromiumRequest<DOMSnapshotEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMSnapshot.enable";
}
/// <summary>
/// Response from <see cref="DOMSnapshotEnableRequest"/>
/// </summary>
internal class DOMSnapshotEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Returns a document snapshot, including the full DOM tree of the root node (including iframes,
/// template contents, and imported documents) in a flattened array, as well as layout and
/// white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
/// flattened.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMSnapshot.getSnapshot</c>
/// </remarks>
internal class DOMSnapshotGetSnapshotRequest : IChromiumRequest<DOMSnapshotGetSnapshotResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMSnapshot.getSnapshot";
/// <summary>
/// Whitelist of computed styles to return.
/// </summary>
public string[] ComputedStyleWhitelist { get; set; }
/// <summary>
/// Whether or not to retrieve details of DOM listeners (default false).
/// </summary>
public bool IncludeEventListeners { get; set; }
/// <summary>
/// Whether to determine and include the paint order index of LayoutTreeNodes (default false).
/// </summary>
public bool IncludePaintOrder { get; set; }
/// <summary>
/// Whether to include UA shadow tree in the snapshot (default false).
/// </summary>
public bool IncludeUserAgentShadowTree { get; set; }}
/// <summary>
/// Response from <see cref="DOMSnapshotGetSnapshotRequest"/>
/// </summary>
internal class DOMSnapshotGetSnapshotResponse : IChromiumResponse
{
/// <summary>
/// The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
/// </summary>
public DOMNode[] DomNodes { get; set; }
/// <summary>
/// The nodes in the layout tree.
/// </summary>
public LayoutTreeNode[] LayoutTreeNodes { get; set; }
/// <summary>
/// Whitelisted ComputedStyle properties for each node in the layout tree.
/// </summary>
public ComputedStyle[] ComputedStyles { get; set; }}
/// <summary>
/// Returns a document snapshot, including the full DOM tree of the root node (including iframes,
/// template contents, and imported documents) in a flattened array, as well as layout and
/// white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
/// flattened.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMSnapshot.captureSnapshot</c>
/// </remarks>
internal class DOMSnapshotCaptureSnapshotRequest : IChromiumRequest<DOMSnapshotCaptureSnapshotResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMSnapshot.captureSnapshot";
/// <summary>
/// Whitelist of computed styles to return.
/// </summary>
public string[] ComputedStyles { get; set; }
/// <summary>
/// Whether to include layout object paint orders into the snapshot.
/// </summary>
public bool IncludePaintOrder { get; set; }
/// <summary>
/// Whether to include DOM rectangles (offsetRects, clientRects, scrollRects) into the snapshot
/// </summary>
public bool IncludeDOMRects { get; set; }}
/// <summary>
/// Response from <see cref="DOMSnapshotCaptureSnapshotRequest"/>
/// </summary>
internal class DOMSnapshotCaptureSnapshotResponse : IChromiumResponse
{
/// <summary>
/// The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
/// </summary>
public DocumentSnapshot[] Documents { get; set; }
/// <summary>
/// Shared string table that all string properties refer to with indexes.
/// </summary>
public string[] Strings { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.DOMStorage
{
/// <summary>
/// DOM Storage identifier.
/// </summary>
internal class StorageId
{
/// <summary>
/// Security origin for the storage.
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// Whether the storage is local storage (not session storage).
/// </summary>
public bool IsLocalStorage { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>DOMStorage.clear</c>
/// </remarks>
internal class DOMStorageClearRequest : IChromiumRequest<DOMStorageClearResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMStorage.clear";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }}
/// <summary>
/// Response from <see cref="DOMStorageClearRequest"/>
/// </summary>
internal class DOMStorageClearResponse : IChromiumResponse
{
}
/// <summary>
/// Disables storage tracking, prevents storage events from being sent to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMStorage.disable</c>
/// </remarks>
internal class DOMStorageDisableRequest : IChromiumRequest<DOMStorageDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMStorage.disable";
}
/// <summary>
/// Response from <see cref="DOMStorageDisableRequest"/>
/// </summary>
internal class DOMStorageDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables storage tracking, storage events will now be delivered to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>DOMStorage.enable</c>
/// </remarks>
internal class DOMStorageEnableRequest : IChromiumRequest<DOMStorageEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMStorage.enable";
}
/// <summary>
/// Response from <see cref="DOMStorageEnableRequest"/>
/// </summary>
internal class DOMStorageEnableResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>DOMStorage.getDOMStorageItems</c>
/// </remarks>
internal class DOMStorageGetDOMStorageItemsRequest : IChromiumRequest<DOMStorageGetDOMStorageItemsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMStorage.getDOMStorageItems";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }}
/// <summary>
/// Response from <see cref="DOMStorageGetDOMStorageItemsRequest"/>
/// </summary>
internal class DOMStorageGetDOMStorageItemsResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public string[][] Entries { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>DOMStorage.removeDOMStorageItem</c>
/// </remarks>
internal class DOMStorageRemoveDOMStorageItemRequest : IChromiumRequest<DOMStorageRemoveDOMStorageItemResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMStorage.removeDOMStorageItem";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }
/// <summary>
/// 
/// </summary>
public string Key { get; set; }}
/// <summary>
/// Response from <see cref="DOMStorageRemoveDOMStorageItemRequest"/>
/// </summary>
internal class DOMStorageRemoveDOMStorageItemResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>DOMStorage.setDOMStorageItem</c>
/// </remarks>
internal class DOMStorageSetDOMStorageItemRequest : IChromiumRequest<DOMStorageSetDOMStorageItemResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DOMStorage.setDOMStorageItem";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }
/// <summary>
/// 
/// </summary>
public string Key { get; set; }
/// <summary>
/// 
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Response from <see cref="DOMStorageSetDOMStorageItemRequest"/>
/// </summary>
internal class DOMStorageSetDOMStorageItemResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>DOMStorage.domStorageItemAdded</c>
/// </remarks>
internal class DOMStorageDomStorageItemAddedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOMStorage.domStorageItemAdded";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }
/// <summary>
/// 
/// </summary>
public string Key { get; set; }
/// <summary>
/// 
/// </summary>
public string NewValue { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>DOMStorage.domStorageItemRemoved</c>
/// </remarks>
internal class DOMStorageDomStorageItemRemovedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOMStorage.domStorageItemRemoved";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }
/// <summary>
/// 
/// </summary>
public string Key { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>DOMStorage.domStorageItemUpdated</c>
/// </remarks>
internal class DOMStorageDomStorageItemUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOMStorage.domStorageItemUpdated";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }
/// <summary>
/// 
/// </summary>
public string Key { get; set; }
/// <summary>
/// 
/// </summary>
public string OldValue { get; set; }
/// <summary>
/// 
/// </summary>
public string NewValue { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>DOMStorage.domStorageItemsCleared</c>
/// </remarks>
internal class DOMStorageDomStorageItemsClearedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "DOMStorage.domStorageItemsCleared";
/// <summary>
/// 
/// </summary>
public StorageId StorageId { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Database
{
/// <summary>
/// Database object.
/// </summary>
internal class Database
{
/// <summary>
/// Database ID.
/// </summary>
public string Id { get; set; }
/// <summary>
/// Database domain.
/// </summary>
public string Domain { get; set; }
/// <summary>
/// Database name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Database version.
/// </summary>
public string Version { get; set; }}
/// <summary>
/// Database error.
/// </summary>
internal class Error
{
/// <summary>
/// Error message.
/// </summary>
public string Message { get; set; }
/// <summary>
/// Error code.
/// </summary>
public int Code { get; set; }}
/// <summary>
/// Disables database tracking, prevents database events from being sent to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>Database.disable</c>
/// </remarks>
internal class DatabaseDisableRequest : IChromiumRequest<DatabaseDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Database.disable";
}
/// <summary>
/// Response from <see cref="DatabaseDisableRequest"/>
/// </summary>
internal class DatabaseDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables database tracking, database events will now be delivered to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>Database.enable</c>
/// </remarks>
internal class DatabaseEnableRequest : IChromiumRequest<DatabaseEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Database.enable";
}
/// <summary>
/// Response from <see cref="DatabaseEnableRequest"/>
/// </summary>
internal class DatabaseEnableResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Database.executeSQL</c>
/// </remarks>
internal class DatabaseExecuteSQLRequest : IChromiumRequest<DatabaseExecuteSQLResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Database.executeSQL";
/// <summary>
/// 
/// </summary>
public string DatabaseId { get; set; }
/// <summary>
/// 
/// </summary>
public string Query { get; set; }}
/// <summary>
/// Response from <see cref="DatabaseExecuteSQLRequest"/>
/// </summary>
internal class DatabaseExecuteSQLResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public string[] ColumnNames { get; set; }
/// <summary>
/// 
/// </summary>
public JsonElement?[] Values { get; set; }
/// <summary>
/// 
/// </summary>
public Error SqlError { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Database.getDatabaseTableNames</c>
/// </remarks>
internal class DatabaseGetDatabaseTableNamesRequest : IChromiumRequest<DatabaseGetDatabaseTableNamesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Database.getDatabaseTableNames";
/// <summary>
/// 
/// </summary>
public string DatabaseId { get; set; }}
/// <summary>
/// Response from <see cref="DatabaseGetDatabaseTableNamesRequest"/>
/// </summary>
internal class DatabaseGetDatabaseTableNamesResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public string[] TableNames { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Database.addDatabase</c>
/// </remarks>
internal class DatabaseAddDatabaseChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Database.addDatabase";
/// <summary>
/// 
/// </summary>
public Database Database { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.DeviceOrientation
{
/// <summary>
/// Clears the overridden Device Orientation.
/// </summary>
/// <remarks>
/// Will send the command <c>DeviceOrientation.clearDeviceOrientationOverride</c>
/// </remarks>
internal class DeviceOrientationClearDeviceOrientationOverrideRequest : IChromiumRequest<DeviceOrientationClearDeviceOrientationOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DeviceOrientation.clearDeviceOrientationOverride";
}
/// <summary>
/// Response from <see cref="DeviceOrientationClearDeviceOrientationOverrideRequest"/>
/// </summary>
internal class DeviceOrientationClearDeviceOrientationOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// Overrides the Device Orientation.
/// </summary>
/// <remarks>
/// Will send the command <c>DeviceOrientation.setDeviceOrientationOverride</c>
/// </remarks>
internal class DeviceOrientationSetDeviceOrientationOverrideRequest : IChromiumRequest<DeviceOrientationSetDeviceOrientationOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "DeviceOrientation.setDeviceOrientationOverride";
/// <summary>
/// Mock alpha
/// </summary>
public double Alpha { get; set; }
/// <summary>
/// Mock beta
/// </summary>
public double Beta { get; set; }
/// <summary>
/// Mock gamma
/// </summary>
public double Gamma { get; set; }}
/// <summary>
/// Response from <see cref="DeviceOrientationSetDeviceOrientationOverrideRequest"/>
/// </summary>
internal class DeviceOrientationSetDeviceOrientationOverrideResponse : IChromiumResponse
{
}
}
namespace PlaywrightSharp.Chromium.Protocol.Emulation
{
/// <summary>
/// Screen orientation.
/// </summary>
internal class ScreenOrientation
{
/// <summary>
/// Orientation type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Orientation angle.
/// </summary>
public int Angle { get; set; }}
/// <summary>
/// 
/// </summary>
internal class MediaFeature
{
/// <summary>
/// 
/// </summary>
public string Name { get; set; }
/// <summary>
/// 
/// </summary>
public string Value { get; set; }}
/// <summary>
/// advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to
/// allow the next delayed task (if any) to run; pause: The virtual time base may not advance;
/// pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending
/// resource fetches.
/// </summary>
internal enum VirtualTimePolicy
{
[System.Runtime.Serialization.EnumMember(Value = "advance")]Advance,
[System.Runtime.Serialization.EnumMember(Value = "pause")]Pause,
[System.Runtime.Serialization.EnumMember(Value = "pauseIfNetworkFetchesPending")]PauseIfNetworkFetchesPending}
/// <summary>
/// Tells whether emulation is supported.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.canEmulate</c>
/// </remarks>
internal class EmulationCanEmulateRequest : IChromiumRequest<EmulationCanEmulateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.canEmulate";
}
/// <summary>
/// Response from <see cref="EmulationCanEmulateRequest"/>
/// </summary>
internal class EmulationCanEmulateResponse : IChromiumResponse
{
/// <summary>
/// True if emulation is supported.
/// </summary>
public bool Result { get; set; }}
/// <summary>
/// Clears the overriden device metrics.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.clearDeviceMetricsOverride</c>
/// </remarks>
internal class EmulationClearDeviceMetricsOverrideRequest : IChromiumRequest<EmulationClearDeviceMetricsOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.clearDeviceMetricsOverride";
}
/// <summary>
/// Response from <see cref="EmulationClearDeviceMetricsOverrideRequest"/>
/// </summary>
internal class EmulationClearDeviceMetricsOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// Clears the overriden Geolocation Position and Error.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.clearGeolocationOverride</c>
/// </remarks>
internal class EmulationClearGeolocationOverrideRequest : IChromiumRequest<EmulationClearGeolocationOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.clearGeolocationOverride";
}
/// <summary>
/// Response from <see cref="EmulationClearGeolocationOverrideRequest"/>
/// </summary>
internal class EmulationClearGeolocationOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// Requests that page scale factor is reset to initial values.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.resetPageScaleFactor</c>
/// </remarks>
internal class EmulationResetPageScaleFactorRequest : IChromiumRequest<EmulationResetPageScaleFactorResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.resetPageScaleFactor";
}
/// <summary>
/// Response from <see cref="EmulationResetPageScaleFactorRequest"/>
/// </summary>
internal class EmulationResetPageScaleFactorResponse : IChromiumResponse
{
}
/// <summary>
/// Enables or disables simulating a focused and active page.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setFocusEmulationEnabled</c>
/// </remarks>
internal class EmulationSetFocusEmulationEnabledRequest : IChromiumRequest<EmulationSetFocusEmulationEnabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setFocusEmulationEnabled";
/// <summary>
/// Whether to enable to disable focus emulation.
/// </summary>
public bool Enabled { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetFocusEmulationEnabledRequest"/>
/// </summary>
internal class EmulationSetFocusEmulationEnabledResponse : IChromiumResponse
{
}
/// <summary>
/// Enables CPU throttling to emulate slow CPUs.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setCPUThrottlingRate</c>
/// </remarks>
internal class EmulationSetCPUThrottlingRateRequest : IChromiumRequest<EmulationSetCPUThrottlingRateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setCPUThrottlingRate";
/// <summary>
/// Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).
/// </summary>
public double Rate { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetCPUThrottlingRateRequest"/>
/// </summary>
internal class EmulationSetCPUThrottlingRateResponse : IChromiumResponse
{
}
/// <summary>
/// Sets or clears an override of the default background color of the frame. This override is used
/// if the content does not specify one.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setDefaultBackgroundColorOverride</c>
/// </remarks>
internal class EmulationSetDefaultBackgroundColorOverrideRequest : IChromiumRequest<EmulationSetDefaultBackgroundColorOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setDefaultBackgroundColorOverride";
/// <summary>
/// RGBA of the default background color. If not specified, any existing override will be
/// cleared.
/// </summary>
public DOM.RGBA Color { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetDefaultBackgroundColorOverrideRequest"/>
/// </summary>
internal class EmulationSetDefaultBackgroundColorOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
/// window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
/// query results).
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setDeviceMetricsOverride</c>
/// </remarks>
internal class EmulationSetDeviceMetricsOverrideRequest : IChromiumRequest<EmulationSetDeviceMetricsOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setDeviceMetricsOverride";
/// <summary>
/// Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
/// </summary>
public int Width { get; set; }
/// <summary>
/// Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
/// </summary>
public int Height { get; set; }
/// <summary>
/// Overriding device scale factor value. 0 disables the override.
/// </summary>
public double DeviceScaleFactor { get; set; }
/// <summary>
/// Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text
/// autosizing and more.
/// </summary>
public bool Mobile { get; set; }
/// <summary>
/// Scale to apply to resulting view image.
/// </summary>
public double Scale { get; set; }
/// <summary>
/// Overriding screen width value in pixels (minimum 0, maximum 10000000).
/// </summary>
public int ScreenWidth { get; set; }
/// <summary>
/// Overriding screen height value in pixels (minimum 0, maximum 10000000).
/// </summary>
public int ScreenHeight { get; set; }
/// <summary>
/// Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
/// </summary>
public int PositionX { get; set; }
/// <summary>
/// Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
/// </summary>
public int PositionY { get; set; }
/// <summary>
/// Do not set visible view size, rely upon explicit setVisibleSize call.
/// </summary>
public bool DontSetVisibleSize { get; set; }
/// <summary>
/// Screen orientation override.
/// </summary>
public ScreenOrientation ScreenOrientation { get; set; }
/// <summary>
/// If set, the visible area of the page will be overridden to this viewport. This viewport
/// change is not observed by the page, e.g. viewport-relative elements do not change positions.
/// </summary>
public Page.Viewport Viewport { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetDeviceMetricsOverrideRequest"/>
/// </summary>
internal class EmulationSetDeviceMetricsOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setScrollbarsHidden</c>
/// </remarks>
internal class EmulationSetScrollbarsHiddenRequest : IChromiumRequest<EmulationSetScrollbarsHiddenResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setScrollbarsHidden";
/// <summary>
/// Whether scrollbars should be always hidden.
/// </summary>
public bool Hidden { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetScrollbarsHiddenRequest"/>
/// </summary>
internal class EmulationSetScrollbarsHiddenResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setDocumentCookieDisabled</c>
/// </remarks>
internal class EmulationSetDocumentCookieDisabledRequest : IChromiumRequest<EmulationSetDocumentCookieDisabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setDocumentCookieDisabled";
/// <summary>
/// Whether document.coookie API should be disabled.
/// </summary>
public bool Disabled { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetDocumentCookieDisabledRequest"/>
/// </summary>
internal class EmulationSetDocumentCookieDisabledResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setEmitTouchEventsForMouse</c>
/// </remarks>
internal class EmulationSetEmitTouchEventsForMouseRequest : IChromiumRequest<EmulationSetEmitTouchEventsForMouseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setEmitTouchEventsForMouse";
/// <summary>
/// Whether touch emulation based on mouse input should be enabled.
/// </summary>
public bool Enabled { get; set; }
/// <summary>
/// Touch/gesture events configuration. Default: current platform.
/// </summary>
public string Configuration { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetEmitTouchEventsForMouseRequest"/>
/// </summary>
internal class EmulationSetEmitTouchEventsForMouseResponse : IChromiumResponse
{
}
/// <summary>
/// Emulates the given media type or media feature for CSS media queries.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setEmulatedMedia</c>
/// </remarks>
internal class EmulationSetEmulatedMediaRequest : IChromiumRequest<EmulationSetEmulatedMediaResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setEmulatedMedia";
/// <summary>
/// Media type to emulate. Empty string disables the override.
/// </summary>
public string Media { get; set; }
/// <summary>
/// Media features to emulate.
/// </summary>
public MediaFeature[] Features { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetEmulatedMediaRequest"/>
/// </summary>
internal class EmulationSetEmulatedMediaResponse : IChromiumResponse
{
}
/// <summary>
/// Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
/// unavailable.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setGeolocationOverride</c>
/// </remarks>
internal class EmulationSetGeolocationOverrideRequest : IChromiumRequest<EmulationSetGeolocationOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setGeolocationOverride";
/// <summary>
/// Mock latitude
/// </summary>
public double Latitude { get; set; }
/// <summary>
/// Mock longitude
/// </summary>
public double Longitude { get; set; }
/// <summary>
/// Mock accuracy
/// </summary>
public double Accuracy { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetGeolocationOverrideRequest"/>
/// </summary>
internal class EmulationSetGeolocationOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// Overrides value returned by the javascript navigator object.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setNavigatorOverrides</c>
/// </remarks>
internal class EmulationSetNavigatorOverridesRequest : IChromiumRequest<EmulationSetNavigatorOverridesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setNavigatorOverrides";
/// <summary>
/// The platform navigator.platform should return.
/// </summary>
public string Platform { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetNavigatorOverridesRequest"/>
/// </summary>
internal class EmulationSetNavigatorOverridesResponse : IChromiumResponse
{
}
/// <summary>
/// Sets a specified page scale factor.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setPageScaleFactor</c>
/// </remarks>
internal class EmulationSetPageScaleFactorRequest : IChromiumRequest<EmulationSetPageScaleFactorResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setPageScaleFactor";
/// <summary>
/// Page scale factor.
/// </summary>
public double PageScaleFactor { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetPageScaleFactorRequest"/>
/// </summary>
internal class EmulationSetPageScaleFactorResponse : IChromiumResponse
{
}
/// <summary>
/// Switches script execution in the page.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setScriptExecutionDisabled</c>
/// </remarks>
internal class EmulationSetScriptExecutionDisabledRequest : IChromiumRequest<EmulationSetScriptExecutionDisabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setScriptExecutionDisabled";
/// <summary>
/// Whether script execution should be disabled in the page.
/// </summary>
public bool Value { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetScriptExecutionDisabledRequest"/>
/// </summary>
internal class EmulationSetScriptExecutionDisabledResponse : IChromiumResponse
{
}
/// <summary>
/// Enables touch on platforms which do not support them.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setTouchEmulationEnabled</c>
/// </remarks>
internal class EmulationSetTouchEmulationEnabledRequest : IChromiumRequest<EmulationSetTouchEmulationEnabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setTouchEmulationEnabled";
/// <summary>
/// Whether the touch event emulation should be enabled.
/// </summary>
public bool Enabled { get; set; }
/// <summary>
/// Maximum touch points supported. Defaults to one.
/// </summary>
public int MaxTouchPoints { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetTouchEmulationEnabledRequest"/>
/// </summary>
internal class EmulationSetTouchEmulationEnabledResponse : IChromiumResponse
{
}
/// <summary>
/// Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
/// the current virtual time policy.  Note this supersedes any previous time budget.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setVirtualTimePolicy</c>
/// </remarks>
internal class EmulationSetVirtualTimePolicyRequest : IChromiumRequest<EmulationSetVirtualTimePolicyResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setVirtualTimePolicy";
/// <summary>
/// 
/// </summary>
public VirtualTimePolicy Policy { get; set; }
/// <summary>
/// If set, after this many virtual milliseconds have elapsed virtual time will be paused and a
/// virtualTimeBudgetExpired event is sent.
/// </summary>
public double Budget { get; set; }
/// <summary>
/// If set this specifies the maximum number of tasks that can be run before virtual is forced
/// forwards to prevent deadlock.
/// </summary>
public int MaxVirtualTimeTaskStarvationCount { get; set; }
/// <summary>
/// If set the virtual time policy change should be deferred until any frame starts navigating.
/// Note any previous deferred policy change is superseded.
/// </summary>
public bool WaitForNavigation { get; set; }
/// <summary>
/// If set, base::Time::Now will be overriden to initially return this value.
/// </summary>
public double InitialVirtualTime { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetVirtualTimePolicyRequest"/>
/// </summary>
internal class EmulationSetVirtualTimePolicyResponse : IChromiumResponse
{
/// <summary>
/// Absolute timestamp at which virtual time was first enabled (up time in milliseconds).
/// </summary>
public double VirtualTimeTicksBase { get; set; }}
/// <summary>
/// Overrides default host system timezone with the specified one.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setTimezoneOverride</c>
/// </remarks>
internal class EmulationSetTimezoneOverrideRequest : IChromiumRequest<EmulationSetTimezoneOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setTimezoneOverride";
/// <summary>
/// The timezone identifier. If empty, disables the override and
/// restores default host system timezone.
/// </summary>
public string TimezoneId { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetTimezoneOverrideRequest"/>
/// </summary>
internal class EmulationSetTimezoneOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// Resizes the frame/viewport of the page. Note that this does not affect the frame's container
/// (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
/// on Android.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setVisibleSize</c>
/// </remarks>
internal class EmulationSetVisibleSizeRequest : IChromiumRequest<EmulationSetVisibleSizeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setVisibleSize";
/// <summary>
/// Frame width (DIP).
/// </summary>
public int Width { get; set; }
/// <summary>
/// Frame height (DIP).
/// </summary>
public int Height { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetVisibleSizeRequest"/>
/// </summary>
internal class EmulationSetVisibleSizeResponse : IChromiumResponse
{
}
/// <summary>
/// Allows overriding user agent with the given string.
/// </summary>
/// <remarks>
/// Will send the command <c>Emulation.setUserAgentOverride</c>
/// </remarks>
internal class EmulationSetUserAgentOverrideRequest : IChromiumRequest<EmulationSetUserAgentOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Emulation.setUserAgentOverride";
/// <summary>
/// User agent to use.
/// </summary>
public string UserAgent { get; set; }
/// <summary>
/// Browser langugage to emulate.
/// </summary>
public string AcceptLanguage { get; set; }
/// <summary>
/// The platform navigator.platform should return.
/// </summary>
public string Platform { get; set; }}
/// <summary>
/// Response from <see cref="EmulationSetUserAgentOverrideRequest"/>
/// </summary>
internal class EmulationSetUserAgentOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// Notification sent after the virtual time budget for the current VirtualTimePolicy has run out.
/// </summary>
/// <remarks>
/// Matches on the event <c>Emulation.virtualTimeBudgetExpired</c>
/// </remarks>
internal class EmulationVirtualTimeBudgetExpiredChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Emulation.virtualTimeBudgetExpired";
}
}
namespace PlaywrightSharp.Chromium.Protocol.HeadlessExperimental
{
/// <summary>
/// Encoding options for a screenshot.
/// </summary>
internal class ScreenshotParams
{
/// <summary>
/// Image compression format (defaults to png).
/// </summary>
public string Format { get; set; }
/// <summary>
/// Compression quality from range [0..100] (jpeg only).
/// </summary>
public int Quality { get; set; }}
/// <summary>
/// Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
/// screenshot from the resulting frame. Requires that the target was created with enabled
/// BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
/// https://goo.gl/3zHXhB for more background.
/// </summary>
/// <remarks>
/// Will send the command <c>HeadlessExperimental.beginFrame</c>
/// </remarks>
internal class HeadlessExperimentalBeginFrameRequest : IChromiumRequest<HeadlessExperimentalBeginFrameResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeadlessExperimental.beginFrame";
/// <summary>
/// Timestamp of this BeginFrame in Renderer TimeTicks (milliseconds of uptime). If not set,
/// the current time will be used.
/// </summary>
public double FrameTimeTicks { get; set; }
/// <summary>
/// The interval between BeginFrames that is reported to the compositor, in milliseconds.
/// Defaults to a 60 frames/second interval, i.e. about 16.666 milliseconds.
/// </summary>
public double Interval { get; set; }
/// <summary>
/// Whether updates should not be committed and drawn onto the display. False by default. If
/// true, only side effects of the BeginFrame will be run, such as layout and animations, but
/// any visual updates may not be visible on the display or in screenshots.
/// </summary>
public bool NoDisplayUpdates { get; set; }
/// <summary>
/// If set, a screenshot of the frame will be captured and returned in the response. Otherwise,
/// no screenshot will be captured. Note that capturing a screenshot can fail, for example,
/// during renderer initialization. In such a case, no screenshot data will be returned.
/// </summary>
public ScreenshotParams Screenshot { get; set; }}
/// <summary>
/// Response from <see cref="HeadlessExperimentalBeginFrameRequest"/>
/// </summary>
internal class HeadlessExperimentalBeginFrameResponse : IChromiumResponse
{
/// <summary>
/// Whether the BeginFrame resulted in damage and, thus, a new frame was committed to the
/// display. Reported for diagnostic uses, may be removed in the future.
/// </summary>
public bool HasDamage { get; set; }
/// <summary>
/// Base64-encoded image data of the screenshot, if one was requested and successfully taken.
/// </summary>
public byte[] ScreenshotData { get; set; }}
/// <summary>
/// Disables headless events for the target.
/// </summary>
/// <remarks>
/// Will send the command <c>HeadlessExperimental.disable</c>
/// </remarks>
internal class HeadlessExperimentalDisableRequest : IChromiumRequest<HeadlessExperimentalDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeadlessExperimental.disable";
}
/// <summary>
/// Response from <see cref="HeadlessExperimentalDisableRequest"/>
/// </summary>
internal class HeadlessExperimentalDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables headless events for the target.
/// </summary>
/// <remarks>
/// Will send the command <c>HeadlessExperimental.enable</c>
/// </remarks>
internal class HeadlessExperimentalEnableRequest : IChromiumRequest<HeadlessExperimentalEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeadlessExperimental.enable";
}
/// <summary>
/// Response from <see cref="HeadlessExperimentalEnableRequest"/>
/// </summary>
internal class HeadlessExperimentalEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Issued when the target starts or stops needing BeginFrames.
/// Deprecated. Issue beginFrame unconditionally instead and use result from
/// beginFrame to detect whether the frames were suppressed.
/// </summary>
/// <remarks>
/// Matches on the event <c>HeadlessExperimental.needsBeginFramesChanged</c>
/// </remarks>
internal class HeadlessExperimentalNeedsBeginFramesChangedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "HeadlessExperimental.needsBeginFramesChanged";
/// <summary>
/// True if BeginFrames are needed, false otherwise.
/// </summary>
public bool NeedsBeginFrames { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.IO
{
/// <summary>
/// Close the stream, discard any temporary backing storage.
/// </summary>
/// <remarks>
/// Will send the command <c>IO.close</c>
/// </remarks>
internal class IOCloseRequest : IChromiumRequest<IOCloseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IO.close";
/// <summary>
/// Handle of the stream to close.
/// </summary>
public string Handle { get; set; }}
/// <summary>
/// Response from <see cref="IOCloseRequest"/>
/// </summary>
internal class IOCloseResponse : IChromiumResponse
{
}
/// <summary>
/// Read a chunk of the stream
/// </summary>
/// <remarks>
/// Will send the command <c>IO.read</c>
/// </remarks>
internal class IOReadRequest : IChromiumRequest<IOReadResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IO.read";
/// <summary>
/// Handle of the stream to read.
/// </summary>
public string Handle { get; set; }
/// <summary>
/// Seek to the specified offset before reading (if not specificed, proceed with offset
/// following the last read). Some types of streams may only support sequential reads.
/// </summary>
public int Offset { get; set; }
/// <summary>
/// Maximum number of bytes to read (left upon the agent discretion if not specified).
/// </summary>
public int Size { get; set; }}
/// <summary>
/// Response from <see cref="IOReadRequest"/>
/// </summary>
internal class IOReadResponse : IChromiumResponse
{
/// <summary>
/// Set if the data is base64-encoded
/// </summary>
public bool Base64Encoded { get; set; }
/// <summary>
/// Data that were read.
/// </summary>
public string Data { get; set; }
/// <summary>
/// Set if the end-of-file condition occured while reading.
/// </summary>
public bool Eof { get; set; }}
/// <summary>
/// Return UUID of Blob object specified by a remote object id.
/// </summary>
/// <remarks>
/// Will send the command <c>IO.resolveBlob</c>
/// </remarks>
internal class IOResolveBlobRequest : IChromiumRequest<IOResolveBlobResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IO.resolveBlob";
/// <summary>
/// Object id of a Blob object wrapper.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="IOResolveBlobRequest"/>
/// </summary>
internal class IOResolveBlobResponse : IChromiumResponse
{
/// <summary>
/// UUID of the specified Blob.
/// </summary>
public string Uuid { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.IndexedDB
{
/// <summary>
/// Database with an array of object stores.
/// </summary>
internal class DatabaseWithObjectStores
{
/// <summary>
/// Database name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Database version (type is not 'integer', as the standard
/// requires the version number to be 'unsigned long long')
/// </summary>
public double Version { get; set; }
/// <summary>
/// Object stores in this database.
/// </summary>
public ObjectStore[] ObjectStores { get; set; }}
/// <summary>
/// Object store.
/// </summary>
internal class ObjectStore
{
/// <summary>
/// Object store name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Object store key path.
/// </summary>
public KeyPath KeyPath { get; set; }
/// <summary>
/// If true, object store has auto increment flag set.
/// </summary>
public bool AutoIncrement { get; set; }
/// <summary>
/// Indexes in this object store.
/// </summary>
public ObjectStoreIndex[] Indexes { get; set; }}
/// <summary>
/// Object store index.
/// </summary>
internal class ObjectStoreIndex
{
/// <summary>
/// Index name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Index key path.
/// </summary>
public KeyPath KeyPath { get; set; }
/// <summary>
/// If true, index is unique.
/// </summary>
public bool Unique { get; set; }
/// <summary>
/// If true, index allows multiple entries for a key.
/// </summary>
public bool MultiEntry { get; set; }}
/// <summary>
/// Key.
/// </summary>
internal class Key
{
/// <summary>
/// Key type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Number value.
/// </summary>
public double Number { get; set; }
/// <summary>
/// String value.
/// </summary>
public string String { get; set; }
/// <summary>
/// Date value.
/// </summary>
public double Date { get; set; }
/// <summary>
/// Array value.
/// </summary>
public Key[] Array { get; set; }}
/// <summary>
/// Key range.
/// </summary>
internal class KeyRange
{
/// <summary>
/// Lower bound.
/// </summary>
public Key Lower { get; set; }
/// <summary>
/// Upper bound.
/// </summary>
public Key Upper { get; set; }
/// <summary>
/// If true lower bound is open.
/// </summary>
public bool LowerOpen { get; set; }
/// <summary>
/// If true upper bound is open.
/// </summary>
public bool UpperOpen { get; set; }}
/// <summary>
/// Data entry.
/// </summary>
internal class DataEntry
{
/// <summary>
/// Key object.
/// </summary>
public Runtime.RemoteObject Key { get; set; }
/// <summary>
/// Primary key object.
/// </summary>
public Runtime.RemoteObject PrimaryKey { get; set; }
/// <summary>
/// Value object.
/// </summary>
public Runtime.RemoteObject Value { get; set; }}
/// <summary>
/// Key path.
/// </summary>
internal class KeyPath
{
/// <summary>
/// Key path type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// String value.
/// </summary>
public string String { get; set; }
/// <summary>
/// Array value.
/// </summary>
public string[] Array { get; set; }}
/// <summary>
/// Clears all entries from an object store.
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.clearObjectStore</c>
/// </remarks>
internal class IndexedDBClearObjectStoreRequest : IChromiumRequest<IndexedDBClearObjectStoreResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.clearObjectStore";
/// <summary>
/// Security origin.
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// Database name.
/// </summary>
public string DatabaseName { get; set; }
/// <summary>
/// Object store name.
/// </summary>
public string ObjectStoreName { get; set; }}
/// <summary>
/// Response from <see cref="IndexedDBClearObjectStoreRequest"/>
/// </summary>
internal class IndexedDBClearObjectStoreResponse : IChromiumResponse
{
}
/// <summary>
/// Deletes a database.
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.deleteDatabase</c>
/// </remarks>
internal class IndexedDBDeleteDatabaseRequest : IChromiumRequest<IndexedDBDeleteDatabaseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.deleteDatabase";
/// <summary>
/// Security origin.
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// Database name.
/// </summary>
public string DatabaseName { get; set; }}
/// <summary>
/// Response from <see cref="IndexedDBDeleteDatabaseRequest"/>
/// </summary>
internal class IndexedDBDeleteDatabaseResponse : IChromiumResponse
{
}
/// <summary>
/// Delete a range of entries from an object store
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.deleteObjectStoreEntries</c>
/// </remarks>
internal class IndexedDBDeleteObjectStoreEntriesRequest : IChromiumRequest<IndexedDBDeleteObjectStoreEntriesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.deleteObjectStoreEntries";
/// <summary>
/// 
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// 
/// </summary>
public string DatabaseName { get; set; }
/// <summary>
/// 
/// </summary>
public string ObjectStoreName { get; set; }
/// <summary>
/// Range of entry keys to delete
/// </summary>
public KeyRange KeyRange { get; set; }}
/// <summary>
/// Response from <see cref="IndexedDBDeleteObjectStoreEntriesRequest"/>
/// </summary>
internal class IndexedDBDeleteObjectStoreEntriesResponse : IChromiumResponse
{
}
/// <summary>
/// Disables events from backend.
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.disable</c>
/// </remarks>
internal class IndexedDBDisableRequest : IChromiumRequest<IndexedDBDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.disable";
}
/// <summary>
/// Response from <see cref="IndexedDBDisableRequest"/>
/// </summary>
internal class IndexedDBDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables events from backend.
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.enable</c>
/// </remarks>
internal class IndexedDBEnableRequest : IChromiumRequest<IndexedDBEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.enable";
}
/// <summary>
/// Response from <see cref="IndexedDBEnableRequest"/>
/// </summary>
internal class IndexedDBEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Requests data from object store or index.
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.requestData</c>
/// </remarks>
internal class IndexedDBRequestDataRequest : IChromiumRequest<IndexedDBRequestDataResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.requestData";
/// <summary>
/// Security origin.
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// Database name.
/// </summary>
public string DatabaseName { get; set; }
/// <summary>
/// Object store name.
/// </summary>
public string ObjectStoreName { get; set; }
/// <summary>
/// Index name, empty string for object store data requests.
/// </summary>
public string IndexName { get; set; }
/// <summary>
/// Number of records to skip.
/// </summary>
public int SkipCount { get; set; }
/// <summary>
/// Number of records to fetch.
/// </summary>
public int PageSize { get; set; }
/// <summary>
/// Key range.
/// </summary>
public KeyRange KeyRange { get; set; }}
/// <summary>
/// Response from <see cref="IndexedDBRequestDataRequest"/>
/// </summary>
internal class IndexedDBRequestDataResponse : IChromiumResponse
{
/// <summary>
/// Array of object store data entries.
/// </summary>
public DataEntry[] ObjectStoreDataEntries { get; set; }
/// <summary>
/// If true, there are more entries to fetch in the given range.
/// </summary>
public bool HasMore { get; set; }}
/// <summary>
/// Gets metadata of an object store
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.getMetadata</c>
/// </remarks>
internal class IndexedDBGetMetadataRequest : IChromiumRequest<IndexedDBGetMetadataResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.getMetadata";
/// <summary>
/// Security origin.
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// Database name.
/// </summary>
public string DatabaseName { get; set; }
/// <summary>
/// Object store name.
/// </summary>
public string ObjectStoreName { get; set; }}
/// <summary>
/// Response from <see cref="IndexedDBGetMetadataRequest"/>
/// </summary>
internal class IndexedDBGetMetadataResponse : IChromiumResponse
{
/// <summary>
/// the entries count
/// </summary>
public double EntriesCount { get; set; }
/// <summary>
/// the current value of key generator, to become the next inserted
/// key into the object store. Valid if objectStore.autoIncrement
/// is true.
/// </summary>
public double KeyGeneratorValue { get; set; }}
/// <summary>
/// Requests database with given name in given frame.
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.requestDatabase</c>
/// </remarks>
internal class IndexedDBRequestDatabaseRequest : IChromiumRequest<IndexedDBRequestDatabaseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.requestDatabase";
/// <summary>
/// Security origin.
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// Database name.
/// </summary>
public string DatabaseName { get; set; }}
/// <summary>
/// Response from <see cref="IndexedDBRequestDatabaseRequest"/>
/// </summary>
internal class IndexedDBRequestDatabaseResponse : IChromiumResponse
{
/// <summary>
/// Database with an array of object stores.
/// </summary>
public DatabaseWithObjectStores DatabaseWithObjectStores { get; set; }}
/// <summary>
/// Requests database names for given security origin.
/// </summary>
/// <remarks>
/// Will send the command <c>IndexedDB.requestDatabaseNames</c>
/// </remarks>
internal class IndexedDBRequestDatabaseNamesRequest : IChromiumRequest<IndexedDBRequestDatabaseNamesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "IndexedDB.requestDatabaseNames";
/// <summary>
/// Security origin.
/// </summary>
public string SecurityOrigin { get; set; }}
/// <summary>
/// Response from <see cref="IndexedDBRequestDatabaseNamesRequest"/>
/// </summary>
internal class IndexedDBRequestDatabaseNamesResponse : IChromiumResponse
{
/// <summary>
/// Database names for origin.
/// </summary>
public string[] DatabaseNames { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Input
{
/// <summary>
/// 
/// </summary>
internal class TouchPoint
{
/// <summary>
/// X coordinate of the event relative to the main frame's viewport in CSS pixels.
/// </summary>
public double X { get; set; }
/// <summary>
/// Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
/// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
/// </summary>
public double Y { get; set; }
/// <summary>
/// X radius of the touch area (default: 1.0).
/// </summary>
public double RadiusX { get; set; }
/// <summary>
/// Y radius of the touch area (default: 1.0).
/// </summary>
public double RadiusY { get; set; }
/// <summary>
/// Rotation angle (default: 0.0).
/// </summary>
public double RotationAngle { get; set; }
/// <summary>
/// Force (default: 1.0).
/// </summary>
public double Force { get; set; }
/// <summary>
/// Identifier used to track touch sources between events, must be unique within an event.
/// </summary>
public double Id { get; set; }}
/// <summary>
/// 
/// </summary>
internal enum GestureSourceType
{
[System.Runtime.Serialization.EnumMember(Value = "default")]Default,
[System.Runtime.Serialization.EnumMember(Value = "touch")]Touch,
[System.Runtime.Serialization.EnumMember(Value = "mouse")]Mouse}
/// <summary>
/// 
/// </summary>
internal enum MouseButton
{
[System.Runtime.Serialization.EnumMember(Value = "none")]None,
[System.Runtime.Serialization.EnumMember(Value = "left")]Left,
[System.Runtime.Serialization.EnumMember(Value = "middle")]Middle,
[System.Runtime.Serialization.EnumMember(Value = "right")]Right,
[System.Runtime.Serialization.EnumMember(Value = "back")]Back,
[System.Runtime.Serialization.EnumMember(Value = "forward")]Forward}
/// <summary>
/// Dispatches a key event to the page.
/// </summary>
/// <remarks>
/// Will send the command <c>Input.dispatchKeyEvent</c>
/// </remarks>
internal class InputDispatchKeyEventRequest : IChromiumRequest<InputDispatchKeyEventResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Input.dispatchKeyEvent";
/// <summary>
/// Type of the key event.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).
/// </summary>
public int Modifiers { get; set; }
/// <summary>
/// Time at which the event occurred.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// Text as generated by processing a virtual key code with a keyboard layout. Not needed for
/// for `keyUp` and `rawKeyDown` events (default: "")
/// </summary>
public string Text { get; set; }
/// <summary>
/// Text that would have been generated by the keyboard if no modifiers were pressed (except for
/// shift). Useful for shortcut (accelerator) key handling (default: "").
/// </summary>
public string UnmodifiedText { get; set; }
/// <summary>
/// Unique key identifier (e.g., 'U+0041') (default: "").
/// </summary>
public string KeyIdentifier { get; set; }
/// <summary>
/// Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
/// </summary>
public string Code { get; set; }
/// <summary>
/// Unique DOM defined string value describing the meaning of the key in the context of active
/// modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
/// </summary>
public string Key { get; set; }
/// <summary>
/// Windows virtual key code (default: 0).
/// </summary>
public int WindowsVirtualKeyCode { get; set; }
/// <summary>
/// Native virtual key code (default: 0).
/// </summary>
public int NativeVirtualKeyCode { get; set; }
/// <summary>
/// Whether the event was generated from auto repeat (default: false).
/// </summary>
public bool AutoRepeat { get; set; }
/// <summary>
/// Whether the event was generated from the keypad (default: false).
/// </summary>
public bool IsKeypad { get; set; }
/// <summary>
/// Whether the event was a system key event (default: false).
/// </summary>
public bool IsSystemKey { get; set; }
/// <summary>
/// Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:
/// 0).
/// </summary>
public int Location { get; set; }}
/// <summary>
/// Response from <see cref="InputDispatchKeyEventRequest"/>
/// </summary>
internal class InputDispatchKeyEventResponse : IChromiumResponse
{
}
/// <summary>
/// This method emulates inserting text that doesn't come from a key press,
/// for example an emoji keyboard or an IME.
/// </summary>
/// <remarks>
/// Will send the command <c>Input.insertText</c>
/// </remarks>
internal class InputInsertTextRequest : IChromiumRequest<InputInsertTextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Input.insertText";
/// <summary>
/// The text to insert.
/// </summary>
public string Text { get; set; }}
/// <summary>
/// Response from <see cref="InputInsertTextRequest"/>
/// </summary>
internal class InputInsertTextResponse : IChromiumResponse
{
}
/// <summary>
/// Dispatches a mouse event to the page.
/// </summary>
/// <remarks>
/// Will send the command <c>Input.dispatchMouseEvent</c>
/// </remarks>
internal class InputDispatchMouseEventRequest : IChromiumRequest<InputDispatchMouseEventResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Input.dispatchMouseEvent";
/// <summary>
/// Type of the mouse event.
/// </summary>
public string Type { get; set; }
/// <summary>
/// X coordinate of the event relative to the main frame's viewport in CSS pixels.
/// </summary>
public double X { get; set; }
/// <summary>
/// Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
/// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
/// </summary>
public double Y { get; set; }
/// <summary>
/// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).
/// </summary>
public int Modifiers { get; set; }
/// <summary>
/// Time at which the event occurred.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// Mouse button (default: "none").
/// </summary>
public MouseButton Button { get; set; }
/// <summary>
/// A number indicating which buttons are pressed on the mouse when a mouse event is triggered.
/// Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
/// </summary>
public int Buttons { get; set; }
/// <summary>
/// Number of times the mouse button was clicked (default: 0).
/// </summary>
public int ClickCount { get; set; }
/// <summary>
/// X delta in CSS pixels for mouse wheel event (default: 0).
/// </summary>
public double DeltaX { get; set; }
/// <summary>
/// Y delta in CSS pixels for mouse wheel event (default: 0).
/// </summary>
public double DeltaY { get; set; }
/// <summary>
/// Pointer type (default: "mouse").
/// </summary>
public string PointerType { get; set; }}
/// <summary>
/// Response from <see cref="InputDispatchMouseEventRequest"/>
/// </summary>
internal class InputDispatchMouseEventResponse : IChromiumResponse
{
}
/// <summary>
/// Dispatches a touch event to the page.
/// </summary>
/// <remarks>
/// Will send the command <c>Input.dispatchTouchEvent</c>
/// </remarks>
internal class InputDispatchTouchEventRequest : IChromiumRequest<InputDispatchTouchEventResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Input.dispatchTouchEvent";
/// <summary>
/// Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while
/// TouchStart and TouchMove must contains at least one.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Active touch points on the touch device. One event per any changed point (compared to
/// previous touch event in a sequence) is generated, emulating pressing/moving/releasing points
/// one by one.
/// </summary>
public TouchPoint[] TouchPoints { get; set; }
/// <summary>
/// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).
/// </summary>
public int Modifiers { get; set; }
/// <summary>
/// Time at which the event occurred.
/// </summary>
public double Timestamp { get; set; }}
/// <summary>
/// Response from <see cref="InputDispatchTouchEventRequest"/>
/// </summary>
internal class InputDispatchTouchEventResponse : IChromiumResponse
{
}
/// <summary>
/// Emulates touch event from the mouse event parameters.
/// </summary>
/// <remarks>
/// Will send the command <c>Input.emulateTouchFromMouseEvent</c>
/// </remarks>
internal class InputEmulateTouchFromMouseEventRequest : IChromiumRequest<InputEmulateTouchFromMouseEventResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Input.emulateTouchFromMouseEvent";
/// <summary>
/// Type of the mouse event.
/// </summary>
public string Type { get; set; }
/// <summary>
/// X coordinate of the mouse pointer in DIP.
/// </summary>
public int X { get; set; }
/// <summary>
/// Y coordinate of the mouse pointer in DIP.
/// </summary>
public int Y { get; set; }
/// <summary>
/// Mouse button. Only "none", "left", "right" are supported.
/// </summary>
public MouseButton Button { get; set; }
/// <summary>
/// Time at which the event occurred (default: current time).
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// X delta in DIP for mouse wheel event (default: 0).
/// </summary>
public double DeltaX { get; set; }
/// <summary>
/// Y delta in DIP for mouse wheel event (default: 0).
/// </summary>
public double DeltaY { get; set; }
/// <summary>
/// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).
/// </summary>
public int Modifiers { get; set; }
/// <summary>
/// Number of times the mouse button was clicked (default: 0).
/// </summary>
public int ClickCount { get; set; }}
/// <summary>
/// Response from <see cref="InputEmulateTouchFromMouseEventRequest"/>
/// </summary>
internal class InputEmulateTouchFromMouseEventResponse : IChromiumResponse
{
}
/// <summary>
/// Ignores input events (useful while auditing page).
/// </summary>
/// <remarks>
/// Will send the command <c>Input.setIgnoreInputEvents</c>
/// </remarks>
internal class InputSetIgnoreInputEventsRequest : IChromiumRequest<InputSetIgnoreInputEventsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Input.setIgnoreInputEvents";
/// <summary>
/// Ignores input events processing when set to true.
/// </summary>
public bool Ignore { get; set; }}
/// <summary>
/// Response from <see cref="InputSetIgnoreInputEventsRequest"/>
/// </summary>
internal class InputSetIgnoreInputEventsResponse : IChromiumResponse
{
}
/// <summary>
/// Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
/// </summary>
/// <remarks>
/// Will send the command <c>Input.synthesizePinchGesture</c>
/// </remarks>
internal class InputSynthesizePinchGestureRequest : IChromiumRequest<InputSynthesizePinchGestureResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Input.synthesizePinchGesture";
/// <summary>
/// X coordinate of the start of the gesture in CSS pixels.
/// </summary>
public double X { get; set; }
/// <summary>
/// Y coordinate of the start of the gesture in CSS pixels.
/// </summary>
public double Y { get; set; }
/// <summary>
/// Relative scale factor after zooming (&gt;1.0 zooms in, &lt;1.0 zooms out).
/// </summary>
public double ScaleFactor { get; set; }
/// <summary>
/// Relative pointer speed in pixels per second (default: 800).
/// </summary>
public int RelativeSpeed { get; set; }
/// <summary>
/// Which type of input events to be generated (default: 'default', which queries the platform
/// for the preferred input type).
/// </summary>
public GestureSourceType GestureSourceType { get; set; }}
/// <summary>
/// Response from <see cref="InputSynthesizePinchGestureRequest"/>
/// </summary>
internal class InputSynthesizePinchGestureResponse : IChromiumResponse
{
}
/// <summary>
/// Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
/// </summary>
/// <remarks>
/// Will send the command <c>Input.synthesizeScrollGesture</c>
/// </remarks>
internal class InputSynthesizeScrollGestureRequest : IChromiumRequest<InputSynthesizeScrollGestureResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Input.synthesizeScrollGesture";
/// <summary>
/// X coordinate of the start of the gesture in CSS pixels.
/// </summary>
public double X { get; set; }
/// <summary>
/// Y coordinate of the start of the gesture in CSS pixels.
/// </summary>
public double Y { get; set; }
/// <summary>
/// The distance to scroll along the X axis (positive to scroll left).
/// </summary>
public double XDistance { get; set; }
/// <summary>
/// The distance to scroll along the Y axis (positive to scroll up).
/// </summary>
public double YDistance { get; set; }
/// <summary>
/// The number of additional pixels to scroll back along the X axis, in addition to the given
/// distance.
/// </summary>
public double XOverscroll { get; set; }
/// <summary>
/// The number of additional pixels to scroll back along the Y axis, in addition to the given
/// distance.
/// </summary>
public double YOverscroll { get; set; }
/// <summary>
/// Prevent fling (default: true).
/// </summary>
public bool PreventFling { get; set; }
/// <summary>
/// Swipe speed in pixels per second (default: 800).
/// </summary>
public int Speed { get; set; }
/// <summary>
/// Which type of input events to be generated (default: 'default', which queries the platform
/// for the preferred input type).
/// </summary>
public GestureSourceType GestureSourceType { get; set; }
/// <summary>
/// The number of times to repeat the gesture (default: 0).
/// </summary>
public int RepeatCount { get; set; }
/// <summary>
/// The number of milliseconds delay between each repeat. (default: 250).
/// </summary>
public int RepeatDelayMs { get; set; }
/// <summary>
/// The name of the interaction markers to generate, if not empty (default: "").
/// </summary>
public string InteractionMarkerName { get; set; }}
/// <summary>
/// Response from <see cref="InputSynthesizeScrollGestureRequest"/>
/// </summary>
internal class InputSynthesizeScrollGestureResponse : IChromiumResponse
{
}
/// <summary>
/// Synthesizes a tap gesture over a time period by issuing appropriate touch events.
/// </summary>
/// <remarks>
/// Will send the command <c>Input.synthesizeTapGesture</c>
/// </remarks>
internal class InputSynthesizeTapGestureRequest : IChromiumRequest<InputSynthesizeTapGestureResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Input.synthesizeTapGesture";
/// <summary>
/// X coordinate of the start of the gesture in CSS pixels.
/// </summary>
public double X { get; set; }
/// <summary>
/// Y coordinate of the start of the gesture in CSS pixels.
/// </summary>
public double Y { get; set; }
/// <summary>
/// Duration between touchdown and touchup events in ms (default: 50).
/// </summary>
public int Duration { get; set; }
/// <summary>
/// Number of times to perform the tap (e.g. 2 for double tap, default: 1).
/// </summary>
public int TapCount { get; set; }
/// <summary>
/// Which type of input events to be generated (default: 'default', which queries the platform
/// for the preferred input type).
/// </summary>
public GestureSourceType GestureSourceType { get; set; }}
/// <summary>
/// Response from <see cref="InputSynthesizeTapGestureRequest"/>
/// </summary>
internal class InputSynthesizeTapGestureResponse : IChromiumResponse
{
}
}
namespace PlaywrightSharp.Chromium.Protocol.Inspector
{
/// <summary>
/// Disables inspector domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Inspector.disable</c>
/// </remarks>
internal class InspectorDisableRequest : IChromiumRequest<InspectorDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Inspector.disable";
}
/// <summary>
/// Response from <see cref="InspectorDisableRequest"/>
/// </summary>
internal class InspectorDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables inspector domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Inspector.enable</c>
/// </remarks>
internal class InspectorEnableRequest : IChromiumRequest<InspectorEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Inspector.enable";
}
/// <summary>
/// Response from <see cref="InspectorEnableRequest"/>
/// </summary>
internal class InspectorEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Fired when remote debugging connection is about to be terminated. Contains detach reason.
/// </summary>
/// <remarks>
/// Matches on the event <c>Inspector.detached</c>
/// </remarks>
internal class InspectorDetachedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Inspector.detached";
/// <summary>
/// The reason why connection has been terminated.
/// </summary>
public string Reason { get; set; }}
/// <summary>
/// Fired when debugging target has crashed
/// </summary>
/// <remarks>
/// Matches on the event <c>Inspector.targetCrashed</c>
/// </remarks>
internal class InspectorTargetCrashedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Inspector.targetCrashed";
}
/// <summary>
/// Fired when debugging target has reloaded after crash
/// </summary>
/// <remarks>
/// Matches on the event <c>Inspector.targetReloadedAfterCrash</c>
/// </remarks>
internal class InspectorTargetReloadedAfterCrashChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Inspector.targetReloadedAfterCrash";
}
}
namespace PlaywrightSharp.Chromium.Protocol.LayerTree
{
/// <summary>
/// Rectangle where scrolling happens on the main thread.
/// </summary>
internal class ScrollRect
{
/// <summary>
/// Rectangle itself.
/// </summary>
public DOM.Rect Rect { get; set; }
/// <summary>
/// Reason for rectangle to force scrolling on the main thread
/// </summary>
public string Type { get; set; }}
/// <summary>
/// Sticky position constraints.
/// </summary>
internal class StickyPositionConstraint
{
/// <summary>
/// Layout rectangle of the sticky element before being shifted
/// </summary>
public DOM.Rect StickyBoxRect { get; set; }
/// <summary>
/// Layout rectangle of the containing block of the sticky element
/// </summary>
public DOM.Rect ContainingBlockRect { get; set; }
/// <summary>
/// The nearest sticky layer that shifts the sticky box
/// </summary>
public string NearestLayerShiftingStickyBox { get; set; }
/// <summary>
/// The nearest sticky layer that shifts the containing block
/// </summary>
public string NearestLayerShiftingContainingBlock { get; set; }}
/// <summary>
/// Serialized fragment of layer picture along with its offset within the layer.
/// </summary>
internal class PictureTile
{
/// <summary>
/// Offset from owning layer left boundary
/// </summary>
public double X { get; set; }
/// <summary>
/// Offset from owning layer top boundary
/// </summary>
public double Y { get; set; }
/// <summary>
/// Base64-encoded snapshot data.
/// </summary>
public byte[] Picture { get; set; }}
/// <summary>
/// Information about a compositing layer.
/// </summary>
internal class Layer
{
/// <summary>
/// The unique id for this layer.
/// </summary>
public string LayerId { get; set; }
/// <summary>
/// The id of parent (not present for root).
/// </summary>
public string ParentLayerId { get; set; }
/// <summary>
/// The backend id for the node associated with this layer.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// Offset from parent layer, X coordinate.
/// </summary>
public double OffsetX { get; set; }
/// <summary>
/// Offset from parent layer, Y coordinate.
/// </summary>
public double OffsetY { get; set; }
/// <summary>
/// Layer width.
/// </summary>
public double Width { get; set; }
/// <summary>
/// Layer height.
/// </summary>
public double Height { get; set; }
/// <summary>
/// Transformation matrix for layer, default is identity matrix
/// </summary>
public double[] Transform { get; set; }
/// <summary>
/// Transform anchor point X, absent if no transform specified
/// </summary>
public double AnchorX { get; set; }
/// <summary>
/// Transform anchor point Y, absent if no transform specified
/// </summary>
public double AnchorY { get; set; }
/// <summary>
/// Transform anchor point Z, absent if no transform specified
/// </summary>
public double AnchorZ { get; set; }
/// <summary>
/// Indicates how many time this layer has painted.
/// </summary>
public int PaintCount { get; set; }
/// <summary>
/// Indicates whether this layer hosts any content, rather than being used for
/// transform/scrolling purposes only.
/// </summary>
public bool DrawsContent { get; set; }
/// <summary>
/// Set if layer is not visible.
/// </summary>
public bool Invisible { get; set; }
/// <summary>
/// Rectangles scrolling on main thread only.
/// </summary>
public ScrollRect[] ScrollRects { get; set; }
/// <summary>
/// Sticky position constraint information
/// </summary>
public StickyPositionConstraint StickyPositionConstraint { get; set; }}
/// <summary>
/// Provides the reasons why the given layer was composited.
/// </summary>
/// <remarks>
/// Will send the command <c>LayerTree.compositingReasons</c>
/// </remarks>
internal class LayerTreeCompositingReasonsRequest : IChromiumRequest<LayerTreeCompositingReasonsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "LayerTree.compositingReasons";
/// <summary>
/// The id of the layer for which we want to get the reasons it was composited.
/// </summary>
public string LayerId { get; set; }}
/// <summary>
/// Response from <see cref="LayerTreeCompositingReasonsRequest"/>
/// </summary>
internal class LayerTreeCompositingReasonsResponse : IChromiumResponse
{
/// <summary>
/// A list of strings specifying reasons for the given layer to become composited.
/// </summary>
public string[] CompositingReasons { get; set; }}
/// <summary>
/// Disables compositing tree inspection.
/// </summary>
/// <remarks>
/// Will send the command <c>LayerTree.disable</c>
/// </remarks>
internal class LayerTreeDisableRequest : IChromiumRequest<LayerTreeDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "LayerTree.disable";
}
/// <summary>
/// Response from <see cref="LayerTreeDisableRequest"/>
/// </summary>
internal class LayerTreeDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables compositing tree inspection.
/// </summary>
/// <remarks>
/// Will send the command <c>LayerTree.enable</c>
/// </remarks>
internal class LayerTreeEnableRequest : IChromiumRequest<LayerTreeEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "LayerTree.enable";
}
/// <summary>
/// Response from <see cref="LayerTreeEnableRequest"/>
/// </summary>
internal class LayerTreeEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Returns the snapshot identifier.
/// </summary>
/// <remarks>
/// Will send the command <c>LayerTree.loadSnapshot</c>
/// </remarks>
internal class LayerTreeLoadSnapshotRequest : IChromiumRequest<LayerTreeLoadSnapshotResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "LayerTree.loadSnapshot";
/// <summary>
/// An array of tiles composing the snapshot.
/// </summary>
public PictureTile[] Tiles { get; set; }}
/// <summary>
/// Response from <see cref="LayerTreeLoadSnapshotRequest"/>
/// </summary>
internal class LayerTreeLoadSnapshotResponse : IChromiumResponse
{
/// <summary>
/// The id of the snapshot.
/// </summary>
public string SnapshotId { get; set; }}
/// <summary>
/// Returns the layer snapshot identifier.
/// </summary>
/// <remarks>
/// Will send the command <c>LayerTree.makeSnapshot</c>
/// </remarks>
internal class LayerTreeMakeSnapshotRequest : IChromiumRequest<LayerTreeMakeSnapshotResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "LayerTree.makeSnapshot";
/// <summary>
/// The id of the layer.
/// </summary>
public string LayerId { get; set; }}
/// <summary>
/// Response from <see cref="LayerTreeMakeSnapshotRequest"/>
/// </summary>
internal class LayerTreeMakeSnapshotResponse : IChromiumResponse
{
/// <summary>
/// The id of the layer snapshot.
/// </summary>
public string SnapshotId { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>LayerTree.profileSnapshot</c>
/// </remarks>
internal class LayerTreeProfileSnapshotRequest : IChromiumRequest<LayerTreeProfileSnapshotResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "LayerTree.profileSnapshot";
/// <summary>
/// The id of the layer snapshot.
/// </summary>
public string SnapshotId { get; set; }
/// <summary>
/// The maximum number of times to replay the snapshot (1, if not specified).
/// </summary>
public int MinRepeatCount { get; set; }
/// <summary>
/// The minimum duration (in seconds) to replay the snapshot.
/// </summary>
public double MinDuration { get; set; }
/// <summary>
/// The clip rectangle to apply when replaying the snapshot.
/// </summary>
public DOM.Rect ClipRect { get; set; }}
/// <summary>
/// Response from <see cref="LayerTreeProfileSnapshotRequest"/>
/// </summary>
internal class LayerTreeProfileSnapshotResponse : IChromiumResponse
{
/// <summary>
/// The array of paint profiles, one per run.
/// </summary>
public double[][] Timings { get; set; }}
/// <summary>
/// Releases layer snapshot captured by the back-end.
/// </summary>
/// <remarks>
/// Will send the command <c>LayerTree.releaseSnapshot</c>
/// </remarks>
internal class LayerTreeReleaseSnapshotRequest : IChromiumRequest<LayerTreeReleaseSnapshotResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "LayerTree.releaseSnapshot";
/// <summary>
/// The id of the layer snapshot.
/// </summary>
public string SnapshotId { get; set; }}
/// <summary>
/// Response from <see cref="LayerTreeReleaseSnapshotRequest"/>
/// </summary>
internal class LayerTreeReleaseSnapshotResponse : IChromiumResponse
{
}
/// <summary>
/// Replays the layer snapshot and returns the resulting bitmap.
/// </summary>
/// <remarks>
/// Will send the command <c>LayerTree.replaySnapshot</c>
/// </remarks>
internal class LayerTreeReplaySnapshotRequest : IChromiumRequest<LayerTreeReplaySnapshotResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "LayerTree.replaySnapshot";
/// <summary>
/// The id of the layer snapshot.
/// </summary>
public string SnapshotId { get; set; }
/// <summary>
/// The first step to replay from (replay from the very start if not specified).
/// </summary>
public int FromStep { get; set; }
/// <summary>
/// The last step to replay to (replay till the end if not specified).
/// </summary>
public int ToStep { get; set; }
/// <summary>
/// The scale to apply while replaying (defaults to 1).
/// </summary>
public double Scale { get; set; }}
/// <summary>
/// Response from <see cref="LayerTreeReplaySnapshotRequest"/>
/// </summary>
internal class LayerTreeReplaySnapshotResponse : IChromiumResponse
{
/// <summary>
/// A data: URL for resulting image.
/// </summary>
public string DataURL { get; set; }}
/// <summary>
/// Replays the layer snapshot and returns canvas log.
/// </summary>
/// <remarks>
/// Will send the command <c>LayerTree.snapshotCommandLog</c>
/// </remarks>
internal class LayerTreeSnapshotCommandLogRequest : IChromiumRequest<LayerTreeSnapshotCommandLogResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "LayerTree.snapshotCommandLog";
/// <summary>
/// The id of the layer snapshot.
/// </summary>
public string SnapshotId { get; set; }}
/// <summary>
/// Response from <see cref="LayerTreeSnapshotCommandLogRequest"/>
/// </summary>
internal class LayerTreeSnapshotCommandLogResponse : IChromiumResponse
{
/// <summary>
/// The array of canvas function calls.
/// </summary>
public JsonElement?[] CommandLog { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>LayerTree.layerPainted</c>
/// </remarks>
internal class LayerTreeLayerPaintedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "LayerTree.layerPainted";
/// <summary>
/// The id of the painted layer.
/// </summary>
public string LayerId { get; set; }
/// <summary>
/// Clip rectangle.
/// </summary>
public DOM.Rect Clip { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>LayerTree.layerTreeDidChange</c>
/// </remarks>
internal class LayerTreeLayerTreeDidChangeChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "LayerTree.layerTreeDidChange";
/// <summary>
/// Layer tree, absent if not in the comspositing mode.
/// </summary>
public Layer[] Layers { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Log
{
/// <summary>
/// Log entry.
/// </summary>
internal class LogEntry
{
/// <summary>
/// Log entry source.
/// </summary>
public string Source { get; set; }
/// <summary>
/// Log entry severity.
/// </summary>
public string Level { get; set; }
/// <summary>
/// Logged text.
/// </summary>
public string Text { get; set; }
/// <summary>
/// Timestamp when this entry was added.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// URL of the resource if known.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Line number in the resource.
/// </summary>
public int LineNumber { get; set; }
/// <summary>
/// JavaScript stack trace.
/// </summary>
public Runtime.StackTrace StackTrace { get; set; }
/// <summary>
/// Identifier of the network request associated with this entry.
/// </summary>
public string NetworkRequestId { get; set; }
/// <summary>
/// Identifier of the worker associated with this entry.
/// </summary>
public string WorkerId { get; set; }
/// <summary>
/// Call arguments.
/// </summary>
public Runtime.RemoteObject[] Args { get; set; }}
/// <summary>
/// Violation configuration setting.
/// </summary>
internal class ViolationSetting
{
/// <summary>
/// Violation type.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Time threshold to trigger upon.
/// </summary>
public double Threshold { get; set; }}
/// <summary>
/// Clears the log.
/// </summary>
/// <remarks>
/// Will send the command <c>Log.clear</c>
/// </remarks>
internal class LogClearRequest : IChromiumRequest<LogClearResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Log.clear";
}
/// <summary>
/// Response from <see cref="LogClearRequest"/>
/// </summary>
internal class LogClearResponse : IChromiumResponse
{
}
/// <summary>
/// Disables log domain, prevents further log entries from being reported to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>Log.disable</c>
/// </remarks>
internal class LogDisableRequest : IChromiumRequest<LogDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Log.disable";
}
/// <summary>
/// Response from <see cref="LogDisableRequest"/>
/// </summary>
internal class LogDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables log domain, sends the entries collected so far to the client by means of the
/// `entryAdded` notification.
/// </summary>
/// <remarks>
/// Will send the command <c>Log.enable</c>
/// </remarks>
internal class LogEnableRequest : IChromiumRequest<LogEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Log.enable";
}
/// <summary>
/// Response from <see cref="LogEnableRequest"/>
/// </summary>
internal class LogEnableResponse : IChromiumResponse
{
}
/// <summary>
/// start violation reporting.
/// </summary>
/// <remarks>
/// Will send the command <c>Log.startViolationsReport</c>
/// </remarks>
internal class LogStartViolationsReportRequest : IChromiumRequest<LogStartViolationsReportResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Log.startViolationsReport";
/// <summary>
/// Configuration for violations.
/// </summary>
public ViolationSetting[] Config { get; set; }}
/// <summary>
/// Response from <see cref="LogStartViolationsReportRequest"/>
/// </summary>
internal class LogStartViolationsReportResponse : IChromiumResponse
{
}
/// <summary>
/// Stop violation reporting.
/// </summary>
/// <remarks>
/// Will send the command <c>Log.stopViolationsReport</c>
/// </remarks>
internal class LogStopViolationsReportRequest : IChromiumRequest<LogStopViolationsReportResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Log.stopViolationsReport";
}
/// <summary>
/// Response from <see cref="LogStopViolationsReportRequest"/>
/// </summary>
internal class LogStopViolationsReportResponse : IChromiumResponse
{
}
/// <summary>
/// Issued when new message was logged.
/// </summary>
/// <remarks>
/// Matches on the event <c>Log.entryAdded</c>
/// </remarks>
internal class LogEntryAddedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Log.entryAdded";
/// <summary>
/// The entry.
/// </summary>
public LogEntry Entry { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Memory
{
/// <summary>
/// Memory pressure level.
/// </summary>
internal enum PressureLevel
{
[System.Runtime.Serialization.EnumMember(Value = "moderate")]Moderate,
[System.Runtime.Serialization.EnumMember(Value = "critical")]Critical}
/// <summary>
/// Heap profile sample.
/// </summary>
internal class SamplingProfileNode
{
/// <summary>
/// Size of the sampled allocation.
/// </summary>
public double Size { get; set; }
/// <summary>
/// Total bytes attributed to this sample.
/// </summary>
public double Total { get; set; }
/// <summary>
/// Execution stack at the point of allocation.
/// </summary>
public string[] Stack { get; set; }}
/// <summary>
/// Array of heap profile samples.
/// </summary>
internal class SamplingProfile
{
/// <summary>
/// 
/// </summary>
public SamplingProfileNode[] Samples { get; set; }
/// <summary>
/// 
/// </summary>
public Module[] Modules { get; set; }}
/// <summary>
/// Executable module information
/// </summary>
internal class Module
{
/// <summary>
/// Name of the module.
/// </summary>
public string Name { get; set; }
/// <summary>
/// UUID of the module.
/// </summary>
public string Uuid { get; set; }
/// <summary>
/// Base address where the module is loaded into memory. Encoded as a decimal
/// or hexadecimal (0x prefixed) string.
/// </summary>
public string BaseAddress { get; set; }
/// <summary>
/// Size of the module in bytes.
/// </summary>
public double Size { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Memory.getDOMCounters</c>
/// </remarks>
internal class MemoryGetDOMCountersRequest : IChromiumRequest<MemoryGetDOMCountersResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Memory.getDOMCounters";
}
/// <summary>
/// Response from <see cref="MemoryGetDOMCountersRequest"/>
/// </summary>
internal class MemoryGetDOMCountersResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public int Documents { get; set; }
/// <summary>
/// 
/// </summary>
public int Nodes { get; set; }
/// <summary>
/// 
/// </summary>
public int JsEventListeners { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Memory.prepareForLeakDetection</c>
/// </remarks>
internal class MemoryPrepareForLeakDetectionRequest : IChromiumRequest<MemoryPrepareForLeakDetectionResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Memory.prepareForLeakDetection";
}
/// <summary>
/// Response from <see cref="MemoryPrepareForLeakDetectionRequest"/>
/// </summary>
internal class MemoryPrepareForLeakDetectionResponse : IChromiumResponse
{
}
/// <summary>
/// Simulate OomIntervention by purging V8 memory.
/// </summary>
/// <remarks>
/// Will send the command <c>Memory.forciblyPurgeJavaScriptMemory</c>
/// </remarks>
internal class MemoryForciblyPurgeJavaScriptMemoryRequest : IChromiumRequest<MemoryForciblyPurgeJavaScriptMemoryResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Memory.forciblyPurgeJavaScriptMemory";
}
/// <summary>
/// Response from <see cref="MemoryForciblyPurgeJavaScriptMemoryRequest"/>
/// </summary>
internal class MemoryForciblyPurgeJavaScriptMemoryResponse : IChromiumResponse
{
}
/// <summary>
/// Enable/disable suppressing memory pressure notifications in all processes.
/// </summary>
/// <remarks>
/// Will send the command <c>Memory.setPressureNotificationsSuppressed</c>
/// </remarks>
internal class MemorySetPressureNotificationsSuppressedRequest : IChromiumRequest<MemorySetPressureNotificationsSuppressedResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Memory.setPressureNotificationsSuppressed";
/// <summary>
/// If true, memory pressure notifications will be suppressed.
/// </summary>
public bool Suppressed { get; set; }}
/// <summary>
/// Response from <see cref="MemorySetPressureNotificationsSuppressedRequest"/>
/// </summary>
internal class MemorySetPressureNotificationsSuppressedResponse : IChromiumResponse
{
}
/// <summary>
/// Simulate a memory pressure notification in all processes.
/// </summary>
/// <remarks>
/// Will send the command <c>Memory.simulatePressureNotification</c>
/// </remarks>
internal class MemorySimulatePressureNotificationRequest : IChromiumRequest<MemorySimulatePressureNotificationResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Memory.simulatePressureNotification";
/// <summary>
/// Memory pressure level of the notification.
/// </summary>
public PressureLevel Level { get; set; }}
/// <summary>
/// Response from <see cref="MemorySimulatePressureNotificationRequest"/>
/// </summary>
internal class MemorySimulatePressureNotificationResponse : IChromiumResponse
{
}
/// <summary>
/// Start collecting native memory profile.
/// </summary>
/// <remarks>
/// Will send the command <c>Memory.startSampling</c>
/// </remarks>
internal class MemoryStartSamplingRequest : IChromiumRequest<MemoryStartSamplingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Memory.startSampling";
/// <summary>
/// Average number of bytes between samples.
/// </summary>
public int SamplingInterval { get; set; }
/// <summary>
/// Do not randomize intervals between samples.
/// </summary>
public bool SuppressRandomness { get; set; }}
/// <summary>
/// Response from <see cref="MemoryStartSamplingRequest"/>
/// </summary>
internal class MemoryStartSamplingResponse : IChromiumResponse
{
}
/// <summary>
/// Stop collecting native memory profile.
/// </summary>
/// <remarks>
/// Will send the command <c>Memory.stopSampling</c>
/// </remarks>
internal class MemoryStopSamplingRequest : IChromiumRequest<MemoryStopSamplingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Memory.stopSampling";
}
/// <summary>
/// Response from <see cref="MemoryStopSamplingRequest"/>
/// </summary>
internal class MemoryStopSamplingResponse : IChromiumResponse
{
}
/// <summary>
/// Retrieve native memory allocations profile
/// collected since renderer process startup.
/// </summary>
/// <remarks>
/// Will send the command <c>Memory.getAllTimeSamplingProfile</c>
/// </remarks>
internal class MemoryGetAllTimeSamplingProfileRequest : IChromiumRequest<MemoryGetAllTimeSamplingProfileResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Memory.getAllTimeSamplingProfile";
}
/// <summary>
/// Response from <see cref="MemoryGetAllTimeSamplingProfileRequest"/>
/// </summary>
internal class MemoryGetAllTimeSamplingProfileResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public SamplingProfile Profile { get; set; }}
/// <summary>
/// Retrieve native memory allocations profile
/// collected since browser process startup.
/// </summary>
/// <remarks>
/// Will send the command <c>Memory.getBrowserSamplingProfile</c>
/// </remarks>
internal class MemoryGetBrowserSamplingProfileRequest : IChromiumRequest<MemoryGetBrowserSamplingProfileResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Memory.getBrowserSamplingProfile";
}
/// <summary>
/// Response from <see cref="MemoryGetBrowserSamplingProfileRequest"/>
/// </summary>
internal class MemoryGetBrowserSamplingProfileResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public SamplingProfile Profile { get; set; }}
/// <summary>
/// Retrieve native memory allocations profile collected since last
/// `startSampling` call.
/// </summary>
/// <remarks>
/// Will send the command <c>Memory.getSamplingProfile</c>
/// </remarks>
internal class MemoryGetSamplingProfileRequest : IChromiumRequest<MemoryGetSamplingProfileResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Memory.getSamplingProfile";
}
/// <summary>
/// Response from <see cref="MemoryGetSamplingProfileRequest"/>
/// </summary>
internal class MemoryGetSamplingProfileResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public SamplingProfile Profile { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Network
{
/// <summary>
/// Resource type as it was perceived by the rendering engine.
/// </summary>
internal enum ResourceType
{
[System.Runtime.Serialization.EnumMember(Value = "Document")]Document,
[System.Runtime.Serialization.EnumMember(Value = "Stylesheet")]Stylesheet,
[System.Runtime.Serialization.EnumMember(Value = "Image")]Image,
[System.Runtime.Serialization.EnumMember(Value = "Media")]Media,
[System.Runtime.Serialization.EnumMember(Value = "Font")]Font,
[System.Runtime.Serialization.EnumMember(Value = "Script")]Script,
[System.Runtime.Serialization.EnumMember(Value = "TextTrack")]TextTrack,
[System.Runtime.Serialization.EnumMember(Value = "XHR")]XHR,
[System.Runtime.Serialization.EnumMember(Value = "Fetch")]Fetch,
[System.Runtime.Serialization.EnumMember(Value = "EventSource")]EventSource,
[System.Runtime.Serialization.EnumMember(Value = "WebSocket")]WebSocket,
[System.Runtime.Serialization.EnumMember(Value = "Manifest")]Manifest,
[System.Runtime.Serialization.EnumMember(Value = "SignedExchange")]SignedExchange,
[System.Runtime.Serialization.EnumMember(Value = "Ping")]Ping,
[System.Runtime.Serialization.EnumMember(Value = "CSPViolationReport")]CSPViolationReport,
[System.Runtime.Serialization.EnumMember(Value = "Other")]Other}
/// <summary>
/// Network level fetch failure reason.
/// </summary>
internal enum ErrorReason
{
[System.Runtime.Serialization.EnumMember(Value = "Failed")]Failed,
[System.Runtime.Serialization.EnumMember(Value = "Aborted")]Aborted,
[System.Runtime.Serialization.EnumMember(Value = "TimedOut")]TimedOut,
[System.Runtime.Serialization.EnumMember(Value = "AccessDenied")]AccessDenied,
[System.Runtime.Serialization.EnumMember(Value = "ConnectionClosed")]ConnectionClosed,
[System.Runtime.Serialization.EnumMember(Value = "ConnectionReset")]ConnectionReset,
[System.Runtime.Serialization.EnumMember(Value = "ConnectionRefused")]ConnectionRefused,
[System.Runtime.Serialization.EnumMember(Value = "ConnectionAborted")]ConnectionAborted,
[System.Runtime.Serialization.EnumMember(Value = "ConnectionFailed")]ConnectionFailed,
[System.Runtime.Serialization.EnumMember(Value = "NameNotResolved")]NameNotResolved,
[System.Runtime.Serialization.EnumMember(Value = "InternetDisconnected")]InternetDisconnected,
[System.Runtime.Serialization.EnumMember(Value = "AddressUnreachable")]AddressUnreachable,
[System.Runtime.Serialization.EnumMember(Value = "BlockedByClient")]BlockedByClient,
[System.Runtime.Serialization.EnumMember(Value = "BlockedByResponse")]BlockedByResponse}
/// <summary>
/// Request / response headers as keys / values of JSON object.
/// </summary>
internal class Headers
{
}
/// <summary>
/// The underlying connection technology that the browser is supposedly using.
/// </summary>
internal enum ConnectionType
{
[System.Runtime.Serialization.EnumMember(Value = "none")]None,
[System.Runtime.Serialization.EnumMember(Value = "cellular2g")]Cellular2G,
[System.Runtime.Serialization.EnumMember(Value = "cellular3g")]Cellular3G,
[System.Runtime.Serialization.EnumMember(Value = "cellular4g")]Cellular4G,
[System.Runtime.Serialization.EnumMember(Value = "bluetooth")]Bluetooth,
[System.Runtime.Serialization.EnumMember(Value = "ethernet")]Ethernet,
[System.Runtime.Serialization.EnumMember(Value = "wifi")]Wifi,
[System.Runtime.Serialization.EnumMember(Value = "wimax")]Wimax,
[System.Runtime.Serialization.EnumMember(Value = "other")]Other}
/// <summary>
/// Represents the cookie's 'SameSite' status:
/// https://tools.ietf.org/html/draft-west-first-party-cookies
/// </summary>
internal enum CookieSameSite
{
[System.Runtime.Serialization.EnumMember(Value = "Strict")]Strict,
[System.Runtime.Serialization.EnumMember(Value = "Lax")]Lax,
[System.Runtime.Serialization.EnumMember(Value = "None")]None}
/// <summary>
/// Represents the cookie's 'Priority' status:
/// https://tools.ietf.org/html/draft-west-cookie-priority-00
/// </summary>
internal enum CookiePriority
{
[System.Runtime.Serialization.EnumMember(Value = "Low")]Low,
[System.Runtime.Serialization.EnumMember(Value = "Medium")]Medium,
[System.Runtime.Serialization.EnumMember(Value = "High")]High}
/// <summary>
/// Timing information for the request.
/// </summary>
internal class ResourceTiming
{
/// <summary>
/// Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
/// milliseconds relatively to this requestTime.
/// </summary>
public double RequestTime { get; set; }
/// <summary>
/// Started resolving proxy.
/// </summary>
public double ProxyStart { get; set; }
/// <summary>
/// Finished resolving proxy.
/// </summary>
public double ProxyEnd { get; set; }
/// <summary>
/// Started DNS address resolve.
/// </summary>
public double DnsStart { get; set; }
/// <summary>
/// Finished DNS address resolve.
/// </summary>
public double DnsEnd { get; set; }
/// <summary>
/// Started connecting to the remote host.
/// </summary>
public double ConnectStart { get; set; }
/// <summary>
/// Connected to the remote host.
/// </summary>
public double ConnectEnd { get; set; }
/// <summary>
/// Started SSL handshake.
/// </summary>
public double SslStart { get; set; }
/// <summary>
/// Finished SSL handshake.
/// </summary>
public double SslEnd { get; set; }
/// <summary>
/// Started running ServiceWorker.
/// </summary>
public double WorkerStart { get; set; }
/// <summary>
/// Finished Starting ServiceWorker.
/// </summary>
public double WorkerReady { get; set; }
/// <summary>
/// Started sending request.
/// </summary>
public double SendStart { get; set; }
/// <summary>
/// Finished sending request.
/// </summary>
public double SendEnd { get; set; }
/// <summary>
/// Time the server started pushing request.
/// </summary>
public double PushStart { get; set; }
/// <summary>
/// Time the server finished pushing request.
/// </summary>
public double PushEnd { get; set; }
/// <summary>
/// Finished receiving response headers.
/// </summary>
public double ReceiveHeadersEnd { get; set; }}
/// <summary>
/// Loading priority of a resource request.
/// </summary>
internal enum ResourcePriority
{
[System.Runtime.Serialization.EnumMember(Value = "VeryLow")]VeryLow,
[System.Runtime.Serialization.EnumMember(Value = "Low")]Low,
[System.Runtime.Serialization.EnumMember(Value = "Medium")]Medium,
[System.Runtime.Serialization.EnumMember(Value = "High")]High,
[System.Runtime.Serialization.EnumMember(Value = "VeryHigh")]VeryHigh}
/// <summary>
/// HTTP request data.
/// </summary>
internal class Request
{
/// <summary>
/// Request URL (without fragment).
/// </summary>
public string Url { get; set; }
/// <summary>
/// Fragment of the requested URL starting with hash, if present.
/// </summary>
public string UrlFragment { get; set; }
/// <summary>
/// HTTP request method.
/// </summary>
public string Method { get; set; }
/// <summary>
/// HTTP request headers.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }
/// <summary>
/// HTTP POST request data.
/// </summary>
public string PostData { get; set; }
/// <summary>
/// True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.
/// </summary>
public bool HasPostData { get; set; }
/// <summary>
/// The mixed content type of the request.
/// </summary>
public Security.MixedContentType MixedContentType { get; set; }
/// <summary>
/// Priority of the resource request at the time request is sent.
/// </summary>
public ResourcePriority InitialPriority { get; set; }
/// <summary>
/// The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
/// </summary>
public string ReferrerPolicy { get; set; }
/// <summary>
/// Whether is loaded via link preload.
/// </summary>
public bool IsLinkPreload { get; set; }}
/// <summary>
/// Details of a signed certificate timestamp (SCT).
/// </summary>
internal class SignedCertificateTimestamp
{
/// <summary>
/// Validation status.
/// </summary>
public string Status { get; set; }
/// <summary>
/// Origin.
/// </summary>
public string Origin { get; set; }
/// <summary>
/// Log name / description.
/// </summary>
public string LogDescription { get; set; }
/// <summary>
/// Log ID.
/// </summary>
public string LogId { get; set; }
/// <summary>
/// Issuance date.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// Hash algorithm.
/// </summary>
public string HashAlgorithm { get; set; }
/// <summary>
/// Signature algorithm.
/// </summary>
public string SignatureAlgorithm { get; set; }
/// <summary>
/// Signature data.
/// </summary>
public string SignatureData { get; set; }}
/// <summary>
/// Security details about a request.
/// </summary>
internal class SecurityDetails
{
/// <summary>
/// Protocol name (e.g. "TLS 1.2" or "QUIC").
/// </summary>
public string Protocol { get; set; }
/// <summary>
/// Key Exchange used by the connection, or the empty string if not applicable.
/// </summary>
public string KeyExchange { get; set; }
/// <summary>
/// (EC)DH group used by the connection, if applicable.
/// </summary>
public string KeyExchangeGroup { get; set; }
/// <summary>
/// Cipher name.
/// </summary>
public string Cipher { get; set; }
/// <summary>
/// TLS MAC. Note that AEAD ciphers do not have separate MACs.
/// </summary>
public string Mac { get; set; }
/// <summary>
/// Certificate ID value.
/// </summary>
public int CertificateId { get; set; }
/// <summary>
/// Certificate subject name.
/// </summary>
public string SubjectName { get; set; }
/// <summary>
/// Subject Alternative Name (SAN) DNS names and IP addresses.
/// </summary>
public string[] SanList { get; set; }
/// <summary>
/// Name of the issuing CA.
/// </summary>
public string Issuer { get; set; }
/// <summary>
/// Certificate valid from date.
/// </summary>
public double ValidFrom { get; set; }
/// <summary>
/// Certificate valid to (expiration) date
/// </summary>
public double ValidTo { get; set; }
/// <summary>
/// List of signed certificate timestamps (SCTs).
/// </summary>
public SignedCertificateTimestamp[] SignedCertificateTimestampList { get; set; }
/// <summary>
/// Whether the request complied with Certificate Transparency policy
/// </summary>
public CertificateTransparencyCompliance CertificateTransparencyCompliance { get; set; }}
/// <summary>
/// Whether the request complied with Certificate Transparency policy.
/// </summary>
internal enum CertificateTransparencyCompliance
{
[System.Runtime.Serialization.EnumMember(Value = "unknown")]Unknown,
[System.Runtime.Serialization.EnumMember(Value = "not-compliant")]NotCompliant,
[System.Runtime.Serialization.EnumMember(Value = "compliant")]Compliant}
/// <summary>
/// The reason why request was blocked.
/// </summary>
internal enum BlockedReason
{
[System.Runtime.Serialization.EnumMember(Value = "other")]Other,
[System.Runtime.Serialization.EnumMember(Value = "csp")]Csp,
[System.Runtime.Serialization.EnumMember(Value = "mixed-content")]MixedContent,
[System.Runtime.Serialization.EnumMember(Value = "origin")]Origin,
[System.Runtime.Serialization.EnumMember(Value = "inspector")]Inspector,
[System.Runtime.Serialization.EnumMember(Value = "subresource-filter")]SubresourceFilter,
[System.Runtime.Serialization.EnumMember(Value = "content-type")]ContentType,
[System.Runtime.Serialization.EnumMember(Value = "collapsed-by-client")]CollapsedByClient}
/// <summary>
/// HTTP response data.
/// </summary>
internal class Response
{
/// <summary>
/// Response URL. This URL can be different from CachedResource.url in case of redirect.
/// </summary>
public string Url { get; set; }
/// <summary>
/// HTTP response status code.
/// </summary>
public int Status { get; set; }
/// <summary>
/// HTTP response status text.
/// </summary>
public string StatusText { get; set; }
/// <summary>
/// HTTP response headers.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }
/// <summary>
/// HTTP response headers text.
/// </summary>
public string HeadersText { get; set; }
/// <summary>
/// Resource mimeType as determined by the browser.
/// </summary>
public string MimeType { get; set; }
/// <summary>
/// Refined HTTP request headers that were actually transmitted over the network.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> RequestHeaders { get; set; }
/// <summary>
/// HTTP request headers text.
/// </summary>
public string RequestHeadersText { get; set; }
/// <summary>
/// Specifies whether physical connection was actually reused for this request.
/// </summary>
public bool ConnectionReused { get; set; }
/// <summary>
/// Physical connection id that was actually used for this request.
/// </summary>
public double ConnectionId { get; set; }
/// <summary>
/// Remote IP address.
/// </summary>
public string RemoteIPAddress { get; set; }
/// <summary>
/// Remote port.
/// </summary>
public int RemotePort { get; set; }
/// <summary>
/// Specifies that the request was served from the disk cache.
/// </summary>
public bool FromDiskCache { get; set; }
/// <summary>
/// Specifies that the request was served from the ServiceWorker.
/// </summary>
public bool FromServiceWorker { get; set; }
/// <summary>
/// Specifies that the request was served from the prefetch cache.
/// </summary>
public bool FromPrefetchCache { get; set; }
/// <summary>
/// Total number of bytes received for this request so far.
/// </summary>
public double EncodedDataLength { get; set; }
/// <summary>
/// Timing information for the given request.
/// </summary>
public ResourceTiming Timing { get; set; }
/// <summary>
/// Protocol used to fetch this request.
/// </summary>
public string Protocol { get; set; }
/// <summary>
/// Security state of the request resource.
/// </summary>
public Security.SecurityState SecurityState { get; set; }
/// <summary>
/// Security details for the request.
/// </summary>
public SecurityDetails SecurityDetails { get; set; }}
/// <summary>
/// WebSocket request data.
/// </summary>
internal class WebSocketRequest
{
/// <summary>
/// HTTP request headers.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }}
/// <summary>
/// WebSocket response data.
/// </summary>
internal class WebSocketResponse
{
/// <summary>
/// HTTP response status code.
/// </summary>
public int Status { get; set; }
/// <summary>
/// HTTP response status text.
/// </summary>
public string StatusText { get; set; }
/// <summary>
/// HTTP response headers.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }
/// <summary>
/// HTTP response headers text.
/// </summary>
public string HeadersText { get; set; }
/// <summary>
/// HTTP request headers.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> RequestHeaders { get; set; }
/// <summary>
/// HTTP request headers text.
/// </summary>
public string RequestHeadersText { get; set; }}
/// <summary>
/// WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
/// </summary>
internal class WebSocketFrame
{
/// <summary>
/// WebSocket message opcode.
/// </summary>
public double Opcode { get; set; }
/// <summary>
/// WebSocket message mask.
/// </summary>
public bool Mask { get; set; }
/// <summary>
/// WebSocket message payload data.
/// If the opcode is 1, this is a text message and payloadData is a UTF-8 string.
/// If the opcode isn't 1, then payloadData is a base64 encoded string representing binary data.
/// </summary>
public string PayloadData { get; set; }}
/// <summary>
/// Information about the cached resource.
/// </summary>
internal class CachedResource
{
/// <summary>
/// Resource URL. This is the url of the original network request.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Type of this resource.
/// </summary>
public ResourceType Type { get; set; }
/// <summary>
/// Cached response data.
/// </summary>
public Response Response { get; set; }
/// <summary>
/// Cached response body size.
/// </summary>
public double BodySize { get; set; }}
/// <summary>
/// Information about the request initiator.
/// </summary>
internal class Initiator
{
/// <summary>
/// Type of this initiator.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Initiator JavaScript stack trace, set for Script only.
/// </summary>
public Runtime.StackTrace Stack { get; set; }
/// <summary>
/// Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Initiator line number, set for Parser type or for Script type (when script is importing
/// module) (0-based).
/// </summary>
public double LineNumber { get; set; }}
/// <summary>
/// Cookie object
/// </summary>
internal class Cookie
{
/// <summary>
/// Cookie name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Cookie value.
/// </summary>
public string Value { get; set; }
/// <summary>
/// Cookie domain.
/// </summary>
public string Domain { get; set; }
/// <summary>
/// Cookie path.
/// </summary>
public string Path { get; set; }
/// <summary>
/// Cookie expiration date as the number of seconds since the UNIX epoch.
/// </summary>
public double Expires { get; set; }
/// <summary>
/// Cookie size.
/// </summary>
public int Size { get; set; }
/// <summary>
/// True if cookie is http-only.
/// </summary>
public bool HttpOnly { get; set; }
/// <summary>
/// True if cookie is secure.
/// </summary>
public bool Secure { get; set; }
/// <summary>
/// True in case of session cookie.
/// </summary>
public bool Session { get; set; }
/// <summary>
/// Cookie SameSite type.
/// </summary>
public CookieSameSite SameSite { get; set; }
/// <summary>
/// Cookie Priority
/// </summary>
public CookiePriority Priority { get; set; }}
/// <summary>
/// Types of reasons why a cookie may not be stored from a response.
/// </summary>
internal enum SetCookieBlockedReason
{
[System.Runtime.Serialization.EnumMember(Value = "SecureOnly")]SecureOnly,
[System.Runtime.Serialization.EnumMember(Value = "SameSiteStrict")]SameSiteStrict,
[System.Runtime.Serialization.EnumMember(Value = "SameSiteLax")]SameSiteLax,
[System.Runtime.Serialization.EnumMember(Value = "SameSiteUnspecifiedTreatedAsLax")]SameSiteUnspecifiedTreatedAsLax,
[System.Runtime.Serialization.EnumMember(Value = "SameSiteNoneInsecure")]SameSiteNoneInsecure,
[System.Runtime.Serialization.EnumMember(Value = "UserPreferences")]UserPreferences,
[System.Runtime.Serialization.EnumMember(Value = "SyntaxError")]SyntaxError,
[System.Runtime.Serialization.EnumMember(Value = "SchemeNotSupported")]SchemeNotSupported,
[System.Runtime.Serialization.EnumMember(Value = "OverwriteSecure")]OverwriteSecure,
[System.Runtime.Serialization.EnumMember(Value = "InvalidDomain")]InvalidDomain,
[System.Runtime.Serialization.EnumMember(Value = "InvalidPrefix")]InvalidPrefix,
[System.Runtime.Serialization.EnumMember(Value = "UnknownError")]UnknownError}
/// <summary>
/// Types of reasons why a cookie may not be sent with a request.
/// </summary>
internal enum CookieBlockedReason
{
[System.Runtime.Serialization.EnumMember(Value = "SecureOnly")]SecureOnly,
[System.Runtime.Serialization.EnumMember(Value = "NotOnPath")]NotOnPath,
[System.Runtime.Serialization.EnumMember(Value = "DomainMismatch")]DomainMismatch,
[System.Runtime.Serialization.EnumMember(Value = "SameSiteStrict")]SameSiteStrict,
[System.Runtime.Serialization.EnumMember(Value = "SameSiteLax")]SameSiteLax,
[System.Runtime.Serialization.EnumMember(Value = "SameSiteUnspecifiedTreatedAsLax")]SameSiteUnspecifiedTreatedAsLax,
[System.Runtime.Serialization.EnumMember(Value = "SameSiteNoneInsecure")]SameSiteNoneInsecure,
[System.Runtime.Serialization.EnumMember(Value = "UserPreferences")]UserPreferences,
[System.Runtime.Serialization.EnumMember(Value = "UnknownError")]UnknownError}
/// <summary>
/// A cookie which was not stored from a response with the corresponding reason.
/// </summary>
internal class BlockedSetCookieWithReason
{
/// <summary>
/// The reason(s) this cookie was blocked.
/// </summary>
public SetCookieBlockedReason[] BlockedReasons { get; set; }
/// <summary>
/// The string representing this individual cookie as it would appear in the header.
/// This is not the entire "cookie" or "set-cookie" header which could have multiple cookies.
/// </summary>
public string CookieLine { get; set; }
/// <summary>
/// The cookie object which represents the cookie which was not stored. It is optional because
/// sometimes complete cookie information is not available, such as in the case of parsing
/// errors.
/// </summary>
public Cookie Cookie { get; set; }}
/// <summary>
/// A cookie with was not sent with a request with the corresponding reason.
/// </summary>
internal class BlockedCookieWithReason
{
/// <summary>
/// The reason(s) the cookie was blocked.
/// </summary>
public CookieBlockedReason[] BlockedReasons { get; set; }
/// <summary>
/// The cookie object representing the cookie which was not sent.
/// </summary>
public Cookie Cookie { get; set; }}
/// <summary>
/// Cookie parameter object
/// </summary>
internal class CookieParam
{
/// <summary>
/// Cookie name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Cookie value.
/// </summary>
public string Value { get; set; }
/// <summary>
/// The request-URI to associate with the setting of the cookie. This value can affect the
/// default domain and path values of the created cookie.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Cookie domain.
/// </summary>
public string Domain { get; set; }
/// <summary>
/// Cookie path.
/// </summary>
public string Path { get; set; }
/// <summary>
/// True if cookie is secure.
/// </summary>
public bool Secure { get; set; }
/// <summary>
/// True if cookie is http-only.
/// </summary>
public bool HttpOnly { get; set; }
/// <summary>
/// Cookie SameSite type.
/// </summary>
public CookieSameSite SameSite { get; set; }
/// <summary>
/// Cookie expiration date, session cookie if not set
/// </summary>
public double Expires { get; set; }
/// <summary>
/// Cookie Priority.
/// </summary>
public CookiePriority Priority { get; set; }}
/// <summary>
/// Authorization challenge for HTTP status code 401 or 407.
/// </summary>
internal class AuthChallenge
{
/// <summary>
/// Source of the authentication challenge.
/// </summary>
public string Source { get; set; }
/// <summary>
/// Origin of the challenger.
/// </summary>
public string Origin { get; set; }
/// <summary>
/// The authentication scheme used, such as basic or digest
/// </summary>
public string Scheme { get; set; }
/// <summary>
/// The realm of the challenge. May be empty.
/// </summary>
public string Realm { get; set; }}
/// <summary>
/// Response to an AuthChallenge.
/// </summary>
internal class AuthChallengeResponse
{
/// <summary>
/// The decision on what to do in response to the authorization challenge.  Default means
/// deferring to the default behavior of the net stack, which will likely either the Cancel
/// authentication or display a popup dialog box.
/// </summary>
public string Response { get; set; }
/// <summary>
/// The username to provide, possibly empty. Should only be set if response is
/// ProvideCredentials.
/// </summary>
public string Username { get; set; }
/// <summary>
/// The password to provide, possibly empty. Should only be set if response is
/// ProvideCredentials.
/// </summary>
public string Password { get; set; }}
/// <summary>
/// Stages of the interception to begin intercepting. Request will intercept before the request is
/// sent. Response will intercept after the response is received.
/// </summary>
internal enum InterceptionStage
{
[System.Runtime.Serialization.EnumMember(Value = "Request")]Request,
[System.Runtime.Serialization.EnumMember(Value = "HeadersReceived")]HeadersReceived}
/// <summary>
/// Request pattern for interception.
/// </summary>
internal class RequestPattern
{
/// <summary>
/// Wildcards ('*' -&gt; zero or more, '?' -&gt; exactly one) are allowed. Escape character is
/// backslash. Omitting is equivalent to "*".
/// </summary>
public string UrlPattern { get; set; }
/// <summary>
/// If set, only requests for matching resource types will be intercepted.
/// </summary>
public ResourceType ResourceType { get; set; }
/// <summary>
/// Stage at wich to begin intercepting requests. Default is Request.
/// </summary>
public InterceptionStage InterceptionStage { get; set; }}
/// <summary>
/// Information about a signed exchange signature.
/// https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
/// </summary>
internal class SignedExchangeSignature
{
/// <summary>
/// Signed exchange signature label.
/// </summary>
public string Label { get; set; }
/// <summary>
/// The hex string of signed exchange signature.
/// </summary>
public string Signature { get; set; }
/// <summary>
/// Signed exchange signature integrity.
/// </summary>
public string Integrity { get; set; }
/// <summary>
/// Signed exchange signature cert Url.
/// </summary>
public string CertUrl { get; set; }
/// <summary>
/// The hex string of signed exchange signature cert sha256.
/// </summary>
public string CertSha256 { get; set; }
/// <summary>
/// Signed exchange signature validity Url.
/// </summary>
public string ValidityUrl { get; set; }
/// <summary>
/// Signed exchange signature date.
/// </summary>
public int Date { get; set; }
/// <summary>
/// Signed exchange signature expires.
/// </summary>
public int Expires { get; set; }
/// <summary>
/// The encoded certificates.
/// </summary>
public string[] Certificates { get; set; }}
/// <summary>
/// Information about a signed exchange header.
/// https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
/// </summary>
internal class SignedExchangeHeader
{
/// <summary>
/// Signed exchange request URL.
/// </summary>
public string RequestUrl { get; set; }
/// <summary>
/// Signed exchange response code.
/// </summary>
public int ResponseCode { get; set; }
/// <summary>
/// Signed exchange response headers.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> ResponseHeaders { get; set; }
/// <summary>
/// Signed exchange response signature.
/// </summary>
public SignedExchangeSignature[] Signatures { get; set; }
/// <summary>
/// Signed exchange header integrity hash in the form of "sha256-&lt;base64-hash-value&gt;".
/// </summary>
public string HeaderIntegrity { get; set; }}
/// <summary>
/// Field type for a signed exchange related error.
/// </summary>
internal enum SignedExchangeErrorField
{
[System.Runtime.Serialization.EnumMember(Value = "signatureSig")]SignatureSig,
[System.Runtime.Serialization.EnumMember(Value = "signatureIntegrity")]SignatureIntegrity,
[System.Runtime.Serialization.EnumMember(Value = "signatureCertUrl")]SignatureCertUrl,
[System.Runtime.Serialization.EnumMember(Value = "signatureCertSha256")]SignatureCertSha256,
[System.Runtime.Serialization.EnumMember(Value = "signatureValidityUrl")]SignatureValidityUrl,
[System.Runtime.Serialization.EnumMember(Value = "signatureTimestamps")]SignatureTimestamps}
/// <summary>
/// Information about a signed exchange response.
/// </summary>
internal class SignedExchangeError
{
/// <summary>
/// Error message.
/// </summary>
public string Message { get; set; }
/// <summary>
/// The index of the signature which caused the error.
/// </summary>
public int SignatureIndex { get; set; }
/// <summary>
/// The field which caused the error.
/// </summary>
public SignedExchangeErrorField ErrorField { get; set; }}
/// <summary>
/// Information about a signed exchange response.
/// </summary>
internal class SignedExchangeInfo
{
/// <summary>
/// The outer response of signed HTTP exchange which was received from network.
/// </summary>
public Response OuterResponse { get; set; }
/// <summary>
/// Information about the signed exchange header.
/// </summary>
public SignedExchangeHeader Header { get; set; }
/// <summary>
/// Security details for the signed exchange header.
/// </summary>
public SecurityDetails SecurityDetails { get; set; }
/// <summary>
/// Errors occurred while handling the signed exchagne.
/// </summary>
public SignedExchangeError[] Errors { get; set; }}
/// <summary>
/// Tells whether clearing browser cache is supported.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.canClearBrowserCache</c>
/// </remarks>
internal class NetworkCanClearBrowserCacheRequest : IChromiumRequest<NetworkCanClearBrowserCacheResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.canClearBrowserCache";
}
/// <summary>
/// Response from <see cref="NetworkCanClearBrowserCacheRequest"/>
/// </summary>
internal class NetworkCanClearBrowserCacheResponse : IChromiumResponse
{
/// <summary>
/// True if browser cache can be cleared.
/// </summary>
public bool Result { get; set; }}
/// <summary>
/// Tells whether clearing browser cookies is supported.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.canClearBrowserCookies</c>
/// </remarks>
internal class NetworkCanClearBrowserCookiesRequest : IChromiumRequest<NetworkCanClearBrowserCookiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.canClearBrowserCookies";
}
/// <summary>
/// Response from <see cref="NetworkCanClearBrowserCookiesRequest"/>
/// </summary>
internal class NetworkCanClearBrowserCookiesResponse : IChromiumResponse
{
/// <summary>
/// True if browser cookies can be cleared.
/// </summary>
public bool Result { get; set; }}
/// <summary>
/// Tells whether emulation of network conditions is supported.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.canEmulateNetworkConditions</c>
/// </remarks>
internal class NetworkCanEmulateNetworkConditionsRequest : IChromiumRequest<NetworkCanEmulateNetworkConditionsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.canEmulateNetworkConditions";
}
/// <summary>
/// Response from <see cref="NetworkCanEmulateNetworkConditionsRequest"/>
/// </summary>
internal class NetworkCanEmulateNetworkConditionsResponse : IChromiumResponse
{
/// <summary>
/// True if emulation of network conditions is supported.
/// </summary>
public bool Result { get; set; }}
/// <summary>
/// Clears browser cache.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.clearBrowserCache</c>
/// </remarks>
internal class NetworkClearBrowserCacheRequest : IChromiumRequest<NetworkClearBrowserCacheResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.clearBrowserCache";
}
/// <summary>
/// Response from <see cref="NetworkClearBrowserCacheRequest"/>
/// </summary>
internal class NetworkClearBrowserCacheResponse : IChromiumResponse
{
}
/// <summary>
/// Clears browser cookies.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.clearBrowserCookies</c>
/// </remarks>
internal class NetworkClearBrowserCookiesRequest : IChromiumRequest<NetworkClearBrowserCookiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.clearBrowserCookies";
}
/// <summary>
/// Response from <see cref="NetworkClearBrowserCookiesRequest"/>
/// </summary>
internal class NetworkClearBrowserCookiesResponse : IChromiumResponse
{
}
/// <summary>
/// Response to Network.requestIntercepted which either modifies the request to continue with any
/// modifications, or blocks it, or completes it with the provided response bytes. If a network
/// fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
/// event will be sent with the same InterceptionId.
/// Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.continueInterceptedRequest</c>
/// </remarks>
internal class NetworkContinueInterceptedRequestRequest : IChromiumRequest<NetworkContinueInterceptedRequestResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.continueInterceptedRequest";
/// <summary>
/// 
/// </summary>
public string InterceptionId { get; set; }
/// <summary>
/// If set this causes the request to fail with the given reason. Passing `Aborted` for requests
/// marked with `isNavigationRequest` also cancels the navigation. Must not be set in response
/// to an authChallenge.
/// </summary>
public ErrorReason ErrorReason { get; set; }
/// <summary>
/// If set the requests completes using with the provided base64 encoded raw response, including
/// HTTP status line and headers etc... Must not be set in response to an authChallenge.
/// </summary>
public byte[] RawResponse { get; set; }
/// <summary>
/// If set the request url will be modified in a way that's not observable by page. Must not be
/// set in response to an authChallenge.
/// </summary>
public string Url { get; set; }
/// <summary>
/// If set this allows the request method to be overridden. Must not be set in response to an
/// authChallenge.
/// </summary>
public string Method { get; set; }
/// <summary>
/// If set this allows postData to be set. Must not be set in response to an authChallenge.
/// </summary>
public string PostData { get; set; }
/// <summary>
/// If set this allows the request headers to be changed. Must not be set in response to an
/// authChallenge.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }
/// <summary>
/// Response to a requestIntercepted with an authChallenge. Must not be set otherwise.
/// </summary>
public AuthChallengeResponse AuthChallengeResponse { get; set; }}
/// <summary>
/// Response from <see cref="NetworkContinueInterceptedRequestRequest"/>
/// </summary>
internal class NetworkContinueInterceptedRequestResponse : IChromiumResponse
{
}
/// <summary>
/// Deletes browser cookies with matching name and url or domain/path pair.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.deleteCookies</c>
/// </remarks>
internal class NetworkDeleteCookiesRequest : IChromiumRequest<NetworkDeleteCookiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.deleteCookies";
/// <summary>
/// Name of the cookies to remove.
/// </summary>
public string Name { get; set; }
/// <summary>
/// If specified, deletes all the cookies with the given name where domain and path match
/// provided URL.
/// </summary>
public string Url { get; set; }
/// <summary>
/// If specified, deletes only cookies with the exact domain.
/// </summary>
public string Domain { get; set; }
/// <summary>
/// If specified, deletes only cookies with the exact path.
/// </summary>
public string Path { get; set; }}
/// <summary>
/// Response from <see cref="NetworkDeleteCookiesRequest"/>
/// </summary>
internal class NetworkDeleteCookiesResponse : IChromiumResponse
{
}
/// <summary>
/// Disables network tracking, prevents network events from being sent to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.disable</c>
/// </remarks>
internal class NetworkDisableRequest : IChromiumRequest<NetworkDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.disable";
}
/// <summary>
/// Response from <see cref="NetworkDisableRequest"/>
/// </summary>
internal class NetworkDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Activates emulation of network conditions.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.emulateNetworkConditions</c>
/// </remarks>
internal class NetworkEmulateNetworkConditionsRequest : IChromiumRequest<NetworkEmulateNetworkConditionsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.emulateNetworkConditions";
/// <summary>
/// True to emulate internet disconnection.
/// </summary>
public bool Offline { get; set; }
/// <summary>
/// Minimum latency from request sent to response headers received (ms).
/// </summary>
public double Latency { get; set; }
/// <summary>
/// Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
/// </summary>
public double DownloadThroughput { get; set; }
/// <summary>
/// Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.
/// </summary>
public double UploadThroughput { get; set; }
/// <summary>
/// Connection type if known.
/// </summary>
public ConnectionType ConnectionType { get; set; }}
/// <summary>
/// Response from <see cref="NetworkEmulateNetworkConditionsRequest"/>
/// </summary>
internal class NetworkEmulateNetworkConditionsResponse : IChromiumResponse
{
}
/// <summary>
/// Enables network tracking, network events will now be delivered to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.enable</c>
/// </remarks>
internal class NetworkEnableRequest : IChromiumRequest<NetworkEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.enable";
/// <summary>
/// Buffer size in bytes to use when preserving network payloads (XHRs, etc).
/// </summary>
public int MaxTotalBufferSize { get; set; }
/// <summary>
/// Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).
/// </summary>
public int MaxResourceBufferSize { get; set; }
/// <summary>
/// Longest post body size (in bytes) that would be included in requestWillBeSent notification
/// </summary>
public int MaxPostDataSize { get; set; }}
/// <summary>
/// Response from <see cref="NetworkEnableRequest"/>
/// </summary>
internal class NetworkEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Returns all browser cookies. Depending on the backend support, will return detailed cookie
/// information in the `cookies` field.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.getAllCookies</c>
/// </remarks>
internal class NetworkGetAllCookiesRequest : IChromiumRequest<NetworkGetAllCookiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.getAllCookies";
}
/// <summary>
/// Response from <see cref="NetworkGetAllCookiesRequest"/>
/// </summary>
internal class NetworkGetAllCookiesResponse : IChromiumResponse
{
/// <summary>
/// Array of cookie objects.
/// </summary>
public Cookie[] Cookies { get; set; }}
/// <summary>
/// Returns the DER-encoded certificate.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.getCertificate</c>
/// </remarks>
internal class NetworkGetCertificateRequest : IChromiumRequest<NetworkGetCertificateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.getCertificate";
/// <summary>
/// Origin to get certificate for.
/// </summary>
public string Origin { get; set; }}
/// <summary>
/// Response from <see cref="NetworkGetCertificateRequest"/>
/// </summary>
internal class NetworkGetCertificateResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public string[] TableNames { get; set; }}
/// <summary>
/// Returns all browser cookies for the current URL. Depending on the backend support, will return
/// detailed cookie information in the `cookies` field.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.getCookies</c>
/// </remarks>
internal class NetworkGetCookiesRequest : IChromiumRequest<NetworkGetCookiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.getCookies";
/// <summary>
/// The list of URLs for which applicable cookies will be fetched
/// </summary>
public string[] Urls { get; set; }}
/// <summary>
/// Response from <see cref="NetworkGetCookiesRequest"/>
/// </summary>
internal class NetworkGetCookiesResponse : IChromiumResponse
{
/// <summary>
/// Array of cookie objects.
/// </summary>
public Cookie[] Cookies { get; set; }}
/// <summary>
/// Returns content served for the given request.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.getResponseBody</c>
/// </remarks>
internal class NetworkGetResponseBodyRequest : IChromiumRequest<NetworkGetResponseBodyResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.getResponseBody";
/// <summary>
/// Identifier of the network request to get content for.
/// </summary>
public string RequestId { get; set; }}
/// <summary>
/// Response from <see cref="NetworkGetResponseBodyRequest"/>
/// </summary>
internal class NetworkGetResponseBodyResponse : IChromiumResponse
{
/// <summary>
/// Response body.
/// </summary>
public string Body { get; set; }
/// <summary>
/// True, if content was sent as base64.
/// </summary>
public bool Base64Encoded { get; set; }}
/// <summary>
/// Returns post data sent with the request. Returns an error when no data was sent with the request.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.getRequestPostData</c>
/// </remarks>
internal class NetworkGetRequestPostDataRequest : IChromiumRequest<NetworkGetRequestPostDataResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.getRequestPostData";
/// <summary>
/// Identifier of the network request to get content for.
/// </summary>
public string RequestId { get; set; }}
/// <summary>
/// Response from <see cref="NetworkGetRequestPostDataRequest"/>
/// </summary>
internal class NetworkGetRequestPostDataResponse : IChromiumResponse
{
/// <summary>
/// Request body string, omitting files from multipart requests
/// </summary>
public string PostData { get; set; }}
/// <summary>
/// Returns content served for the given currently intercepted request.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.getResponseBodyForInterception</c>
/// </remarks>
internal class NetworkGetResponseBodyForInterceptionRequest : IChromiumRequest<NetworkGetResponseBodyForInterceptionResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.getResponseBodyForInterception";
/// <summary>
/// Identifier for the intercepted request to get body for.
/// </summary>
public string InterceptionId { get; set; }}
/// <summary>
/// Response from <see cref="NetworkGetResponseBodyForInterceptionRequest"/>
/// </summary>
internal class NetworkGetResponseBodyForInterceptionResponse : IChromiumResponse
{
/// <summary>
/// Response body.
/// </summary>
public string Body { get; set; }
/// <summary>
/// True, if content was sent as base64.
/// </summary>
public bool Base64Encoded { get; set; }}
/// <summary>
/// Returns a handle to the stream representing the response body. Note that after this command,
/// the intercepted request can't be continued as is -- you either need to cancel it or to provide
/// the response body. The stream only supports sequential read, IO.read will fail if the position
/// is specified.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.takeResponseBodyForInterceptionAsStream</c>
/// </remarks>
internal class NetworkTakeResponseBodyForInterceptionAsStreamRequest : IChromiumRequest<NetworkTakeResponseBodyForInterceptionAsStreamResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.takeResponseBodyForInterceptionAsStream";
/// <summary>
/// 
/// </summary>
public string InterceptionId { get; set; }}
/// <summary>
/// Response from <see cref="NetworkTakeResponseBodyForInterceptionAsStreamRequest"/>
/// </summary>
internal class NetworkTakeResponseBodyForInterceptionAsStreamResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public string Stream { get; set; }}
/// <summary>
/// This method sends a new XMLHttpRequest which is identical to the original one. The following
/// parameters should be identical: method, url, async, request body, extra headers, withCredentials
/// attribute, user, password.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.replayXHR</c>
/// </remarks>
internal class NetworkReplayXHRRequest : IChromiumRequest<NetworkReplayXHRResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.replayXHR";
/// <summary>
/// Identifier of XHR to replay.
/// </summary>
public string RequestId { get; set; }}
/// <summary>
/// Response from <see cref="NetworkReplayXHRRequest"/>
/// </summary>
internal class NetworkReplayXHRResponse : IChromiumResponse
{
}
/// <summary>
/// Searches for given string in response content.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.searchInResponseBody</c>
/// </remarks>
internal class NetworkSearchInResponseBodyRequest : IChromiumRequest<NetworkSearchInResponseBodyResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.searchInResponseBody";
/// <summary>
/// Identifier of the network response to search.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// String to search for.
/// </summary>
public string Query { get; set; }
/// <summary>
/// If true, search is case sensitive.
/// </summary>
public bool CaseSensitive { get; set; }
/// <summary>
/// If true, treats string parameter as regex.
/// </summary>
public bool IsRegex { get; set; }}
/// <summary>
/// Response from <see cref="NetworkSearchInResponseBodyRequest"/>
/// </summary>
internal class NetworkSearchInResponseBodyResponse : IChromiumResponse
{
/// <summary>
/// List of search matches.
/// </summary>
public Debugger.SearchMatch[] Result { get; set; }}
/// <summary>
/// Blocks URLs from loading.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.setBlockedURLs</c>
/// </remarks>
internal class NetworkSetBlockedURLsRequest : IChromiumRequest<NetworkSetBlockedURLsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.setBlockedURLs";
/// <summary>
/// URL patterns to block. Wildcards ('*') are allowed.
/// </summary>
public string[] Urls { get; set; }}
/// <summary>
/// Response from <see cref="NetworkSetBlockedURLsRequest"/>
/// </summary>
internal class NetworkSetBlockedURLsResponse : IChromiumResponse
{
}
/// <summary>
/// Toggles ignoring of service worker for each request.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.setBypassServiceWorker</c>
/// </remarks>
internal class NetworkSetBypassServiceWorkerRequest : IChromiumRequest<NetworkSetBypassServiceWorkerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.setBypassServiceWorker";
/// <summary>
/// Bypass service worker and load from network.
/// </summary>
public bool Bypass { get; set; }}
/// <summary>
/// Response from <see cref="NetworkSetBypassServiceWorkerRequest"/>
/// </summary>
internal class NetworkSetBypassServiceWorkerResponse : IChromiumResponse
{
}
/// <summary>
/// Toggles ignoring cache for each request. If `true`, cache will not be used.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.setCacheDisabled</c>
/// </remarks>
internal class NetworkSetCacheDisabledRequest : IChromiumRequest<NetworkSetCacheDisabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.setCacheDisabled";
/// <summary>
/// Cache disabled state.
/// </summary>
public bool CacheDisabled { get; set; }}
/// <summary>
/// Response from <see cref="NetworkSetCacheDisabledRequest"/>
/// </summary>
internal class NetworkSetCacheDisabledResponse : IChromiumResponse
{
}
/// <summary>
/// Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.setCookie</c>
/// </remarks>
internal class NetworkSetCookieRequest : IChromiumRequest<NetworkSetCookieResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.setCookie";
/// <summary>
/// Cookie name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Cookie value.
/// </summary>
public string Value { get; set; }
/// <summary>
/// The request-URI to associate with the setting of the cookie. This value can affect the
/// default domain and path values of the created cookie.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Cookie domain.
/// </summary>
public string Domain { get; set; }
/// <summary>
/// Cookie path.
/// </summary>
public string Path { get; set; }
/// <summary>
/// True if cookie is secure.
/// </summary>
public bool Secure { get; set; }
/// <summary>
/// True if cookie is http-only.
/// </summary>
public bool HttpOnly { get; set; }
/// <summary>
/// Cookie SameSite type.
/// </summary>
public CookieSameSite SameSite { get; set; }
/// <summary>
/// Cookie expiration date, session cookie if not set
/// </summary>
public double Expires { get; set; }
/// <summary>
/// Cookie Priority type.
/// </summary>
public CookiePriority Priority { get; set; }}
/// <summary>
/// Response from <see cref="NetworkSetCookieRequest"/>
/// </summary>
internal class NetworkSetCookieResponse : IChromiumResponse
{
/// <summary>
/// True if successfully set cookie.
/// </summary>
public bool Success { get; set; }}
/// <summary>
/// Sets given cookies.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.setCookies</c>
/// </remarks>
internal class NetworkSetCookiesRequest : IChromiumRequest<NetworkSetCookiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.setCookies";
/// <summary>
/// Cookies to be set.
/// </summary>
public CookieParam[] Cookies { get; set; }}
/// <summary>
/// Response from <see cref="NetworkSetCookiesRequest"/>
/// </summary>
internal class NetworkSetCookiesResponse : IChromiumResponse
{
}
/// <summary>
/// For testing.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.setDataSizeLimitsForTest</c>
/// </remarks>
internal class NetworkSetDataSizeLimitsForTestRequest : IChromiumRequest<NetworkSetDataSizeLimitsForTestResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.setDataSizeLimitsForTest";
/// <summary>
/// Maximum total buffer size.
/// </summary>
public int MaxTotalSize { get; set; }
/// <summary>
/// Maximum per-resource size.
/// </summary>
public int MaxResourceSize { get; set; }}
/// <summary>
/// Response from <see cref="NetworkSetDataSizeLimitsForTestRequest"/>
/// </summary>
internal class NetworkSetDataSizeLimitsForTestResponse : IChromiumResponse
{
}
/// <summary>
/// Specifies whether to always send extra HTTP headers with the requests from this page.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.setExtraHTTPHeaders</c>
/// </remarks>
internal class NetworkSetExtraHTTPHeadersRequest : IChromiumRequest<NetworkSetExtraHTTPHeadersResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.setExtraHTTPHeaders";
/// <summary>
/// Map with extra HTTP headers.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }}
/// <summary>
/// Response from <see cref="NetworkSetExtraHTTPHeadersRequest"/>
/// </summary>
internal class NetworkSetExtraHTTPHeadersResponse : IChromiumResponse
{
}
/// <summary>
/// Sets the requests to intercept that match the provided patterns and optionally resource types.
/// Deprecated, please use Fetch.enable instead.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.setRequestInterception</c>
/// </remarks>
internal class NetworkSetRequestInterceptionRequest : IChromiumRequest<NetworkSetRequestInterceptionResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.setRequestInterception";
/// <summary>
/// Requests matching any of these patterns will be forwarded and wait for the corresponding
/// continueInterceptedRequest call.
/// </summary>
public RequestPattern[] Patterns { get; set; }}
/// <summary>
/// Response from <see cref="NetworkSetRequestInterceptionRequest"/>
/// </summary>
internal class NetworkSetRequestInterceptionResponse : IChromiumResponse
{
}
/// <summary>
/// Allows overriding user agent with the given string.
/// </summary>
/// <remarks>
/// Will send the command <c>Network.setUserAgentOverride</c>
/// </remarks>
internal class NetworkSetUserAgentOverrideRequest : IChromiumRequest<NetworkSetUserAgentOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Network.setUserAgentOverride";
/// <summary>
/// User agent to use.
/// </summary>
public string UserAgent { get; set; }
/// <summary>
/// Browser langugage to emulate.
/// </summary>
public string AcceptLanguage { get; set; }
/// <summary>
/// The platform navigator.platform should return.
/// </summary>
public string Platform { get; set; }}
/// <summary>
/// Response from <see cref="NetworkSetUserAgentOverrideRequest"/>
/// </summary>
internal class NetworkSetUserAgentOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// Fired when data chunk was received over the network.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.dataReceived</c>
/// </remarks>
internal class NetworkDataReceivedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.dataReceived";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// Data chunk length.
/// </summary>
public int DataLength { get; set; }
/// <summary>
/// Actual bytes received (might be less than dataLength for compressed encodings).
/// </summary>
public int EncodedDataLength { get; set; }}
/// <summary>
/// Fired when EventSource message is received.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.eventSourceMessageReceived</c>
/// </remarks>
internal class NetworkEventSourceMessageReceivedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.eventSourceMessageReceived";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// Message type.
/// </summary>
public string EventName { get; set; }
/// <summary>
/// Message identifier.
/// </summary>
public string EventId { get; set; }
/// <summary>
/// Message content.
/// </summary>
public string Data { get; set; }}
/// <summary>
/// Fired when HTTP request has failed to load.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.loadingFailed</c>
/// </remarks>
internal class NetworkLoadingFailedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.loadingFailed";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// Resource type.
/// </summary>
public ResourceType Type { get; set; }
/// <summary>
/// User friendly error message.
/// </summary>
public string ErrorText { get; set; }
/// <summary>
/// True if loading was canceled.
/// </summary>
public bool Canceled { get; set; }
/// <summary>
/// The reason why loading was blocked, if any.
/// </summary>
public BlockedReason BlockedReason { get; set; }}
/// <summary>
/// Fired when HTTP request has finished loading.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.loadingFinished</c>
/// </remarks>
internal class NetworkLoadingFinishedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.loadingFinished";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// Total number of bytes received for this request.
/// </summary>
public double EncodedDataLength { get; set; }
/// <summary>
/// Set when 1) response was blocked by Cross-Origin Read Blocking and also
/// 2) this needs to be reported to the DevTools console.
/// </summary>
public bool ShouldReportCorbBlocking { get; set; }}
/// <summary>
/// Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
/// mocked.
/// Deprecated, use Fetch.requestPaused instead.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.requestIntercepted</c>
/// </remarks>
internal class NetworkRequestInterceptedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.requestIntercepted";
/// <summary>
/// Each request the page makes will have a unique id, however if any redirects are encountered
/// while processing that fetch, they will be reported with the same id as the original fetch.
/// Likewise if HTTP authentication is needed then the same fetch id will be used.
/// </summary>
public string InterceptionId { get; set; }
/// <summary>
/// 
/// </summary>
public Request Request { get; set; }
/// <summary>
/// The id of the frame that initiated the request.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// How the requested resource will be used.
/// </summary>
public ResourceType ResourceType { get; set; }
/// <summary>
/// Whether this is a navigation request, which can abort the navigation completely.
/// </summary>
public bool IsNavigationRequest { get; set; }
/// <summary>
/// Set if the request is a navigation that will result in a download.
/// Only present after response is received from the server (i.e. HeadersReceived stage).
/// </summary>
public bool IsDownload { get; set; }
/// <summary>
/// Redirect location, only sent if a redirect was intercepted.
/// </summary>
public string RedirectUrl { get; set; }
/// <summary>
/// Details of the Authorization Challenge encountered. If this is set then
/// continueInterceptedRequest must contain an authChallengeResponse.
/// </summary>
public AuthChallenge AuthChallenge { get; set; }
/// <summary>
/// Response error if intercepted at response stage or if redirect occurred while intercepting
/// request.
/// </summary>
public ErrorReason ResponseErrorReason { get; set; }
/// <summary>
/// Response code if intercepted at response stage or if redirect occurred while intercepting
/// request or auth retry occurred.
/// </summary>
public int ResponseStatusCode { get; set; }
/// <summary>
/// Response headers if intercepted at the response stage or if redirect occurred while
/// intercepting request or auth retry occurred.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> ResponseHeaders { get; set; }
/// <summary>
/// If the intercepted request had a corresponding requestWillBeSent event fired for it, then
/// this requestId will be the same as the requestId present in the requestWillBeSent event.
/// </summary>
public string RequestId { get; set; }}
/// <summary>
/// Fired if request ended up loading from cache.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.requestServedFromCache</c>
/// </remarks>
internal class NetworkRequestServedFromCacheChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.requestServedFromCache";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }}
/// <summary>
/// Fired when page is about to send HTTP request.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.requestWillBeSent</c>
/// </remarks>
internal class NetworkRequestWillBeSentChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.requestWillBeSent";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Loader identifier. Empty string if the request is fetched from worker.
/// </summary>
public string LoaderId { get; set; }
/// <summary>
/// URL of the document this request is loaded for.
/// </summary>
public string DocumentURL { get; set; }
/// <summary>
/// Request data.
/// </summary>
public Request Request { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double WallTime { get; set; }
/// <summary>
/// Request initiator.
/// </summary>
public Initiator Initiator { get; set; }
/// <summary>
/// Redirect response data.
/// </summary>
public Response RedirectResponse { get; set; }
/// <summary>
/// Type of this resource.
/// </summary>
public ResourceType Type { get; set; }
/// <summary>
/// Frame identifier.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Whether the request is initiated by a user gesture. Defaults to false.
/// </summary>
public bool HasUserGesture { get; set; }}
/// <summary>
/// Fired when resource loading priority is changed
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.resourceChangedPriority</c>
/// </remarks>
internal class NetworkResourceChangedPriorityChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.resourceChangedPriority";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// New priority
/// </summary>
public ResourcePriority NewPriority { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double Timestamp { get; set; }}
/// <summary>
/// Fired when a signed exchange was received over the network
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.signedExchangeReceived</c>
/// </remarks>
internal class NetworkSignedExchangeReceivedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.signedExchangeReceived";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Information about the signed exchange response.
/// </summary>
public SignedExchangeInfo Info { get; set; }}
/// <summary>
/// Fired when HTTP response is available.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.responseReceived</c>
/// </remarks>
internal class NetworkResponseReceivedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.responseReceived";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Loader identifier. Empty string if the request is fetched from worker.
/// </summary>
public string LoaderId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// Resource type.
/// </summary>
public ResourceType Type { get; set; }
/// <summary>
/// Response data.
/// </summary>
public Response Response { get; set; }
/// <summary>
/// Frame identifier.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Fired when WebSocket is closed.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.webSocketClosed</c>
/// </remarks>
internal class NetworkWebSocketClosedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.webSocketClosed";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double Timestamp { get; set; }}
/// <summary>
/// Fired upon WebSocket creation.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.webSocketCreated</c>
/// </remarks>
internal class NetworkWebSocketCreatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.webSocketCreated";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// WebSocket request URL.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Request initiator.
/// </summary>
public Initiator Initiator { get; set; }}
/// <summary>
/// Fired when WebSocket message error occurs.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.webSocketFrameError</c>
/// </remarks>
internal class NetworkWebSocketFrameErrorChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.webSocketFrameError";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// WebSocket error message.
/// </summary>
public string ErrorMessage { get; set; }}
/// <summary>
/// Fired when WebSocket message is received.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.webSocketFrameReceived</c>
/// </remarks>
internal class NetworkWebSocketFrameReceivedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.webSocketFrameReceived";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// WebSocket response data.
/// </summary>
public WebSocketFrame Response { get; set; }}
/// <summary>
/// Fired when WebSocket message is sent.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.webSocketFrameSent</c>
/// </remarks>
internal class NetworkWebSocketFrameSentChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.webSocketFrameSent";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// WebSocket response data.
/// </summary>
public WebSocketFrame Response { get; set; }}
/// <summary>
/// Fired when WebSocket handshake response becomes available.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.webSocketHandshakeResponseReceived</c>
/// </remarks>
internal class NetworkWebSocketHandshakeResponseReceivedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.webSocketHandshakeResponseReceived";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// WebSocket response data.
/// </summary>
public WebSocketResponse Response { get; set; }}
/// <summary>
/// Fired when WebSocket is about to initiate handshake.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.webSocketWillSendHandshakeRequest</c>
/// </remarks>
internal class NetworkWebSocketWillSendHandshakeRequestChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.webSocketWillSendHandshakeRequest";
/// <summary>
/// Request identifier.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Timestamp.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// UTC Timestamp.
/// </summary>
public double WallTime { get; set; }
/// <summary>
/// WebSocket request data.
/// </summary>
public WebSocketRequest Request { get; set; }}
/// <summary>
/// Fired when additional information about a requestWillBeSent event is available from the
/// network stack. Not every requestWillBeSent event will have an additional
/// requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent
/// or requestWillBeSentExtraInfo will be fired first for the same request.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.requestWillBeSentExtraInfo</c>
/// </remarks>
internal class NetworkRequestWillBeSentExtraInfoChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.requestWillBeSentExtraInfo";
/// <summary>
/// Request identifier. Used to match this information to an existing requestWillBeSent event.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// A list of cookies which will not be sent with this request along with corresponding reasons
/// for blocking.
/// </summary>
public BlockedCookieWithReason[] BlockedCookies { get; set; }
/// <summary>
/// Raw request headers as they will be sent over the wire.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }}
/// <summary>
/// Fired when additional information about a responseReceived event is available from the network
/// stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for
/// it, and responseReceivedExtraInfo may be fired before or after responseReceived.
/// </summary>
/// <remarks>
/// Matches on the event <c>Network.responseReceivedExtraInfo</c>
/// </remarks>
internal class NetworkResponseReceivedExtraInfoChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Network.responseReceivedExtraInfo";
/// <summary>
/// Request identifier. Used to match this information to another responseReceived event.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// A list of cookies which were not stored from the response along with the corresponding
/// reasons for blocking. The cookies here may not be valid due to syntax errors, which
/// are represented by the invalid cookie line string instead of a proper cookie.
/// </summary>
public BlockedSetCookieWithReason[] BlockedCookies { get; set; }
/// <summary>
/// Raw response headers as they were received over the wire.
/// </summary>
public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }
/// <summary>
/// Raw response header text as it was received over the wire. The raw text may not always be
/// available, such as in the case of HTTP/2 or QUIC.
/// </summary>
public string HeadersText { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Overlay
{
/// <summary>
/// Configuration data for the highlighting of page elements.
/// </summary>
internal class HighlightConfig
{
/// <summary>
/// Whether the node info tooltip should be shown (default: false).
/// </summary>
public bool ShowInfo { get; set; }
/// <summary>
/// Whether the node styles in the tooltip (default: false).
/// </summary>
public bool ShowStyles { get; set; }
/// <summary>
/// Whether the rulers should be shown (default: false).
/// </summary>
public bool ShowRulers { get; set; }
/// <summary>
/// Whether the extension lines from node to the rulers should be shown (default: false).
/// </summary>
public bool ShowExtensionLines { get; set; }
/// <summary>
/// The content box highlight fill color (default: transparent).
/// </summary>
public DOM.RGBA ContentColor { get; set; }
/// <summary>
/// The padding highlight fill color (default: transparent).
/// </summary>
public DOM.RGBA PaddingColor { get; set; }
/// <summary>
/// The border highlight fill color (default: transparent).
/// </summary>
public DOM.RGBA BorderColor { get; set; }
/// <summary>
/// The margin highlight fill color (default: transparent).
/// </summary>
public DOM.RGBA MarginColor { get; set; }
/// <summary>
/// The event target element highlight fill color (default: transparent).
/// </summary>
public DOM.RGBA EventTargetColor { get; set; }
/// <summary>
/// The shape outside fill color (default: transparent).
/// </summary>
public DOM.RGBA ShapeColor { get; set; }
/// <summary>
/// The shape margin fill color (default: transparent).
/// </summary>
public DOM.RGBA ShapeMarginColor { get; set; }
/// <summary>
/// The grid layout color (default: transparent).
/// </summary>
public DOM.RGBA CssGridColor { get; set; }}
/// <summary>
/// 
/// </summary>
internal enum InspectMode
{
[System.Runtime.Serialization.EnumMember(Value = "searchForNode")]SearchForNode,
[System.Runtime.Serialization.EnumMember(Value = "searchForUAShadowDOM")]SearchForUAShadowDOM,
[System.Runtime.Serialization.EnumMember(Value = "captureAreaScreenshot")]CaptureAreaScreenshot,
[System.Runtime.Serialization.EnumMember(Value = "showDistances")]ShowDistances,
[System.Runtime.Serialization.EnumMember(Value = "none")]None}
/// <summary>
/// Disables domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.disable</c>
/// </remarks>
internal class OverlayDisableRequest : IChromiumRequest<OverlayDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.disable";
}
/// <summary>
/// Response from <see cref="OverlayDisableRequest"/>
/// </summary>
internal class OverlayDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.enable</c>
/// </remarks>
internal class OverlayEnableRequest : IChromiumRequest<OverlayEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.enable";
}
/// <summary>
/// Response from <see cref="OverlayEnableRequest"/>
/// </summary>
internal class OverlayEnableResponse : IChromiumResponse
{
}
/// <summary>
/// For testing.
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.getHighlightObjectForTest</c>
/// </remarks>
internal class OverlayGetHighlightObjectForTestRequest : IChromiumRequest<OverlayGetHighlightObjectForTestResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.getHighlightObjectForTest";
/// <summary>
/// Id of the node to get highlight object for.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Whether to include distance info.
/// </summary>
public bool IncludeDistance { get; set; }
/// <summary>
/// Whether to include style info.
/// </summary>
public bool IncludeStyle { get; set; }}
/// <summary>
/// Response from <see cref="OverlayGetHighlightObjectForTestRequest"/>
/// </summary>
internal class OverlayGetHighlightObjectForTestResponse : IChromiumResponse
{
/// <summary>
/// Highlight data for the node.
/// </summary>
public JsonElement? Highlight { get; set; }}
/// <summary>
/// Hides any highlight.
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.hideHighlight</c>
/// </remarks>
internal class OverlayHideHighlightRequest : IChromiumRequest<OverlayHideHighlightResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.hideHighlight";
}
/// <summary>
/// Response from <see cref="OverlayHideHighlightRequest"/>
/// </summary>
internal class OverlayHideHighlightResponse : IChromiumResponse
{
}
/// <summary>
/// Highlights owner element of the frame with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.highlightFrame</c>
/// </remarks>
internal class OverlayHighlightFrameRequest : IChromiumRequest<OverlayHighlightFrameResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.highlightFrame";
/// <summary>
/// Identifier of the frame to highlight.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// The content box highlight fill color (default: transparent).
/// </summary>
public DOM.RGBA ContentColor { get; set; }
/// <summary>
/// The content box highlight outline color (default: transparent).
/// </summary>
public DOM.RGBA ContentOutlineColor { get; set; }}
/// <summary>
/// Response from <see cref="OverlayHighlightFrameRequest"/>
/// </summary>
internal class OverlayHighlightFrameResponse : IChromiumResponse
{
}
/// <summary>
/// Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
/// objectId must be specified.
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.highlightNode</c>
/// </remarks>
internal class OverlayHighlightNodeRequest : IChromiumRequest<OverlayHighlightNodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.highlightNode";
/// <summary>
/// A descriptor for the highlight appearance.
/// </summary>
public HighlightConfig HighlightConfig { get; set; }
/// <summary>
/// Identifier of the node to highlight.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Identifier of the backend node to highlight.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// JavaScript object id of the node to be highlighted.
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// Selectors to highlight relevant nodes.
/// </summary>
public string Selector { get; set; }}
/// <summary>
/// Response from <see cref="OverlayHighlightNodeRequest"/>
/// </summary>
internal class OverlayHighlightNodeResponse : IChromiumResponse
{
}
/// <summary>
/// Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.highlightQuad</c>
/// </remarks>
internal class OverlayHighlightQuadRequest : IChromiumRequest<OverlayHighlightQuadResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.highlightQuad";
/// <summary>
/// Quad to highlight
/// </summary>
public double[] Quad { get; set; }
/// <summary>
/// The highlight fill color (default: transparent).
/// </summary>
public DOM.RGBA Color { get; set; }
/// <summary>
/// The highlight outline color (default: transparent).
/// </summary>
public DOM.RGBA OutlineColor { get; set; }}
/// <summary>
/// Response from <see cref="OverlayHighlightQuadRequest"/>
/// </summary>
internal class OverlayHighlightQuadResponse : IChromiumResponse
{
}
/// <summary>
/// Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.highlightRect</c>
/// </remarks>
internal class OverlayHighlightRectRequest : IChromiumRequest<OverlayHighlightRectResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.highlightRect";
/// <summary>
/// X coordinate
/// </summary>
public int X { get; set; }
/// <summary>
/// Y coordinate
/// </summary>
public int Y { get; set; }
/// <summary>
/// Rectangle width
/// </summary>
public int Width { get; set; }
/// <summary>
/// Rectangle height
/// </summary>
public int Height { get; set; }
/// <summary>
/// The highlight fill color (default: transparent).
/// </summary>
public DOM.RGBA Color { get; set; }
/// <summary>
/// The highlight outline color (default: transparent).
/// </summary>
public DOM.RGBA OutlineColor { get; set; }}
/// <summary>
/// Response from <see cref="OverlayHighlightRectRequest"/>
/// </summary>
internal class OverlayHighlightRectResponse : IChromiumResponse
{
}
/// <summary>
/// Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.
/// Backend then generates 'inspectNodeRequested' event upon element selection.
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.setInspectMode</c>
/// </remarks>
internal class OverlaySetInspectModeRequest : IChromiumRequest<OverlaySetInspectModeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.setInspectMode";
/// <summary>
/// Set an inspection mode.
/// </summary>
public InspectMode Mode { get; set; }
/// <summary>
/// A descriptor for the highlight appearance of hovered-over nodes. May be omitted if `enabled
/// == false`.
/// </summary>
public HighlightConfig HighlightConfig { get; set; }}
/// <summary>
/// Response from <see cref="OverlaySetInspectModeRequest"/>
/// </summary>
internal class OverlaySetInspectModeResponse : IChromiumResponse
{
}
/// <summary>
/// Highlights owner element of all frames detected to be ads.
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.setShowAdHighlights</c>
/// </remarks>
internal class OverlaySetShowAdHighlightsRequest : IChromiumRequest<OverlaySetShowAdHighlightsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.setShowAdHighlights";
/// <summary>
/// True for showing ad highlights
/// </summary>
public bool Show { get; set; }}
/// <summary>
/// Response from <see cref="OverlaySetShowAdHighlightsRequest"/>
/// </summary>
internal class OverlaySetShowAdHighlightsResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.setPausedInDebuggerMessage</c>
/// </remarks>
internal class OverlaySetPausedInDebuggerMessageRequest : IChromiumRequest<OverlaySetPausedInDebuggerMessageResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.setPausedInDebuggerMessage";
/// <summary>
/// The message to display, also triggers resume and step over controls.
/// </summary>
public string Message { get; set; }}
/// <summary>
/// Response from <see cref="OverlaySetPausedInDebuggerMessageRequest"/>
/// </summary>
internal class OverlaySetPausedInDebuggerMessageResponse : IChromiumResponse
{
}
/// <summary>
/// Requests that backend shows debug borders on layers
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.setShowDebugBorders</c>
/// </remarks>
internal class OverlaySetShowDebugBordersRequest : IChromiumRequest<OverlaySetShowDebugBordersResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.setShowDebugBorders";
/// <summary>
/// True for showing debug borders
/// </summary>
public bool Show { get; set; }}
/// <summary>
/// Response from <see cref="OverlaySetShowDebugBordersRequest"/>
/// </summary>
internal class OverlaySetShowDebugBordersResponse : IChromiumResponse
{
}
/// <summary>
/// Requests that backend shows the FPS counter
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.setShowFPSCounter</c>
/// </remarks>
internal class OverlaySetShowFPSCounterRequest : IChromiumRequest<OverlaySetShowFPSCounterResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.setShowFPSCounter";
/// <summary>
/// True for showing the FPS counter
/// </summary>
public bool Show { get; set; }}
/// <summary>
/// Response from <see cref="OverlaySetShowFPSCounterRequest"/>
/// </summary>
internal class OverlaySetShowFPSCounterResponse : IChromiumResponse
{
}
/// <summary>
/// Requests that backend shows paint rectangles
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.setShowPaintRects</c>
/// </remarks>
internal class OverlaySetShowPaintRectsRequest : IChromiumRequest<OverlaySetShowPaintRectsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.setShowPaintRects";
/// <summary>
/// True for showing paint rectangles
/// </summary>
public bool Result { get; set; }}
/// <summary>
/// Response from <see cref="OverlaySetShowPaintRectsRequest"/>
/// </summary>
internal class OverlaySetShowPaintRectsResponse : IChromiumResponse
{
}
/// <summary>
/// Requests that backend shows layout shift regions
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.setShowLayoutShiftRegions</c>
/// </remarks>
internal class OverlaySetShowLayoutShiftRegionsRequest : IChromiumRequest<OverlaySetShowLayoutShiftRegionsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.setShowLayoutShiftRegions";
/// <summary>
/// True for showing layout shift regions
/// </summary>
public bool Result { get; set; }}
/// <summary>
/// Response from <see cref="OverlaySetShowLayoutShiftRegionsRequest"/>
/// </summary>
internal class OverlaySetShowLayoutShiftRegionsResponse : IChromiumResponse
{
}
/// <summary>
/// Requests that backend shows scroll bottleneck rects
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.setShowScrollBottleneckRects</c>
/// </remarks>
internal class OverlaySetShowScrollBottleneckRectsRequest : IChromiumRequest<OverlaySetShowScrollBottleneckRectsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.setShowScrollBottleneckRects";
/// <summary>
/// True for showing scroll bottleneck rects
/// </summary>
public bool Show { get; set; }}
/// <summary>
/// Response from <see cref="OverlaySetShowScrollBottleneckRectsRequest"/>
/// </summary>
internal class OverlaySetShowScrollBottleneckRectsResponse : IChromiumResponse
{
}
/// <summary>
/// Requests that backend shows hit-test borders on layers
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.setShowHitTestBorders</c>
/// </remarks>
internal class OverlaySetShowHitTestBordersRequest : IChromiumRequest<OverlaySetShowHitTestBordersResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.setShowHitTestBorders";
/// <summary>
/// True for showing hit-test borders
/// </summary>
public bool Show { get; set; }}
/// <summary>
/// Response from <see cref="OverlaySetShowHitTestBordersRequest"/>
/// </summary>
internal class OverlaySetShowHitTestBordersResponse : IChromiumResponse
{
}
/// <summary>
/// Paints viewport size upon main frame resize.
/// </summary>
/// <remarks>
/// Will send the command <c>Overlay.setShowViewportSizeOnResize</c>
/// </remarks>
internal class OverlaySetShowViewportSizeOnResizeRequest : IChromiumRequest<OverlaySetShowViewportSizeOnResizeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Overlay.setShowViewportSizeOnResize";
/// <summary>
/// Whether to paint size or not.
/// </summary>
public bool Show { get; set; }}
/// <summary>
/// Response from <see cref="OverlaySetShowViewportSizeOnResizeRequest"/>
/// </summary>
internal class OverlaySetShowViewportSizeOnResizeResponse : IChromiumResponse
{
}
/// <summary>
/// Fired when the node should be inspected. This happens after call to `setInspectMode` or when
/// user manually inspects an element.
/// </summary>
/// <remarks>
/// Matches on the event <c>Overlay.inspectNodeRequested</c>
/// </remarks>
internal class OverlayInspectNodeRequestedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Overlay.inspectNodeRequested";
/// <summary>
/// Id of the node to inspect.
/// </summary>
public int BackendNodeId { get; set; }}
/// <summary>
/// Fired when the node should be highlighted. This happens after call to `setInspectMode`.
/// </summary>
/// <remarks>
/// Matches on the event <c>Overlay.nodeHighlightRequested</c>
/// </remarks>
internal class OverlayNodeHighlightRequestedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Overlay.nodeHighlightRequested";
/// <summary>
/// 
/// </summary>
public int NodeId { get; set; }}
/// <summary>
/// Fired when user asks to capture screenshot of some area on the page.
/// </summary>
/// <remarks>
/// Matches on the event <c>Overlay.screenshotRequested</c>
/// </remarks>
internal class OverlayScreenshotRequestedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Overlay.screenshotRequested";
/// <summary>
/// Viewport to capture, in device independent pixels (dip).
/// </summary>
public Page.Viewport Viewport { get; set; }}
/// <summary>
/// Fired when user cancels the inspect mode.
/// </summary>
/// <remarks>
/// Matches on the event <c>Overlay.inspectModeCanceled</c>
/// </remarks>
internal class OverlayInspectModeCanceledChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Overlay.inspectModeCanceled";
}
}
namespace PlaywrightSharp.Chromium.Protocol.Page
{
/// <summary>
/// Information about the Frame on the page.
/// </summary>
internal class Frame
{
/// <summary>
/// Frame unique identifier.
/// </summary>
public string Id { get; set; }
/// <summary>
/// Parent frame identifier.
/// </summary>
public string ParentId { get; set; }
/// <summary>
/// Identifier of the loader associated with this frame.
/// </summary>
public string LoaderId { get; set; }
/// <summary>
/// Frame's name as specified in the tag.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Frame document's URL without fragment.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Frame document's URL fragment including the '#'.
/// </summary>
public string UrlFragment { get; set; }
/// <summary>
/// Frame document's security origin.
/// </summary>
public string SecurityOrigin { get; set; }
/// <summary>
/// Frame document's mimeType as determined by the browser.
/// </summary>
public string MimeType { get; set; }
/// <summary>
/// If the frame failed to load, this contains the URL that could not be loaded. Note that unlike url above, this URL may contain a fragment.
/// </summary>
public string UnreachableUrl { get; set; }}
/// <summary>
/// Information about the Resource on the page.
/// </summary>
internal class FrameResource
{
/// <summary>
/// Resource URL.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Type of this resource.
/// </summary>
public Network.ResourceType Type { get; set; }
/// <summary>
/// Resource mimeType as determined by the browser.
/// </summary>
public string MimeType { get; set; }
/// <summary>
/// last-modified timestamp as reported by server.
/// </summary>
public double LastModified { get; set; }
/// <summary>
/// Resource content size.
/// </summary>
public double ContentSize { get; set; }
/// <summary>
/// True if the resource failed to load.
/// </summary>
public bool Failed { get; set; }
/// <summary>
/// True if the resource was canceled during loading.
/// </summary>
public bool Canceled { get; set; }}
/// <summary>
/// Information about the Frame hierarchy along with their cached resources.
/// </summary>
internal class FrameResourceTree
{
/// <summary>
/// Frame information for this tree item.
/// </summary>
public Frame Frame { get; set; }
/// <summary>
/// Child frames.
/// </summary>
public FrameResourceTree[] ChildFrames { get; set; }
/// <summary>
/// Information about frame resources.
/// </summary>
public FrameResource[] Resources { get; set; }}
/// <summary>
/// Information about the Frame hierarchy.
/// </summary>
internal class FrameTree
{
/// <summary>
/// Frame information for this tree item.
/// </summary>
public Frame Frame { get; set; }
/// <summary>
/// Child frames.
/// </summary>
public FrameTree[] ChildFrames { get; set; }}
/// <summary>
/// Transition type.
/// </summary>
internal enum TransitionType
{
[System.Runtime.Serialization.EnumMember(Value = "link")]Link,
[System.Runtime.Serialization.EnumMember(Value = "typed")]Typed,
[System.Runtime.Serialization.EnumMember(Value = "address_bar")]AddressBar,
[System.Runtime.Serialization.EnumMember(Value = "auto_bookmark")]AutoBookmark,
[System.Runtime.Serialization.EnumMember(Value = "auto_subframe")]AutoSubframe,
[System.Runtime.Serialization.EnumMember(Value = "manual_subframe")]ManualSubframe,
[System.Runtime.Serialization.EnumMember(Value = "generated")]Generated,
[System.Runtime.Serialization.EnumMember(Value = "auto_toplevel")]AutoToplevel,
[System.Runtime.Serialization.EnumMember(Value = "form_submit")]FormSubmit,
[System.Runtime.Serialization.EnumMember(Value = "reload")]Reload,
[System.Runtime.Serialization.EnumMember(Value = "keyword")]Keyword,
[System.Runtime.Serialization.EnumMember(Value = "keyword_generated")]KeywordGenerated,
[System.Runtime.Serialization.EnumMember(Value = "other")]Other}
/// <summary>
/// Navigation history entry.
/// </summary>
internal class NavigationEntry
{
/// <summary>
/// Unique id of the navigation history entry.
/// </summary>
public int Id { get; set; }
/// <summary>
/// URL of the navigation history entry.
/// </summary>
public string Url { get; set; }
/// <summary>
/// URL that the user typed in the url bar.
/// </summary>
public string UserTypedURL { get; set; }
/// <summary>
/// Title of the navigation history entry.
/// </summary>
public string Title { get; set; }
/// <summary>
/// Transition type.
/// </summary>
public TransitionType TransitionType { get; set; }}
/// <summary>
/// Screencast frame metadata.
/// </summary>
internal class ScreencastFrameMetadata
{
/// <summary>
/// Top offset in DIP.
/// </summary>
public double OffsetTop { get; set; }
/// <summary>
/// Page scale factor.
/// </summary>
public double PageScaleFactor { get; set; }
/// <summary>
/// Device screen width in DIP.
/// </summary>
public double DeviceWidth { get; set; }
/// <summary>
/// Device screen height in DIP.
/// </summary>
public double DeviceHeight { get; set; }
/// <summary>
/// Position of horizontal scroll in CSS pixels.
/// </summary>
public double ScrollOffsetX { get; set; }
/// <summary>
/// Position of vertical scroll in CSS pixels.
/// </summary>
public double ScrollOffsetY { get; set; }
/// <summary>
/// Frame swap timestamp.
/// </summary>
public double Timestamp { get; set; }}
/// <summary>
/// Javascript dialog type.
/// </summary>
internal enum DialogType
{
[System.Runtime.Serialization.EnumMember(Value = "alert")]Alert,
[System.Runtime.Serialization.EnumMember(Value = "confirm")]Confirm,
[System.Runtime.Serialization.EnumMember(Value = "prompt")]Prompt,
[System.Runtime.Serialization.EnumMember(Value = "beforeunload")]Beforeunload}
/// <summary>
/// Error while paring app manifest.
/// </summary>
internal class AppManifestError
{
/// <summary>
/// Error message.
/// </summary>
public string Message { get; set; }
/// <summary>
/// If criticial, this is a non-recoverable parse error.
/// </summary>
public int Critical { get; set; }
/// <summary>
/// Error line.
/// </summary>
public int Line { get; set; }
/// <summary>
/// Error column.
/// </summary>
public int Column { get; set; }}
/// <summary>
/// Parsed app manifest properties.
/// </summary>
internal class AppManifestParsedProperties
{
/// <summary>
/// Computed scope value
/// </summary>
public string Scope { get; set; }}
/// <summary>
/// Layout viewport position and dimensions.
/// </summary>
internal class LayoutViewport
{
/// <summary>
/// Horizontal offset relative to the document (CSS pixels).
/// </summary>
public int PageX { get; set; }
/// <summary>
/// Vertical offset relative to the document (CSS pixels).
/// </summary>
public int PageY { get; set; }
/// <summary>
/// Width (CSS pixels), excludes scrollbar if present.
/// </summary>
public int ClientWidth { get; set; }
/// <summary>
/// Height (CSS pixels), excludes scrollbar if present.
/// </summary>
public int ClientHeight { get; set; }}
/// <summary>
/// Visual viewport position, dimensions, and scale.
/// </summary>
internal class VisualViewport
{
/// <summary>
/// Horizontal offset relative to the layout viewport (CSS pixels).
/// </summary>
public double OffsetX { get; set; }
/// <summary>
/// Vertical offset relative to the layout viewport (CSS pixels).
/// </summary>
public double OffsetY { get; set; }
/// <summary>
/// Horizontal offset relative to the document (CSS pixels).
/// </summary>
public double PageX { get; set; }
/// <summary>
/// Vertical offset relative to the document (CSS pixels).
/// </summary>
public double PageY { get; set; }
/// <summary>
/// Width (CSS pixels), excludes scrollbar if present.
/// </summary>
public double ClientWidth { get; set; }
/// <summary>
/// Height (CSS pixels), excludes scrollbar if present.
/// </summary>
public double ClientHeight { get; set; }
/// <summary>
/// Scale relative to the ideal viewport (size at width=device-width).
/// </summary>
public double Scale { get; set; }
/// <summary>
/// Page zoom factor (CSS to device independent pixels ratio).
/// </summary>
public double Zoom { get; set; }}
/// <summary>
/// Viewport for capturing screenshot.
/// </summary>
internal class Viewport
{
/// <summary>
/// X offset in device independent pixels (dip).
/// </summary>
public double X { get; set; }
/// <summary>
/// Y offset in device independent pixels (dip).
/// </summary>
public double Y { get; set; }
/// <summary>
/// Rectangle width in device independent pixels (dip).
/// </summary>
public double Width { get; set; }
/// <summary>
/// Rectangle height in device independent pixels (dip).
/// </summary>
public double Height { get; set; }
/// <summary>
/// Page scale factor.
/// </summary>
public double Scale { get; set; }}
/// <summary>
/// Generic font families collection.
/// </summary>
internal class FontFamilies
{
/// <summary>
/// The standard font-family.
/// </summary>
public string Standard { get; set; }
/// <summary>
/// The fixed font-family.
/// </summary>
public string Fixed { get; set; }
/// <summary>
/// The serif font-family.
/// </summary>
public string Serif { get; set; }
/// <summary>
/// The sansSerif font-family.
/// </summary>
public string SansSerif { get; set; }
/// <summary>
/// The cursive font-family.
/// </summary>
public string Cursive { get; set; }
/// <summary>
/// The fantasy font-family.
/// </summary>
public string Fantasy { get; set; }
/// <summary>
/// The pictograph font-family.
/// </summary>
public string Pictograph { get; set; }}
/// <summary>
/// Default font sizes.
/// </summary>
internal class FontSizes
{
/// <summary>
/// Default standard font size.
/// </summary>
public int Standard { get; set; }
/// <summary>
/// Default fixed font size.
/// </summary>
public int Fixed { get; set; }}
/// <summary>
/// 
/// </summary>
internal enum ClientNavigationReason
{
[System.Runtime.Serialization.EnumMember(Value = "formSubmissionGet")]FormSubmissionGet,
[System.Runtime.Serialization.EnumMember(Value = "formSubmissionPost")]FormSubmissionPost,
[System.Runtime.Serialization.EnumMember(Value = "httpHeaderRefresh")]HttpHeaderRefresh,
[System.Runtime.Serialization.EnumMember(Value = "scriptInitiated")]ScriptInitiated,
[System.Runtime.Serialization.EnumMember(Value = "metaTagRefresh")]MetaTagRefresh,
[System.Runtime.Serialization.EnumMember(Value = "pageBlockInterstitial")]PageBlockInterstitial,
[System.Runtime.Serialization.EnumMember(Value = "reload")]Reload}
/// <summary>
/// Deprecated, please use addScriptToEvaluateOnNewDocument instead.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.addScriptToEvaluateOnLoad</c>
/// </remarks>
[System.Obsolete("Deprecated, please use addScriptToEvaluateOnNewDocument instead.")]
internal class PageAddScriptToEvaluateOnLoadRequest : IChromiumRequest<PageAddScriptToEvaluateOnLoadResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.addScriptToEvaluateOnLoad";
/// <summary>
/// 
/// </summary>
public string ScriptSource { get; set; }}
/// <summary>
/// Response from <see cref="PageAddScriptToEvaluateOnLoadRequest"/>
/// </summary>
internal class PageAddScriptToEvaluateOnLoadResponse : IChromiumResponse
{
/// <summary>
/// Identifier of the added script.
/// </summary>
public string Identifier { get; set; }}
/// <summary>
/// Evaluates given script in every frame upon creation (before loading frame's scripts).
/// </summary>
/// <remarks>
/// Will send the command <c>Page.addScriptToEvaluateOnNewDocument</c>
/// </remarks>
internal class PageAddScriptToEvaluateOnNewDocumentRequest : IChromiumRequest<PageAddScriptToEvaluateOnNewDocumentResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.addScriptToEvaluateOnNewDocument";
/// <summary>
/// 
/// </summary>
public string Source { get; set; }
/// <summary>
/// If specified, creates an isolated world with the given name and evaluates given script in it.
/// This world name will be used as the ExecutionContextDescription::name when the corresponding
/// event is emitted.
/// </summary>
public string WorldName { get; set; }}
/// <summary>
/// Response from <see cref="PageAddScriptToEvaluateOnNewDocumentRequest"/>
/// </summary>
internal class PageAddScriptToEvaluateOnNewDocumentResponse : IChromiumResponse
{
/// <summary>
/// Identifier of the added script.
/// </summary>
public string Identifier { get; set; }}
/// <summary>
/// Brings page to front (activates tab).
/// </summary>
/// <remarks>
/// Will send the command <c>Page.bringToFront</c>
/// </remarks>
internal class PageBringToFrontRequest : IChromiumRequest<PageBringToFrontResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.bringToFront";
}
/// <summary>
/// Response from <see cref="PageBringToFrontRequest"/>
/// </summary>
internal class PageBringToFrontResponse : IChromiumResponse
{
}
/// <summary>
/// Capture page screenshot.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.captureScreenshot</c>
/// </remarks>
internal class PageCaptureScreenshotRequest : IChromiumRequest<PageCaptureScreenshotResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.captureScreenshot";
/// <summary>
/// Image compression format (defaults to png).
/// </summary>
public string Format { get; set; }
/// <summary>
/// Compression quality from range [0..100] (jpeg only).
/// </summary>
public int Quality { get; set; }
/// <summary>
/// Capture the screenshot of a given region only.
/// </summary>
public Viewport Clip { get; set; }
/// <summary>
/// Capture the screenshot from the surface, rather than the view. Defaults to true.
/// </summary>
public bool FromSurface { get; set; }}
/// <summary>
/// Response from <see cref="PageCaptureScreenshotRequest"/>
/// </summary>
internal class PageCaptureScreenshotResponse : IChromiumResponse
{
/// <summary>
/// Base64-encoded image data.
/// </summary>
public byte[] Data { get; set; }}
/// <summary>
/// Returns a snapshot of the page as a string. For MHTML format, the serialization includes
/// iframes, shadow DOM, external resources, and element-inline styles.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.captureSnapshot</c>
/// </remarks>
internal class PageCaptureSnapshotRequest : IChromiumRequest<PageCaptureSnapshotResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.captureSnapshot";
/// <summary>
/// Format (defaults to mhtml).
/// </summary>
public string Format { get; set; }}
/// <summary>
/// Response from <see cref="PageCaptureSnapshotRequest"/>
/// </summary>
internal class PageCaptureSnapshotResponse : IChromiumResponse
{
/// <summary>
/// Serialized page data.
/// </summary>
public string Data { get; set; }}
/// <summary>
/// Clears the overriden device metrics.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.clearDeviceMetricsOverride</c>
/// </remarks>
internal class PageClearDeviceMetricsOverrideRequest : IChromiumRequest<PageClearDeviceMetricsOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.clearDeviceMetricsOverride";
}
/// <summary>
/// Response from <see cref="PageClearDeviceMetricsOverrideRequest"/>
/// </summary>
internal class PageClearDeviceMetricsOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// Clears the overridden Device Orientation.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.clearDeviceOrientationOverride</c>
/// </remarks>
internal class PageClearDeviceOrientationOverrideRequest : IChromiumRequest<PageClearDeviceOrientationOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.clearDeviceOrientationOverride";
}
/// <summary>
/// Response from <see cref="PageClearDeviceOrientationOverrideRequest"/>
/// </summary>
internal class PageClearDeviceOrientationOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// Clears the overriden Geolocation Position and Error.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.clearGeolocationOverride</c>
/// </remarks>
internal class PageClearGeolocationOverrideRequest : IChromiumRequest<PageClearGeolocationOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.clearGeolocationOverride";
}
/// <summary>
/// Response from <see cref="PageClearGeolocationOverrideRequest"/>
/// </summary>
internal class PageClearGeolocationOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// Creates an isolated world for the given frame.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.createIsolatedWorld</c>
/// </remarks>
internal class PageCreateIsolatedWorldRequest : IChromiumRequest<PageCreateIsolatedWorldResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.createIsolatedWorld";
/// <summary>
/// Id of the frame in which the isolated world should be created.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// An optional name which is reported in the Execution Context.
/// </summary>
public string WorldName { get; set; }
/// <summary>
/// Whether or not universal access should be granted to the isolated world. This is a powerful
/// option, use with caution.
/// </summary>
public bool GrantUniveralAccess { get; set; }}
/// <summary>
/// Response from <see cref="PageCreateIsolatedWorldRequest"/>
/// </summary>
internal class PageCreateIsolatedWorldResponse : IChromiumResponse
{
/// <summary>
/// Execution context of the isolated world.
/// </summary>
public int ExecutionContextId { get; set; }}
/// <summary>
/// Deletes browser cookie with given name, domain and path.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.deleteCookie</c>
/// </remarks>
internal class PageDeleteCookieRequest : IChromiumRequest<PageDeleteCookieResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.deleteCookie";
/// <summary>
/// Name of the cookie to remove.
/// </summary>
public string CookieName { get; set; }
/// <summary>
/// URL to match cooke domain and path.
/// </summary>
public string Url { get; set; }}
/// <summary>
/// Response from <see cref="PageDeleteCookieRequest"/>
/// </summary>
internal class PageDeleteCookieResponse : IChromiumResponse
{
}
/// <summary>
/// Disables page domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.disable</c>
/// </remarks>
internal class PageDisableRequest : IChromiumRequest<PageDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.disable";
}
/// <summary>
/// Response from <see cref="PageDisableRequest"/>
/// </summary>
internal class PageDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables page domain notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.enable</c>
/// </remarks>
internal class PageEnableRequest : IChromiumRequest<PageEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.enable";
}
/// <summary>
/// Response from <see cref="PageEnableRequest"/>
/// </summary>
internal class PageEnableResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Page.getAppManifest</c>
/// </remarks>
internal class PageGetAppManifestRequest : IChromiumRequest<PageGetAppManifestResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.getAppManifest";
}
/// <summary>
/// Response from <see cref="PageGetAppManifestRequest"/>
/// </summary>
internal class PageGetAppManifestResponse : IChromiumResponse
{
/// <summary>
/// Manifest location.
/// </summary>
public string Url { get; set; }
/// <summary>
/// 
/// </summary>
public AppManifestError[] Errors { get; set; }
/// <summary>
/// Manifest content.
/// </summary>
public string Data { get; set; }
/// <summary>
/// Parsed manifest properties
/// </summary>
public AppManifestParsedProperties Parsed { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Page.getInstallabilityErrors</c>
/// </remarks>
internal class PageGetInstallabilityErrorsRequest : IChromiumRequest<PageGetInstallabilityErrorsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.getInstallabilityErrors";
}
/// <summary>
/// Response from <see cref="PageGetInstallabilityErrorsRequest"/>
/// </summary>
internal class PageGetInstallabilityErrorsResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public string[] Errors { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Page.getManifestIcons</c>
/// </remarks>
internal class PageGetManifestIconsRequest : IChromiumRequest<PageGetManifestIconsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.getManifestIcons";
}
/// <summary>
/// Response from <see cref="PageGetManifestIconsRequest"/>
/// </summary>
internal class PageGetManifestIconsResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public byte[] PrimaryIcon { get; set; }}
/// <summary>
/// Returns all browser cookies. Depending on the backend support, will return detailed cookie
/// information in the `cookies` field.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.getCookies</c>
/// </remarks>
internal class PageGetCookiesRequest : IChromiumRequest<PageGetCookiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.getCookies";
}
/// <summary>
/// Response from <see cref="PageGetCookiesRequest"/>
/// </summary>
internal class PageGetCookiesResponse : IChromiumResponse
{
/// <summary>
/// Array of cookie objects.
/// </summary>
public Network.Cookie[] Cookies { get; set; }}
/// <summary>
/// Returns present frame tree structure.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.getFrameTree</c>
/// </remarks>
internal class PageGetFrameTreeRequest : IChromiumRequest<PageGetFrameTreeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.getFrameTree";
}
/// <summary>
/// Response from <see cref="PageGetFrameTreeRequest"/>
/// </summary>
internal class PageGetFrameTreeResponse : IChromiumResponse
{
/// <summary>
/// Present frame tree structure.
/// </summary>
public FrameTree FrameTree { get; set; }}
/// <summary>
/// Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.getLayoutMetrics</c>
/// </remarks>
internal class PageGetLayoutMetricsRequest : IChromiumRequest<PageGetLayoutMetricsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.getLayoutMetrics";
}
/// <summary>
/// Response from <see cref="PageGetLayoutMetricsRequest"/>
/// </summary>
internal class PageGetLayoutMetricsResponse : IChromiumResponse
{
/// <summary>
/// Metrics relating to the layout viewport.
/// </summary>
public LayoutViewport LayoutViewport { get; set; }
/// <summary>
/// Metrics relating to the visual viewport.
/// </summary>
public VisualViewport VisualViewport { get; set; }
/// <summary>
/// Size of scrollable area.
/// </summary>
public DOM.Rect ContentSize { get; set; }}
/// <summary>
/// Returns navigation history for the current page.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.getNavigationHistory</c>
/// </remarks>
internal class PageGetNavigationHistoryRequest : IChromiumRequest<PageGetNavigationHistoryResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.getNavigationHistory";
}
/// <summary>
/// Response from <see cref="PageGetNavigationHistoryRequest"/>
/// </summary>
internal class PageGetNavigationHistoryResponse : IChromiumResponse
{
/// <summary>
/// Index of the current navigation history entry.
/// </summary>
public int CurrentIndex { get; set; }
/// <summary>
/// Array of navigation history entries.
/// </summary>
public NavigationEntry[] Entries { get; set; }}
/// <summary>
/// Resets navigation history for the current page.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.resetNavigationHistory</c>
/// </remarks>
internal class PageResetNavigationHistoryRequest : IChromiumRequest<PageResetNavigationHistoryResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.resetNavigationHistory";
}
/// <summary>
/// Response from <see cref="PageResetNavigationHistoryRequest"/>
/// </summary>
internal class PageResetNavigationHistoryResponse : IChromiumResponse
{
}
/// <summary>
/// Returns content of the given resource.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.getResourceContent</c>
/// </remarks>
internal class PageGetResourceContentRequest : IChromiumRequest<PageGetResourceContentResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.getResourceContent";
/// <summary>
/// Frame id to get resource for.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// URL of the resource to get content for.
/// </summary>
public string Url { get; set; }}
/// <summary>
/// Response from <see cref="PageGetResourceContentRequest"/>
/// </summary>
internal class PageGetResourceContentResponse : IChromiumResponse
{
/// <summary>
/// Resource content.
/// </summary>
public string Content { get; set; }
/// <summary>
/// True, if content was served as base64.
/// </summary>
public bool Base64Encoded { get; set; }}
/// <summary>
/// Returns present frame / resource tree structure.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.getResourceTree</c>
/// </remarks>
internal class PageGetResourceTreeRequest : IChromiumRequest<PageGetResourceTreeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.getResourceTree";
}
/// <summary>
/// Response from <see cref="PageGetResourceTreeRequest"/>
/// </summary>
internal class PageGetResourceTreeResponse : IChromiumResponse
{
/// <summary>
/// Present frame / resource tree structure.
/// </summary>
public FrameResourceTree FrameTree { get; set; }}
/// <summary>
/// Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
/// </summary>
/// <remarks>
/// Will send the command <c>Page.handleJavaScriptDialog</c>
/// </remarks>
internal class PageHandleJavaScriptDialogRequest : IChromiumRequest<PageHandleJavaScriptDialogResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.handleJavaScriptDialog";
/// <summary>
/// Whether to accept or dismiss the dialog.
/// </summary>
public bool Accept { get; set; }
/// <summary>
/// The text to enter into the dialog prompt before accepting. Used only if this is a prompt
/// dialog.
/// </summary>
public string PromptText { get; set; }}
/// <summary>
/// Response from <see cref="PageHandleJavaScriptDialogRequest"/>
/// </summary>
internal class PageHandleJavaScriptDialogResponse : IChromiumResponse
{
}
/// <summary>
/// Navigates current page to the given URL.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.navigate</c>
/// </remarks>
internal class PageNavigateRequest : IChromiumRequest<PageNavigateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.navigate";
/// <summary>
/// URL to navigate the page to.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Referrer URL.
/// </summary>
public string Referrer { get; set; }
/// <summary>
/// Intended transition type.
/// </summary>
public TransitionType TransitionType { get; set; }
/// <summary>
/// Frame id to navigate, if not specified navigates the top frame.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Response from <see cref="PageNavigateRequest"/>
/// </summary>
internal class PageNavigateResponse : IChromiumResponse
{
/// <summary>
/// Frame id that has navigated (or failed to navigate)
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Loader identifier.
/// </summary>
public string LoaderId { get; set; }
/// <summary>
/// User friendly error message, present if and only if navigation has failed.
/// </summary>
public string ErrorText { get; set; }}
/// <summary>
/// Navigates current page to the given history entry.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.navigateToHistoryEntry</c>
/// </remarks>
internal class PageNavigateToHistoryEntryRequest : IChromiumRequest<PageNavigateToHistoryEntryResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.navigateToHistoryEntry";
/// <summary>
/// Unique id of the entry to navigate to.
/// </summary>
public int EntryId { get; set; }}
/// <summary>
/// Response from <see cref="PageNavigateToHistoryEntryRequest"/>
/// </summary>
internal class PageNavigateToHistoryEntryResponse : IChromiumResponse
{
}
/// <summary>
/// Print page as PDF.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.printToPDF</c>
/// </remarks>
internal class PagePrintToPDFRequest : IChromiumRequest<PagePrintToPDFResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.printToPDF";
/// <summary>
/// Paper orientation. Defaults to false.
/// </summary>
public bool Landscape { get; set; }
/// <summary>
/// Display header and footer. Defaults to false.
/// </summary>
public bool DisplayHeaderFooter { get; set; }
/// <summary>
/// Print background graphics. Defaults to false.
/// </summary>
public bool PrintBackground { get; set; }
/// <summary>
/// Scale of the webpage rendering. Defaults to 1.
/// </summary>
public double Scale { get; set; }
/// <summary>
/// Paper width in inches. Defaults to 8.5 inches.
/// </summary>
public double PaperWidth { get; set; }
/// <summary>
/// Paper height in inches. Defaults to 11 inches.
/// </summary>
public double PaperHeight { get; set; }
/// <summary>
/// Top margin in inches. Defaults to 1cm (~0.4 inches).
/// </summary>
public double MarginTop { get; set; }
/// <summary>
/// Bottom margin in inches. Defaults to 1cm (~0.4 inches).
/// </summary>
public double MarginBottom { get; set; }
/// <summary>
/// Left margin in inches. Defaults to 1cm (~0.4 inches).
/// </summary>
public double MarginLeft { get; set; }
/// <summary>
/// Right margin in inches. Defaults to 1cm (~0.4 inches).
/// </summary>
public double MarginRight { get; set; }
/// <summary>
/// Paper ranges to print, e.g., '1-5, 8, 11-13'. Defaults to the empty string, which means
/// print all pages.
/// </summary>
public string PageRanges { get; set; }
/// <summary>
/// Whether to silently ignore invalid but successfully parsed page ranges, such as '3-2'.
/// Defaults to false.
/// </summary>
public bool IgnoreInvalidPageRanges { get; set; }
/// <summary>
/// HTML template for the print header. Should be valid HTML markup with following
/// classes used to inject printing values into them:
/// - `date`: formatted print date
/// - `title`: document title
/// - `url`: document location
/// - `pageNumber`: current page number
/// - `totalPages`: total pages in the document
/// 
/// For example, `&lt;span class=title&gt;&lt;/span&gt;` would generate span containing the title.
/// </summary>
public string HeaderTemplate { get; set; }
/// <summary>
/// HTML template for the print footer. Should use the same format as the `headerTemplate`.
/// </summary>
public string FooterTemplate { get; set; }
/// <summary>
/// Whether or not to prefer page size as defined by css. Defaults to false,
/// in which case the content will be scaled to fit the paper size.
/// </summary>
public bool PreferCSSPageSize { get; set; }
/// <summary>
/// return as stream
/// </summary>
public string TransferMode { get; set; }}
/// <summary>
/// Response from <see cref="PagePrintToPDFRequest"/>
/// </summary>
internal class PagePrintToPDFResponse : IChromiumResponse
{
/// <summary>
/// Base64-encoded pdf data. Empty if |returnAsStream| is specified.
/// </summary>
public byte[] Data { get; set; }
/// <summary>
/// A handle of the stream that holds resulting PDF data.
/// </summary>
public string Stream { get; set; }}
/// <summary>
/// Reloads given page optionally ignoring the cache.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.reload</c>
/// </remarks>
internal class PageReloadRequest : IChromiumRequest<PageReloadResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.reload";
/// <summary>
/// If true, browser cache is ignored (as if the user pressed Shift+refresh).
/// </summary>
public bool IgnoreCache { get; set; }
/// <summary>
/// If set, the script will be injected into all frames of the inspected page after reload.
/// Argument will be ignored if reloading dataURL origin.
/// </summary>
public string ScriptToEvaluateOnLoad { get; set; }}
/// <summary>
/// Response from <see cref="PageReloadRequest"/>
/// </summary>
internal class PageReloadResponse : IChromiumResponse
{
}
/// <summary>
/// Deprecated, please use removeScriptToEvaluateOnNewDocument instead.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.removeScriptToEvaluateOnLoad</c>
/// </remarks>
[System.Obsolete("Deprecated, please use removeScriptToEvaluateOnNewDocument instead.")]
internal class PageRemoveScriptToEvaluateOnLoadRequest : IChromiumRequest<PageRemoveScriptToEvaluateOnLoadResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.removeScriptToEvaluateOnLoad";
/// <summary>
/// 
/// </summary>
public string Identifier { get; set; }}
/// <summary>
/// Response from <see cref="PageRemoveScriptToEvaluateOnLoadRequest"/>
/// </summary>
internal class PageRemoveScriptToEvaluateOnLoadResponse : IChromiumResponse
{
}
/// <summary>
/// Removes given script from the list.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.removeScriptToEvaluateOnNewDocument</c>
/// </remarks>
internal class PageRemoveScriptToEvaluateOnNewDocumentRequest : IChromiumRequest<PageRemoveScriptToEvaluateOnNewDocumentResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.removeScriptToEvaluateOnNewDocument";
/// <summary>
/// 
/// </summary>
public string Identifier { get; set; }}
/// <summary>
/// Response from <see cref="PageRemoveScriptToEvaluateOnNewDocumentRequest"/>
/// </summary>
internal class PageRemoveScriptToEvaluateOnNewDocumentResponse : IChromiumResponse
{
}
/// <summary>
/// Acknowledges that a screencast frame has been received by the frontend.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.screencastFrameAck</c>
/// </remarks>
internal class PageScreencastFrameAckRequest : IChromiumRequest<PageScreencastFrameAckResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.screencastFrameAck";
/// <summary>
/// Frame number.
/// </summary>
public int SessionId { get; set; }}
/// <summary>
/// Response from <see cref="PageScreencastFrameAckRequest"/>
/// </summary>
internal class PageScreencastFrameAckResponse : IChromiumResponse
{
}
/// <summary>
/// Searches for given string in resource content.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.searchInResource</c>
/// </remarks>
internal class PageSearchInResourceRequest : IChromiumRequest<PageSearchInResourceResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.searchInResource";
/// <summary>
/// Frame id for resource to search in.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// URL of the resource to search in.
/// </summary>
public string Url { get; set; }
/// <summary>
/// String to search for.
/// </summary>
public string Query { get; set; }
/// <summary>
/// If true, search is case sensitive.
/// </summary>
public bool CaseSensitive { get; set; }
/// <summary>
/// If true, treats string parameter as regex.
/// </summary>
public bool IsRegex { get; set; }}
/// <summary>
/// Response from <see cref="PageSearchInResourceRequest"/>
/// </summary>
internal class PageSearchInResourceResponse : IChromiumResponse
{
/// <summary>
/// List of search matches.
/// </summary>
public Debugger.SearchMatch[] Result { get; set; }}
/// <summary>
/// Enable Chrome's experimental ad filter on all sites.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setAdBlockingEnabled</c>
/// </remarks>
internal class PageSetAdBlockingEnabledRequest : IChromiumRequest<PageSetAdBlockingEnabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setAdBlockingEnabled";
/// <summary>
/// Whether to block ads.
/// </summary>
public bool Enabled { get; set; }}
/// <summary>
/// Response from <see cref="PageSetAdBlockingEnabledRequest"/>
/// </summary>
internal class PageSetAdBlockingEnabledResponse : IChromiumResponse
{
}
/// <summary>
/// Enable page Content Security Policy by-passing.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setBypassCSP</c>
/// </remarks>
internal class PageSetBypassCSPRequest : IChromiumRequest<PageSetBypassCSPResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setBypassCSP";
/// <summary>
/// Whether to bypass page CSP.
/// </summary>
public bool Enabled { get; set; }}
/// <summary>
/// Response from <see cref="PageSetBypassCSPRequest"/>
/// </summary>
internal class PageSetBypassCSPResponse : IChromiumResponse
{
}
/// <summary>
/// Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
/// window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
/// query results).
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setDeviceMetricsOverride</c>
/// </remarks>
internal class PageSetDeviceMetricsOverrideRequest : IChromiumRequest<PageSetDeviceMetricsOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setDeviceMetricsOverride";
/// <summary>
/// Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
/// </summary>
public int Width { get; set; }
/// <summary>
/// Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
/// </summary>
public int Height { get; set; }
/// <summary>
/// Overriding device scale factor value. 0 disables the override.
/// </summary>
public double DeviceScaleFactor { get; set; }
/// <summary>
/// Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text
/// autosizing and more.
/// </summary>
public bool Mobile { get; set; }
/// <summary>
/// Scale to apply to resulting view image.
/// </summary>
public double Scale { get; set; }
/// <summary>
/// Overriding screen width value in pixels (minimum 0, maximum 10000000).
/// </summary>
public int ScreenWidth { get; set; }
/// <summary>
/// Overriding screen height value in pixels (minimum 0, maximum 10000000).
/// </summary>
public int ScreenHeight { get; set; }
/// <summary>
/// Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
/// </summary>
public int PositionX { get; set; }
/// <summary>
/// Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
/// </summary>
public int PositionY { get; set; }
/// <summary>
/// Do not set visible view size, rely upon explicit setVisibleSize call.
/// </summary>
public bool DontSetVisibleSize { get; set; }
/// <summary>
/// Screen orientation override.
/// </summary>
public Emulation.ScreenOrientation ScreenOrientation { get; set; }
/// <summary>
/// The viewport dimensions and scale. If not set, the override is cleared.
/// </summary>
public Viewport Viewport { get; set; }}
/// <summary>
/// Response from <see cref="PageSetDeviceMetricsOverrideRequest"/>
/// </summary>
internal class PageSetDeviceMetricsOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// Overrides the Device Orientation.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setDeviceOrientationOverride</c>
/// </remarks>
internal class PageSetDeviceOrientationOverrideRequest : IChromiumRequest<PageSetDeviceOrientationOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setDeviceOrientationOverride";
/// <summary>
/// Mock alpha
/// </summary>
public double Alpha { get; set; }
/// <summary>
/// Mock beta
/// </summary>
public double Beta { get; set; }
/// <summary>
/// Mock gamma
/// </summary>
public double Gamma { get; set; }}
/// <summary>
/// Response from <see cref="PageSetDeviceOrientationOverrideRequest"/>
/// </summary>
internal class PageSetDeviceOrientationOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// Set generic font families.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setFontFamilies</c>
/// </remarks>
internal class PageSetFontFamiliesRequest : IChromiumRequest<PageSetFontFamiliesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setFontFamilies";
/// <summary>
/// Specifies font families to set. If a font family is not specified, it won't be changed.
/// </summary>
public FontFamilies FontFamilies { get; set; }}
/// <summary>
/// Response from <see cref="PageSetFontFamiliesRequest"/>
/// </summary>
internal class PageSetFontFamiliesResponse : IChromiumResponse
{
}
/// <summary>
/// Set default font sizes.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setFontSizes</c>
/// </remarks>
internal class PageSetFontSizesRequest : IChromiumRequest<PageSetFontSizesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setFontSizes";
/// <summary>
/// Specifies font sizes to set. If a font size is not specified, it won't be changed.
/// </summary>
public FontSizes FontSizes { get; set; }}
/// <summary>
/// Response from <see cref="PageSetFontSizesRequest"/>
/// </summary>
internal class PageSetFontSizesResponse : IChromiumResponse
{
}
/// <summary>
/// Sets given markup as the document's HTML.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setDocumentContent</c>
/// </remarks>
internal class PageSetDocumentContentRequest : IChromiumRequest<PageSetDocumentContentResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setDocumentContent";
/// <summary>
/// Frame id to set HTML for.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// HTML content to set.
/// </summary>
public string Html { get; set; }}
/// <summary>
/// Response from <see cref="PageSetDocumentContentRequest"/>
/// </summary>
internal class PageSetDocumentContentResponse : IChromiumResponse
{
}
/// <summary>
/// Set the behavior when downloading a file.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setDownloadBehavior</c>
/// </remarks>
internal class PageSetDownloadBehaviorRequest : IChromiumRequest<PageSetDownloadBehaviorResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setDownloadBehavior";
/// <summary>
/// Whether to allow all or deny all download requests, or use default Chrome behavior if
/// available (otherwise deny).
/// </summary>
public string Behavior { get; set; }
/// <summary>
/// The default path to save downloaded files to. This is requred if behavior is set to 'allow'
/// </summary>
public string DownloadPath { get; set; }}
/// <summary>
/// Response from <see cref="PageSetDownloadBehaviorRequest"/>
/// </summary>
internal class PageSetDownloadBehaviorResponse : IChromiumResponse
{
}
/// <summary>
/// Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
/// unavailable.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setGeolocationOverride</c>
/// </remarks>
internal class PageSetGeolocationOverrideRequest : IChromiumRequest<PageSetGeolocationOverrideResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setGeolocationOverride";
/// <summary>
/// Mock latitude
/// </summary>
public double Latitude { get; set; }
/// <summary>
/// Mock longitude
/// </summary>
public double Longitude { get; set; }
/// <summary>
/// Mock accuracy
/// </summary>
public double Accuracy { get; set; }}
/// <summary>
/// Response from <see cref="PageSetGeolocationOverrideRequest"/>
/// </summary>
internal class PageSetGeolocationOverrideResponse : IChromiumResponse
{
}
/// <summary>
/// Controls whether page will emit lifecycle events.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setLifecycleEventsEnabled</c>
/// </remarks>
internal class PageSetLifecycleEventsEnabledRequest : IChromiumRequest<PageSetLifecycleEventsEnabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setLifecycleEventsEnabled";
/// <summary>
/// If true, starts emitting lifecycle events.
/// </summary>
public bool Enabled { get; set; }}
/// <summary>
/// Response from <see cref="PageSetLifecycleEventsEnabledRequest"/>
/// </summary>
internal class PageSetLifecycleEventsEnabledResponse : IChromiumResponse
{
}
/// <summary>
/// Toggles mouse event-based touch event emulation.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setTouchEmulationEnabled</c>
/// </remarks>
internal class PageSetTouchEmulationEnabledRequest : IChromiumRequest<PageSetTouchEmulationEnabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setTouchEmulationEnabled";
/// <summary>
/// Whether the touch event emulation should be enabled.
/// </summary>
public bool Enabled { get; set; }
/// <summary>
/// Touch/gesture events configuration. Default: current platform.
/// </summary>
public string Configuration { get; set; }}
/// <summary>
/// Response from <see cref="PageSetTouchEmulationEnabledRequest"/>
/// </summary>
internal class PageSetTouchEmulationEnabledResponse : IChromiumResponse
{
}
/// <summary>
/// Starts sending each frame using the `screencastFrame` event.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.startScreencast</c>
/// </remarks>
internal class PageStartScreencastRequest : IChromiumRequest<PageStartScreencastResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.startScreencast";
/// <summary>
/// Image compression format.
/// </summary>
public string Format { get; set; }
/// <summary>
/// Compression quality from range [0..100].
/// </summary>
public int Quality { get; set; }
/// <summary>
/// Maximum screenshot width.
/// </summary>
public int MaxWidth { get; set; }
/// <summary>
/// Maximum screenshot height.
/// </summary>
public int MaxHeight { get; set; }
/// <summary>
/// Send every n-th frame.
/// </summary>
public int EveryNthFrame { get; set; }}
/// <summary>
/// Response from <see cref="PageStartScreencastRequest"/>
/// </summary>
internal class PageStartScreencastResponse : IChromiumResponse
{
}
/// <summary>
/// Force the page stop all navigations and pending resource fetches.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.stopLoading</c>
/// </remarks>
internal class PageStopLoadingRequest : IChromiumRequest<PageStopLoadingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.stopLoading";
}
/// <summary>
/// Response from <see cref="PageStopLoadingRequest"/>
/// </summary>
internal class PageStopLoadingResponse : IChromiumResponse
{
}
/// <summary>
/// Crashes renderer on the IO thread, generates minidumps.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.crash</c>
/// </remarks>
internal class PageCrashRequest : IChromiumRequest<PageCrashResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.crash";
}
/// <summary>
/// Response from <see cref="PageCrashRequest"/>
/// </summary>
internal class PageCrashResponse : IChromiumResponse
{
}
/// <summary>
/// Tries to close page, running its beforeunload hooks, if any.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.close</c>
/// </remarks>
internal class PageCloseRequest : IChromiumRequest<PageCloseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.close";
}
/// <summary>
/// Response from <see cref="PageCloseRequest"/>
/// </summary>
internal class PageCloseResponse : IChromiumResponse
{
}
/// <summary>
/// Tries to update the web lifecycle state of the page.
/// It will transition the page to the given state according to:
/// https://github.com/WICG/web-lifecycle/
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setWebLifecycleState</c>
/// </remarks>
internal class PageSetWebLifecycleStateRequest : IChromiumRequest<PageSetWebLifecycleStateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setWebLifecycleState";
/// <summary>
/// Target lifecycle state
/// </summary>
public string State { get; set; }}
/// <summary>
/// Response from <see cref="PageSetWebLifecycleStateRequest"/>
/// </summary>
internal class PageSetWebLifecycleStateResponse : IChromiumResponse
{
}
/// <summary>
/// Stops sending each frame in the `screencastFrame`.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.stopScreencast</c>
/// </remarks>
internal class PageStopScreencastRequest : IChromiumRequest<PageStopScreencastResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.stopScreencast";
}
/// <summary>
/// Response from <see cref="PageStopScreencastRequest"/>
/// </summary>
internal class PageStopScreencastResponse : IChromiumResponse
{
}
/// <summary>
/// Forces compilation cache to be generated for every subresource script.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setProduceCompilationCache</c>
/// </remarks>
internal class PageSetProduceCompilationCacheRequest : IChromiumRequest<PageSetProduceCompilationCacheResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setProduceCompilationCache";
/// <summary>
/// 
/// </summary>
public bool Enabled { get; set; }}
/// <summary>
/// Response from <see cref="PageSetProduceCompilationCacheRequest"/>
/// </summary>
internal class PageSetProduceCompilationCacheResponse : IChromiumResponse
{
}
/// <summary>
/// Seeds compilation cache for given url. Compilation cache does not survive
/// cross-process navigation.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.addCompilationCache</c>
/// </remarks>
internal class PageAddCompilationCacheRequest : IChromiumRequest<PageAddCompilationCacheResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.addCompilationCache";
/// <summary>
/// 
/// </summary>
public string Url { get; set; }
/// <summary>
/// Base64-encoded data
/// </summary>
public byte[] Data { get; set; }}
/// <summary>
/// Response from <see cref="PageAddCompilationCacheRequest"/>
/// </summary>
internal class PageAddCompilationCacheResponse : IChromiumResponse
{
}
/// <summary>
/// Clears seeded compilation cache.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.clearCompilationCache</c>
/// </remarks>
internal class PageClearCompilationCacheRequest : IChromiumRequest<PageClearCompilationCacheResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.clearCompilationCache";
}
/// <summary>
/// Response from <see cref="PageClearCompilationCacheRequest"/>
/// </summary>
internal class PageClearCompilationCacheResponse : IChromiumResponse
{
}
/// <summary>
/// Generates a report for testing.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.generateTestReport</c>
/// </remarks>
internal class PageGenerateTestReportRequest : IChromiumRequest<PageGenerateTestReportResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.generateTestReport";
/// <summary>
/// Message to be displayed in the report.
/// </summary>
public string Message { get; set; }
/// <summary>
/// Specifies the endpoint group to deliver the report to.
/// </summary>
public string Group { get; set; }}
/// <summary>
/// Response from <see cref="PageGenerateTestReportRequest"/>
/// </summary>
internal class PageGenerateTestReportResponse : IChromiumResponse
{
}
/// <summary>
/// Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.waitForDebugger</c>
/// </remarks>
internal class PageWaitForDebuggerRequest : IChromiumRequest<PageWaitForDebuggerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.waitForDebugger";
}
/// <summary>
/// Response from <see cref="PageWaitForDebuggerRequest"/>
/// </summary>
internal class PageWaitForDebuggerResponse : IChromiumResponse
{
}
/// <summary>
/// Intercept file chooser requests and transfer control to protocol clients.
/// When file chooser interception is enabled, native file chooser dialog is not shown.
/// Instead, a protocol event `Page.fileChooserOpened` is emitted.
/// </summary>
/// <remarks>
/// Will send the command <c>Page.setInterceptFileChooserDialog</c>
/// </remarks>
internal class PageSetInterceptFileChooserDialogRequest : IChromiumRequest<PageSetInterceptFileChooserDialogResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Page.setInterceptFileChooserDialog";
/// <summary>
/// 
/// </summary>
public bool Enabled { get; set; }}
/// <summary>
/// Response from <see cref="PageSetInterceptFileChooserDialogRequest"/>
/// </summary>
internal class PageSetInterceptFileChooserDialogResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.domContentEventFired</c>
/// </remarks>
internal class PageDomContentEventFiredChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.domContentEventFired";
/// <summary>
/// 
/// </summary>
public double Timestamp { get; set; }}
/// <summary>
/// Emitted only when `page.interceptFileChooser` is enabled.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.fileChooserOpened</c>
/// </remarks>
internal class PageFileChooserOpenedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.fileChooserOpened";
/// <summary>
/// Id of the frame containing input node.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Input node id.
/// </summary>
public int BackendNodeId { get; set; }
/// <summary>
/// Input mode.
/// </summary>
public string Mode { get; set; }}
/// <summary>
/// Fired when frame has been attached to its parent.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameAttached</c>
/// </remarks>
internal class PageFrameAttachedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.frameAttached";
/// <summary>
/// Id of the frame that has been attached.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Parent frame identifier.
/// </summary>
public string ParentFrameId { get; set; }
/// <summary>
/// JavaScript stack trace of when frame was attached, only set if frame initiated from script.
/// </summary>
public Runtime.StackTrace Stack { get; set; }}
/// <summary>
/// Fired when frame no longer has a scheduled navigation.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameClearedScheduledNavigation</c>
/// </remarks>
internal class PageFrameClearedScheduledNavigationChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.frameClearedScheduledNavigation";
/// <summary>
/// Id of the frame that has cleared its scheduled navigation.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Fired when frame has been detached from its parent.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameDetached</c>
/// </remarks>
internal class PageFrameDetachedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.frameDetached";
/// <summary>
/// Id of the frame that has been detached.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Fired once navigation of the frame has completed. Frame is now associated with the new loader.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameNavigated</c>
/// </remarks>
internal class PageFrameNavigatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.frameNavigated";
/// <summary>
/// Frame object.
/// </summary>
public Frame Frame { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameResized</c>
/// </remarks>
internal class PageFrameResizedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.frameResized";
}
/// <summary>
/// Fired when a renderer-initiated navigation is requested.
/// Navigation may still be cancelled after the event is issued.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameRequestedNavigation</c>
/// </remarks>
internal class PageFrameRequestedNavigationChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.frameRequestedNavigation";
/// <summary>
/// Id of the frame that is being navigated.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// The reason for the navigation.
/// </summary>
public ClientNavigationReason Reason { get; set; }
/// <summary>
/// The destination URL for the requested navigation.
/// </summary>
public string Url { get; set; }}
/// <summary>
/// Fired when frame schedules a potential navigation.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameScheduledNavigation</c>
/// </remarks>
internal class PageFrameScheduledNavigationChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.frameScheduledNavigation";
/// <summary>
/// Id of the frame that has scheduled a navigation.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Delay (in seconds) until the navigation is scheduled to begin. The navigation is not
/// guaranteed to start.
/// </summary>
public double Delay { get; set; }
/// <summary>
/// The reason for the navigation.
/// </summary>
public string Reason { get; set; }
/// <summary>
/// The destination URL for the scheduled navigation.
/// </summary>
public string Url { get; set; }}
/// <summary>
/// Fired when frame has started loading.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameStartedLoading</c>
/// </remarks>
internal class PageFrameStartedLoadingChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.frameStartedLoading";
/// <summary>
/// Id of the frame that has started loading.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Fired when frame has stopped loading.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.frameStoppedLoading</c>
/// </remarks>
internal class PageFrameStoppedLoadingChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.frameStoppedLoading";
/// <summary>
/// Id of the frame that has stopped loading.
/// </summary>
public string FrameId { get; set; }}
/// <summary>
/// Fired when page is about to start a download.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.downloadWillBegin</c>
/// </remarks>
internal class PageDownloadWillBeginChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.downloadWillBegin";
/// <summary>
/// Id of the frame that caused download to begin.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// URL of the resource being downloaded.
/// </summary>
public string Url { get; set; }}
/// <summary>
/// Fired when interstitial page was hidden
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.interstitialHidden</c>
/// </remarks>
internal class PageInterstitialHiddenChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.interstitialHidden";
}
/// <summary>
/// Fired when interstitial page was shown
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.interstitialShown</c>
/// </remarks>
internal class PageInterstitialShownChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.interstitialShown";
}
/// <summary>
/// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been
/// closed.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.javascriptDialogClosed</c>
/// </remarks>
internal class PageJavascriptDialogClosedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.javascriptDialogClosed";
/// <summary>
/// Whether dialog was confirmed.
/// </summary>
public bool Result { get; set; }
/// <summary>
/// User input in case of prompt.
/// </summary>
public string UserInput { get; set; }}
/// <summary>
/// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to
/// open.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.javascriptDialogOpening</c>
/// </remarks>
internal class PageJavascriptDialogOpeningChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.javascriptDialogOpening";
/// <summary>
/// Frame url.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Message that will be displayed by the dialog.
/// </summary>
public string Message { get; set; }
/// <summary>
/// Dialog type.
/// </summary>
public DialogType Type { get; set; }
/// <summary>
/// True iff browser is capable showing or acting on the given dialog. When browser has no
/// dialog handler for given target, calling alert while Page domain is engaged will stall
/// the page execution. Execution can be resumed via calling Page.handleJavaScriptDialog.
/// </summary>
public bool HasBrowserHandler { get; set; }
/// <summary>
/// Default dialog prompt.
/// </summary>
public string DefaultPrompt { get; set; }}
/// <summary>
/// Fired for top level page lifecycle events such as navigation, load, paint, etc.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.lifecycleEvent</c>
/// </remarks>
internal class PageLifecycleEventChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.lifecycleEvent";
/// <summary>
/// Id of the frame.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Loader identifier. Empty string if the request is fetched from worker.
/// </summary>
public string LoaderId { get; set; }
/// <summary>
/// 
/// </summary>
public string Name { get; set; }
/// <summary>
/// 
/// </summary>
public double Timestamp { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.loadEventFired</c>
/// </remarks>
internal class PageLoadEventFiredChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.loadEventFired";
/// <summary>
/// 
/// </summary>
public double Timestamp { get; set; }}
/// <summary>
/// Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.navigatedWithinDocument</c>
/// </remarks>
internal class PageNavigatedWithinDocumentChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.navigatedWithinDocument";
/// <summary>
/// Id of the frame.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// Frame's new url.
/// </summary>
public string Url { get; set; }}
/// <summary>
/// Compressed image data requested by the `startScreencast`.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.screencastFrame</c>
/// </remarks>
internal class PageScreencastFrameChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.screencastFrame";
/// <summary>
/// Base64-encoded compressed image.
/// </summary>
public byte[] Data { get; set; }
/// <summary>
/// Screencast frame metadata.
/// </summary>
public ScreencastFrameMetadata Metadata { get; set; }
/// <summary>
/// Frame number.
/// </summary>
public int SessionId { get; set; }}
/// <summary>
/// Fired when the page with currently enabled screencast was shown or hidden `.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.screencastVisibilityChanged</c>
/// </remarks>
internal class PageScreencastVisibilityChangedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.screencastVisibilityChanged";
/// <summary>
/// True if the page is visible.
/// </summary>
public bool Visible { get; set; }}
/// <summary>
/// Fired when a new window is going to be opened, via window.open(), link click, form submission,
/// etc.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.windowOpen</c>
/// </remarks>
internal class PageWindowOpenChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.windowOpen";
/// <summary>
/// The URL for the new window.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Window name.
/// </summary>
public string WindowName { get; set; }
/// <summary>
/// An array of enabled window features.
/// </summary>
public string[] WindowFeatures { get; set; }
/// <summary>
/// Whether or not it was triggered by user gesture.
/// </summary>
public bool UserGesture { get; set; }}
/// <summary>
/// Issued for every compilation cache generated. Is only available
/// if Page.setGenerateCompilationCache is enabled.
/// </summary>
/// <remarks>
/// Matches on the event <c>Page.compilationCacheProduced</c>
/// </remarks>
internal class PageCompilationCacheProducedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Page.compilationCacheProduced";
/// <summary>
/// 
/// </summary>
public string Url { get; set; }
/// <summary>
/// Base64-encoded data
/// </summary>
public byte[] Data { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Performance
{
/// <summary>
/// Run-time execution metric.
/// </summary>
internal class Metric
{
/// <summary>
/// Metric name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Metric value.
/// </summary>
public double Value { get; set; }}
/// <summary>
/// Disable collecting and reporting metrics.
/// </summary>
/// <remarks>
/// Will send the command <c>Performance.disable</c>
/// </remarks>
internal class PerformanceDisableRequest : IChromiumRequest<PerformanceDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Performance.disable";
}
/// <summary>
/// Response from <see cref="PerformanceDisableRequest"/>
/// </summary>
internal class PerformanceDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enable collecting and reporting metrics.
/// </summary>
/// <remarks>
/// Will send the command <c>Performance.enable</c>
/// </remarks>
internal class PerformanceEnableRequest : IChromiumRequest<PerformanceEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Performance.enable";
}
/// <summary>
/// Response from <see cref="PerformanceEnableRequest"/>
/// </summary>
internal class PerformanceEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Sets time domain to use for collecting and reporting duration metrics.
/// Note that this must be called before enabling metrics collection. Calling
/// this method while metrics collection is enabled returns an error.
/// </summary>
/// <remarks>
/// Will send the command <c>Performance.setTimeDomain</c>
/// </remarks>
internal class PerformanceSetTimeDomainRequest : IChromiumRequest<PerformanceSetTimeDomainResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Performance.setTimeDomain";
/// <summary>
/// Time domain
/// </summary>
public string TimeDomain { get; set; }}
/// <summary>
/// Response from <see cref="PerformanceSetTimeDomainRequest"/>
/// </summary>
internal class PerformanceSetTimeDomainResponse : IChromiumResponse
{
}
/// <summary>
/// Retrieve current values of run-time metrics.
/// </summary>
/// <remarks>
/// Will send the command <c>Performance.getMetrics</c>
/// </remarks>
internal class PerformanceGetMetricsRequest : IChromiumRequest<PerformanceGetMetricsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Performance.getMetrics";
}
/// <summary>
/// Response from <see cref="PerformanceGetMetricsRequest"/>
/// </summary>
internal class PerformanceGetMetricsResponse : IChromiumResponse
{
/// <summary>
/// Current values for run-time metrics.
/// </summary>
public Metric[] Metrics { get; set; }}
/// <summary>
/// Current values of the metrics.
/// </summary>
/// <remarks>
/// Matches on the event <c>Performance.metrics</c>
/// </remarks>
internal class PerformanceMetricsChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Performance.metrics";
/// <summary>
/// Current values of the metrics.
/// </summary>
public Metric[] Metrics { get; set; }
/// <summary>
/// Timestamp title.
/// </summary>
public string Title { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Security
{
/// <summary>
/// A description of mixed content (HTTP resources on HTTPS pages), as defined by
/// https://www.w3.org/TR/mixed-content/#categories
/// </summary>
internal enum MixedContentType
{
[System.Runtime.Serialization.EnumMember(Value = "blockable")]Blockable,
[System.Runtime.Serialization.EnumMember(Value = "optionally-blockable")]OptionallyBlockable,
[System.Runtime.Serialization.EnumMember(Value = "none")]None}
/// <summary>
/// The security level of a page or resource.
/// </summary>
internal enum SecurityState
{
[System.Runtime.Serialization.EnumMember(Value = "unknown")]Unknown,
[System.Runtime.Serialization.EnumMember(Value = "neutral")]Neutral,
[System.Runtime.Serialization.EnumMember(Value = "insecure")]Insecure,
[System.Runtime.Serialization.EnumMember(Value = "secure")]Secure,
[System.Runtime.Serialization.EnumMember(Value = "info")]Info,
[System.Runtime.Serialization.EnumMember(Value = "insecure-broken")]InsecureBroken}
/// <summary>
/// Details about the security state of the page certificate.
/// </summary>
internal class CertificateSecurityState
{
/// <summary>
/// Protocol name (e.g. "TLS 1.2" or "QUIC").
/// </summary>
public string Protocol { get; set; }
/// <summary>
/// Key Exchange used by the connection, or the empty string if not applicable.
/// </summary>
public string KeyExchange { get; set; }
/// <summary>
/// (EC)DH group used by the connection, if applicable.
/// </summary>
public string KeyExchangeGroup { get; set; }
/// <summary>
/// Cipher name.
/// </summary>
public string Cipher { get; set; }
/// <summary>
/// TLS MAC. Note that AEAD ciphers do not have separate MACs.
/// </summary>
public string Mac { get; set; }
/// <summary>
/// Page certificate.
/// </summary>
public string[] Certificate { get; set; }
/// <summary>
/// Certificate subject name.
/// </summary>
public string SubjectName { get; set; }
/// <summary>
/// Name of the issuing CA.
/// </summary>
public string Issuer { get; set; }
/// <summary>
/// Certificate valid from date.
/// </summary>
public double ValidFrom { get; set; }
/// <summary>
/// Certificate valid to (expiration) date
/// </summary>
public double ValidTo { get; set; }
/// <summary>
/// The highest priority network error code, if the certificate has an error.
/// </summary>
public string CertificateNetworkError { get; set; }
/// <summary>
/// True if the certificate uses a weak signature aglorithm.
/// </summary>
public bool CertificateHasWeakSignature { get; set; }
/// <summary>
/// True if the certificate has a SHA1 signature in the chain.
/// </summary>
public bool CertificateHasSha1Signature { get; set; }
/// <summary>
/// True if modern SSL
/// </summary>
public bool ModernSSL { get; set; }
/// <summary>
/// True if the connection is using an obsolete SSL protocol.
/// </summary>
public bool ObsoleteSslProtocol { get; set; }
/// <summary>
/// True if the connection is using an obsolete SSL key exchange.
/// </summary>
public bool ObsoleteSslKeyExchange { get; set; }
/// <summary>
/// True if the connection is using an obsolete SSL cipher.
/// </summary>
public bool ObsoleteSslCipher { get; set; }
/// <summary>
/// True if the connection is using an obsolete SSL signature.
/// </summary>
public bool ObsoleteSslSignature { get; set; }}
/// <summary>
/// 
/// </summary>
internal enum SafetyTipStatus
{
[System.Runtime.Serialization.EnumMember(Value = "badReputation")]BadReputation,
[System.Runtime.Serialization.EnumMember(Value = "lookalike")]Lookalike}
/// <summary>
/// 
/// </summary>
internal class SafetyTipInfo
{
/// <summary>
/// Describes whether the page triggers any safety tips or reputation warnings. Default is unknown.
/// </summary>
public SafetyTipStatus SafetyTipStatus { get; set; }
/// <summary>
/// The URL the safety tip suggested ("Did you mean?"). Only filled in for lookalike matches.
/// </summary>
public string SafeUrl { get; set; }}
/// <summary>
/// Security state information about the page.
/// </summary>
internal class VisibleSecurityState
{
/// <summary>
/// The security level of the page.
/// </summary>
public SecurityState SecurityState { get; set; }
/// <summary>
/// Security state details about the page certificate.
/// </summary>
public CertificateSecurityState CertificateSecurityState { get; set; }
/// <summary>
/// The type of Safety Tip triggered on the page. Note that this field will be set even if the Safety Tip UI was not actually shown.
/// </summary>
public SafetyTipInfo SafetyTipInfo { get; set; }
/// <summary>
/// Array of security state issues ids.
/// </summary>
public string[] SecurityStateIssueIds { get; set; }}
/// <summary>
/// An explanation of an factor contributing to the security state.
/// </summary>
internal class SecurityStateExplanation
{
/// <summary>
/// Security state representing the severity of the factor being explained.
/// </summary>
public SecurityState SecurityState { get; set; }
/// <summary>
/// Title describing the type of factor.
/// </summary>
public string Title { get; set; }
/// <summary>
/// Short phrase describing the type of factor.
/// </summary>
public string Summary { get; set; }
/// <summary>
/// Full text explanation of the factor.
/// </summary>
public string Description { get; set; }
/// <summary>
/// The type of mixed content described by the explanation.
/// </summary>
public MixedContentType MixedContentType { get; set; }
/// <summary>
/// Page certificate.
/// </summary>
public string[] Certificate { get; set; }
/// <summary>
/// Recommendations to fix any issues.
/// </summary>
public string[] Recommendations { get; set; }}
/// <summary>
/// Information about insecure content on the page.
/// </summary>
internal class InsecureContentStatus
{
/// <summary>
/// Always false.
/// </summary>
public bool RanMixedContent { get; set; }
/// <summary>
/// Always false.
/// </summary>
public bool DisplayedMixedContent { get; set; }
/// <summary>
/// Always false.
/// </summary>
public bool ContainedMixedForm { get; set; }
/// <summary>
/// Always false.
/// </summary>
public bool RanContentWithCertErrors { get; set; }
/// <summary>
/// Always false.
/// </summary>
public bool DisplayedContentWithCertErrors { get; set; }
/// <summary>
/// Always set to unknown.
/// </summary>
public SecurityState RanInsecureContentStyle { get; set; }
/// <summary>
/// Always set to unknown.
/// </summary>
public SecurityState DisplayedInsecureContentStyle { get; set; }}
/// <summary>
/// The action to take when a certificate error occurs. continue will continue processing the
/// request and cancel will cancel the request.
/// </summary>
internal enum CertificateErrorAction
{
[System.Runtime.Serialization.EnumMember(Value = "continue")]Continue,
[System.Runtime.Serialization.EnumMember(Value = "cancel")]Cancel}
/// <summary>
/// Disables tracking security state changes.
/// </summary>
/// <remarks>
/// Will send the command <c>Security.disable</c>
/// </remarks>
internal class SecurityDisableRequest : IChromiumRequest<SecurityDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Security.disable";
}
/// <summary>
/// Response from <see cref="SecurityDisableRequest"/>
/// </summary>
internal class SecurityDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables tracking security state changes.
/// </summary>
/// <remarks>
/// Will send the command <c>Security.enable</c>
/// </remarks>
internal class SecurityEnableRequest : IChromiumRequest<SecurityEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Security.enable";
}
/// <summary>
/// Response from <see cref="SecurityEnableRequest"/>
/// </summary>
internal class SecurityEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Enable/disable whether all certificate errors should be ignored.
/// </summary>
/// <remarks>
/// Will send the command <c>Security.setIgnoreCertificateErrors</c>
/// </remarks>
internal class SecuritySetIgnoreCertificateErrorsRequest : IChromiumRequest<SecuritySetIgnoreCertificateErrorsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Security.setIgnoreCertificateErrors";
/// <summary>
/// If true, all certificate errors will be ignored.
/// </summary>
public bool Ignore { get; set; }}
/// <summary>
/// Response from <see cref="SecuritySetIgnoreCertificateErrorsRequest"/>
/// </summary>
internal class SecuritySetIgnoreCertificateErrorsResponse : IChromiumResponse
{
}
/// <summary>
/// Handles a certificate error that fired a certificateError event.
/// </summary>
/// <remarks>
/// Will send the command <c>Security.handleCertificateError</c>
/// </remarks>
internal class SecurityHandleCertificateErrorRequest : IChromiumRequest<SecurityHandleCertificateErrorResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Security.handleCertificateError";
/// <summary>
/// The ID of the event.
/// </summary>
public int EventId { get; set; }
/// <summary>
/// The action to take on the certificate error.
/// </summary>
public CertificateErrorAction Action { get; set; }}
/// <summary>
/// Response from <see cref="SecurityHandleCertificateErrorRequest"/>
/// </summary>
internal class SecurityHandleCertificateErrorResponse : IChromiumResponse
{
}
/// <summary>
/// Enable/disable overriding certificate errors. If enabled, all certificate error events need to
/// be handled by the DevTools client and should be answered with `handleCertificateError` commands.
/// </summary>
/// <remarks>
/// Will send the command <c>Security.setOverrideCertificateErrors</c>
/// </remarks>
internal class SecuritySetOverrideCertificateErrorsRequest : IChromiumRequest<SecuritySetOverrideCertificateErrorsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Security.setOverrideCertificateErrors";
/// <summary>
/// If true, certificate errors will be overridden.
/// </summary>
public bool Override { get; set; }}
/// <summary>
/// Response from <see cref="SecuritySetOverrideCertificateErrorsRequest"/>
/// </summary>
internal class SecuritySetOverrideCertificateErrorsResponse : IChromiumResponse
{
}
/// <summary>
/// There is a certificate error. If overriding certificate errors is enabled, then it should be
/// handled with the `handleCertificateError` command. Note: this event does not fire if the
/// certificate error has been allowed internally. Only one client per target should override
/// certificate errors at the same time.
/// </summary>
/// <remarks>
/// Matches on the event <c>Security.certificateError</c>
/// </remarks>
internal class SecurityCertificateErrorChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Security.certificateError";
/// <summary>
/// The ID of the event.
/// </summary>
public int EventId { get; set; }
/// <summary>
/// The type of the error.
/// </summary>
public string ErrorType { get; set; }
/// <summary>
/// The url that was requested.
/// </summary>
public string RequestURL { get; set; }}
/// <summary>
/// The security state of the page changed.
/// </summary>
/// <remarks>
/// Matches on the event <c>Security.visibleSecurityStateChanged</c>
/// </remarks>
internal class SecurityVisibleSecurityStateChangedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Security.visibleSecurityStateChanged";
/// <summary>
/// Security state information about the page.
/// </summary>
public VisibleSecurityState VisibleSecurityState { get; set; }}
/// <summary>
/// The security state of the page changed.
/// </summary>
/// <remarks>
/// Matches on the event <c>Security.securityStateChanged</c>
/// </remarks>
internal class SecuritySecurityStateChangedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Security.securityStateChanged";
/// <summary>
/// Security state.
/// </summary>
public SecurityState SecurityState { get; set; }
/// <summary>
/// True if the page was loaded over cryptographic transport such as HTTPS.
/// </summary>
public bool SchemeIsCryptographic { get; set; }
/// <summary>
/// List of explanations for the security state. If the overall security state is `insecure` or
/// `warning`, at least one corresponding explanation should be included.
/// </summary>
public SecurityStateExplanation[] Explanations { get; set; }
/// <summary>
/// Information about insecure content on the page.
/// </summary>
public InsecureContentStatus InsecureContentStatus { get; set; }
/// <summary>
/// Overrides user-visible description of the state.
/// </summary>
public string Summary { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.ServiceWorker
{
/// <summary>
/// ServiceWorker registration.
/// </summary>
internal class ServiceWorkerRegistration
{
/// <summary>
/// 
/// </summary>
public string RegistrationId { get; set; }
/// <summary>
/// 
/// </summary>
public string ScopeURL { get; set; }
/// <summary>
/// 
/// </summary>
public bool IsDeleted { get; set; }}
/// <summary>
/// 
/// </summary>
internal enum ServiceWorkerVersionRunningStatus
{
[System.Runtime.Serialization.EnumMember(Value = "stopped")]Stopped,
[System.Runtime.Serialization.EnumMember(Value = "starting")]Starting,
[System.Runtime.Serialization.EnumMember(Value = "running")]Running,
[System.Runtime.Serialization.EnumMember(Value = "stopping")]Stopping}
/// <summary>
/// 
/// </summary>
internal enum ServiceWorkerVersionStatus
{
[System.Runtime.Serialization.EnumMember(Value = "new")]New,
[System.Runtime.Serialization.EnumMember(Value = "installing")]Installing,
[System.Runtime.Serialization.EnumMember(Value = "installed")]Installed,
[System.Runtime.Serialization.EnumMember(Value = "activating")]Activating,
[System.Runtime.Serialization.EnumMember(Value = "activated")]Activated,
[System.Runtime.Serialization.EnumMember(Value = "redundant")]Redundant}
/// <summary>
/// ServiceWorker version.
/// </summary>
internal class ServiceWorkerVersion
{
/// <summary>
/// 
/// </summary>
public string VersionId { get; set; }
/// <summary>
/// 
/// </summary>
public string RegistrationId { get; set; }
/// <summary>
/// 
/// </summary>
public string ScriptURL { get; set; }
/// <summary>
/// 
/// </summary>
public ServiceWorkerVersionRunningStatus RunningStatus { get; set; }
/// <summary>
/// 
/// </summary>
public ServiceWorkerVersionStatus Status { get; set; }
/// <summary>
/// The Last-Modified header value of the main script.
/// </summary>
public double ScriptLastModified { get; set; }
/// <summary>
/// The time at which the response headers of the main script were received from the server.
/// For cached script it is the last time the cache entry was validated.
/// </summary>
public double ScriptResponseTime { get; set; }
/// <summary>
/// 
/// </summary>
public string[] ControlledClients { get; set; }
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// ServiceWorker error message.
/// </summary>
internal class ServiceWorkerErrorMessage
{
/// <summary>
/// 
/// </summary>
public string ErrorMessage { get; set; }
/// <summary>
/// 
/// </summary>
public string RegistrationId { get; set; }
/// <summary>
/// 
/// </summary>
public string VersionId { get; set; }
/// <summary>
/// 
/// </summary>
public string SourceURL { get; set; }
/// <summary>
/// 
/// </summary>
public int LineNumber { get; set; }
/// <summary>
/// 
/// </summary>
public int ColumnNumber { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>ServiceWorker.deliverPushMessage</c>
/// </remarks>
internal class ServiceWorkerDeliverPushMessageRequest : IChromiumRequest<ServiceWorkerDeliverPushMessageResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ServiceWorker.deliverPushMessage";
/// <summary>
/// 
/// </summary>
public string Origin { get; set; }
/// <summary>
/// 
/// </summary>
public string RegistrationId { get; set; }
/// <summary>
/// 
/// </summary>
public string Data { get; set; }}
/// <summary>
/// Response from <see cref="ServiceWorkerDeliverPushMessageRequest"/>
/// </summary>
internal class ServiceWorkerDeliverPushMessageResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>ServiceWorker.disable</c>
/// </remarks>
internal class ServiceWorkerDisableRequest : IChromiumRequest<ServiceWorkerDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ServiceWorker.disable";
}
/// <summary>
/// Response from <see cref="ServiceWorkerDisableRequest"/>
/// </summary>
internal class ServiceWorkerDisableResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>ServiceWorker.dispatchSyncEvent</c>
/// </remarks>
internal class ServiceWorkerDispatchSyncEventRequest : IChromiumRequest<ServiceWorkerDispatchSyncEventResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ServiceWorker.dispatchSyncEvent";
/// <summary>
/// 
/// </summary>
public string Origin { get; set; }
/// <summary>
/// 
/// </summary>
public string RegistrationId { get; set; }
/// <summary>
/// 
/// </summary>
public string Tag { get; set; }
/// <summary>
/// 
/// </summary>
public bool LastChance { get; set; }}
/// <summary>
/// Response from <see cref="ServiceWorkerDispatchSyncEventRequest"/>
/// </summary>
internal class ServiceWorkerDispatchSyncEventResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>ServiceWorker.dispatchPeriodicSyncEvent</c>
/// </remarks>
internal class ServiceWorkerDispatchPeriodicSyncEventRequest : IChromiumRequest<ServiceWorkerDispatchPeriodicSyncEventResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ServiceWorker.dispatchPeriodicSyncEvent";
/// <summary>
/// 
/// </summary>
public string Origin { get; set; }
/// <summary>
/// 
/// </summary>
public string RegistrationId { get; set; }
/// <summary>
/// 
/// </summary>
public string Tag { get; set; }}
/// <summary>
/// Response from <see cref="ServiceWorkerDispatchPeriodicSyncEventRequest"/>
/// </summary>
internal class ServiceWorkerDispatchPeriodicSyncEventResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>ServiceWorker.enable</c>
/// </remarks>
internal class ServiceWorkerEnableRequest : IChromiumRequest<ServiceWorkerEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ServiceWorker.enable";
}
/// <summary>
/// Response from <see cref="ServiceWorkerEnableRequest"/>
/// </summary>
internal class ServiceWorkerEnableResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>ServiceWorker.inspectWorker</c>
/// </remarks>
internal class ServiceWorkerInspectWorkerRequest : IChromiumRequest<ServiceWorkerInspectWorkerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ServiceWorker.inspectWorker";
/// <summary>
/// 
/// </summary>
public string VersionId { get; set; }}
/// <summary>
/// Response from <see cref="ServiceWorkerInspectWorkerRequest"/>
/// </summary>
internal class ServiceWorkerInspectWorkerResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>ServiceWorker.setForceUpdateOnPageLoad</c>
/// </remarks>
internal class ServiceWorkerSetForceUpdateOnPageLoadRequest : IChromiumRequest<ServiceWorkerSetForceUpdateOnPageLoadResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ServiceWorker.setForceUpdateOnPageLoad";
/// <summary>
/// 
/// </summary>
public bool ForceUpdateOnPageLoad { get; set; }}
/// <summary>
/// Response from <see cref="ServiceWorkerSetForceUpdateOnPageLoadRequest"/>
/// </summary>
internal class ServiceWorkerSetForceUpdateOnPageLoadResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>ServiceWorker.skipWaiting</c>
/// </remarks>
internal class ServiceWorkerSkipWaitingRequest : IChromiumRequest<ServiceWorkerSkipWaitingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ServiceWorker.skipWaiting";
/// <summary>
/// 
/// </summary>
public string ScopeURL { get; set; }}
/// <summary>
/// Response from <see cref="ServiceWorkerSkipWaitingRequest"/>
/// </summary>
internal class ServiceWorkerSkipWaitingResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>ServiceWorker.startWorker</c>
/// </remarks>
internal class ServiceWorkerStartWorkerRequest : IChromiumRequest<ServiceWorkerStartWorkerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ServiceWorker.startWorker";
/// <summary>
/// 
/// </summary>
public string ScopeURL { get; set; }}
/// <summary>
/// Response from <see cref="ServiceWorkerStartWorkerRequest"/>
/// </summary>
internal class ServiceWorkerStartWorkerResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>ServiceWorker.stopAllWorkers</c>
/// </remarks>
internal class ServiceWorkerStopAllWorkersRequest : IChromiumRequest<ServiceWorkerStopAllWorkersResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ServiceWorker.stopAllWorkers";
}
/// <summary>
/// Response from <see cref="ServiceWorkerStopAllWorkersRequest"/>
/// </summary>
internal class ServiceWorkerStopAllWorkersResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>ServiceWorker.stopWorker</c>
/// </remarks>
internal class ServiceWorkerStopWorkerRequest : IChromiumRequest<ServiceWorkerStopWorkerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ServiceWorker.stopWorker";
/// <summary>
/// 
/// </summary>
public string VersionId { get; set; }}
/// <summary>
/// Response from <see cref="ServiceWorkerStopWorkerRequest"/>
/// </summary>
internal class ServiceWorkerStopWorkerResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>ServiceWorker.unregister</c>
/// </remarks>
internal class ServiceWorkerUnregisterRequest : IChromiumRequest<ServiceWorkerUnregisterResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ServiceWorker.unregister";
/// <summary>
/// 
/// </summary>
public string ScopeURL { get; set; }}
/// <summary>
/// Response from <see cref="ServiceWorkerUnregisterRequest"/>
/// </summary>
internal class ServiceWorkerUnregisterResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>ServiceWorker.updateRegistration</c>
/// </remarks>
internal class ServiceWorkerUpdateRegistrationRequest : IChromiumRequest<ServiceWorkerUpdateRegistrationResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "ServiceWorker.updateRegistration";
/// <summary>
/// 
/// </summary>
public string ScopeURL { get; set; }}
/// <summary>
/// Response from <see cref="ServiceWorkerUpdateRegistrationRequest"/>
/// </summary>
internal class ServiceWorkerUpdateRegistrationResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>ServiceWorker.workerErrorReported</c>
/// </remarks>
internal class ServiceWorkerWorkerErrorReportedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "ServiceWorker.workerErrorReported";
/// <summary>
/// 
/// </summary>
public ServiceWorkerErrorMessage ErrorMessage { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>ServiceWorker.workerRegistrationUpdated</c>
/// </remarks>
internal class ServiceWorkerWorkerRegistrationUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "ServiceWorker.workerRegistrationUpdated";
/// <summary>
/// 
/// </summary>
public ServiceWorkerRegistration[] Registrations { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>ServiceWorker.workerVersionUpdated</c>
/// </remarks>
internal class ServiceWorkerWorkerVersionUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "ServiceWorker.workerVersionUpdated";
/// <summary>
/// 
/// </summary>
public ServiceWorkerVersion[] Versions { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Storage
{
/// <summary>
/// Enum of possible storage types.
/// </summary>
internal enum StorageType
{
[System.Runtime.Serialization.EnumMember(Value = "appcache")]Appcache,
[System.Runtime.Serialization.EnumMember(Value = "cookies")]Cookies,
[System.Runtime.Serialization.EnumMember(Value = "file_systems")]FileSystems,
[System.Runtime.Serialization.EnumMember(Value = "indexeddb")]Indexeddb,
[System.Runtime.Serialization.EnumMember(Value = "local_storage")]LocalStorage,
[System.Runtime.Serialization.EnumMember(Value = "shader_cache")]ShaderCache,
[System.Runtime.Serialization.EnumMember(Value = "websql")]Websql,
[System.Runtime.Serialization.EnumMember(Value = "service_workers")]ServiceWorkers,
[System.Runtime.Serialization.EnumMember(Value = "cache_storage")]CacheStorage,
[System.Runtime.Serialization.EnumMember(Value = "all")]All,
[System.Runtime.Serialization.EnumMember(Value = "other")]Other}
/// <summary>
/// Usage for a storage type.
/// </summary>
internal class UsageForType
{
/// <summary>
/// Name of storage type.
/// </summary>
public StorageType StorageType { get; set; }
/// <summary>
/// Storage usage (bytes).
/// </summary>
public double Usage { get; set; }}
/// <summary>
/// Clears storage for origin.
/// </summary>
/// <remarks>
/// Will send the command <c>Storage.clearDataForOrigin</c>
/// </remarks>
internal class StorageClearDataForOriginRequest : IChromiumRequest<StorageClearDataForOriginResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Storage.clearDataForOrigin";
/// <summary>
/// Security origin.
/// </summary>
public string Origin { get; set; }
/// <summary>
/// Comma separated list of StorageType to clear.
/// </summary>
public string StorageTypes { get; set; }}
/// <summary>
/// Response from <see cref="StorageClearDataForOriginRequest"/>
/// </summary>
internal class StorageClearDataForOriginResponse : IChromiumResponse
{
}
/// <summary>
/// Returns all browser cookies.
/// </summary>
/// <remarks>
/// Will send the command <c>Storage.getCookies</c>
/// </remarks>
internal class StorageGetCookiesRequest : IChromiumRequest<StorageGetCookiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Storage.getCookies";
/// <summary>
/// Browser context to use when called on the browser endpoint.
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// Response from <see cref="StorageGetCookiesRequest"/>
/// </summary>
internal class StorageGetCookiesResponse : IChromiumResponse
{
/// <summary>
/// Array of cookie objects.
/// </summary>
public Network.Cookie[] Cookies { get; set; }}
/// <summary>
/// Sets given cookies.
/// </summary>
/// <remarks>
/// Will send the command <c>Storage.setCookies</c>
/// </remarks>
internal class StorageSetCookiesRequest : IChromiumRequest<StorageSetCookiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Storage.setCookies";
/// <summary>
/// Cookies to be set.
/// </summary>
public Network.CookieParam[] Cookies { get; set; }
/// <summary>
/// Browser context to use when called on the browser endpoint.
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// Response from <see cref="StorageSetCookiesRequest"/>
/// </summary>
internal class StorageSetCookiesResponse : IChromiumResponse
{
}
/// <summary>
/// Clears cookies.
/// </summary>
/// <remarks>
/// Will send the command <c>Storage.clearCookies</c>
/// </remarks>
internal class StorageClearCookiesRequest : IChromiumRequest<StorageClearCookiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Storage.clearCookies";
/// <summary>
/// Browser context to use when called on the browser endpoint.
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// Response from <see cref="StorageClearCookiesRequest"/>
/// </summary>
internal class StorageClearCookiesResponse : IChromiumResponse
{
}
/// <summary>
/// Returns usage and quota in bytes.
/// </summary>
/// <remarks>
/// Will send the command <c>Storage.getUsageAndQuota</c>
/// </remarks>
internal class StorageGetUsageAndQuotaRequest : IChromiumRequest<StorageGetUsageAndQuotaResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Storage.getUsageAndQuota";
/// <summary>
/// Security origin.
/// </summary>
public string Origin { get; set; }}
/// <summary>
/// Response from <see cref="StorageGetUsageAndQuotaRequest"/>
/// </summary>
internal class StorageGetUsageAndQuotaResponse : IChromiumResponse
{
/// <summary>
/// Storage usage (bytes).
/// </summary>
public double Usage { get; set; }
/// <summary>
/// Storage quota (bytes).
/// </summary>
public double Quota { get; set; }
/// <summary>
/// Storage usage per type (bytes).
/// </summary>
public UsageForType[] UsageBreakdown { get; set; }}
/// <summary>
/// Registers origin to be notified when an update occurs to its cache storage list.
/// </summary>
/// <remarks>
/// Will send the command <c>Storage.trackCacheStorageForOrigin</c>
/// </remarks>
internal class StorageTrackCacheStorageForOriginRequest : IChromiumRequest<StorageTrackCacheStorageForOriginResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Storage.trackCacheStorageForOrigin";
/// <summary>
/// Security origin.
/// </summary>
public string Origin { get; set; }}
/// <summary>
/// Response from <see cref="StorageTrackCacheStorageForOriginRequest"/>
/// </summary>
internal class StorageTrackCacheStorageForOriginResponse : IChromiumResponse
{
}
/// <summary>
/// Registers origin to be notified when an update occurs to its IndexedDB.
/// </summary>
/// <remarks>
/// Will send the command <c>Storage.trackIndexedDBForOrigin</c>
/// </remarks>
internal class StorageTrackIndexedDBForOriginRequest : IChromiumRequest<StorageTrackIndexedDBForOriginResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Storage.trackIndexedDBForOrigin";
/// <summary>
/// Security origin.
/// </summary>
public string Origin { get; set; }}
/// <summary>
/// Response from <see cref="StorageTrackIndexedDBForOriginRequest"/>
/// </summary>
internal class StorageTrackIndexedDBForOriginResponse : IChromiumResponse
{
}
/// <summary>
/// Unregisters origin from receiving notifications for cache storage.
/// </summary>
/// <remarks>
/// Will send the command <c>Storage.untrackCacheStorageForOrigin</c>
/// </remarks>
internal class StorageUntrackCacheStorageForOriginRequest : IChromiumRequest<StorageUntrackCacheStorageForOriginResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Storage.untrackCacheStorageForOrigin";
/// <summary>
/// Security origin.
/// </summary>
public string Origin { get; set; }}
/// <summary>
/// Response from <see cref="StorageUntrackCacheStorageForOriginRequest"/>
/// </summary>
internal class StorageUntrackCacheStorageForOriginResponse : IChromiumResponse
{
}
/// <summary>
/// Unregisters origin from receiving notifications for IndexedDB.
/// </summary>
/// <remarks>
/// Will send the command <c>Storage.untrackIndexedDBForOrigin</c>
/// </remarks>
internal class StorageUntrackIndexedDBForOriginRequest : IChromiumRequest<StorageUntrackIndexedDBForOriginResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Storage.untrackIndexedDBForOrigin";
/// <summary>
/// Security origin.
/// </summary>
public string Origin { get; set; }}
/// <summary>
/// Response from <see cref="StorageUntrackIndexedDBForOriginRequest"/>
/// </summary>
internal class StorageUntrackIndexedDBForOriginResponse : IChromiumResponse
{
}
/// <summary>
/// A cache's contents have been modified.
/// </summary>
/// <remarks>
/// Matches on the event <c>Storage.cacheStorageContentUpdated</c>
/// </remarks>
internal class StorageCacheStorageContentUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Storage.cacheStorageContentUpdated";
/// <summary>
/// Origin to update.
/// </summary>
public string Origin { get; set; }
/// <summary>
/// Name of cache in origin.
/// </summary>
public string CacheName { get; set; }}
/// <summary>
/// A cache has been added/deleted.
/// </summary>
/// <remarks>
/// Matches on the event <c>Storage.cacheStorageListUpdated</c>
/// </remarks>
internal class StorageCacheStorageListUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Storage.cacheStorageListUpdated";
/// <summary>
/// Origin to update.
/// </summary>
public string Origin { get; set; }}
/// <summary>
/// The origin's IndexedDB object store has been modified.
/// </summary>
/// <remarks>
/// Matches on the event <c>Storage.indexedDBContentUpdated</c>
/// </remarks>
internal class StorageIndexedDBContentUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Storage.indexedDBContentUpdated";
/// <summary>
/// Origin to update.
/// </summary>
public string Origin { get; set; }
/// <summary>
/// Database to update.
/// </summary>
public string DatabaseName { get; set; }
/// <summary>
/// ObjectStore to update.
/// </summary>
public string ObjectStoreName { get; set; }}
/// <summary>
/// The origin's IndexedDB database list has been modified.
/// </summary>
/// <remarks>
/// Matches on the event <c>Storage.indexedDBListUpdated</c>
/// </remarks>
internal class StorageIndexedDBListUpdatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Storage.indexedDBListUpdated";
/// <summary>
/// Origin to update.
/// </summary>
public string Origin { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.SystemInfo
{
/// <summary>
/// Describes a single graphics processor (GPU).
/// </summary>
internal class GPUDevice
{
/// <summary>
/// PCI ID of the GPU vendor, if available; 0 otherwise.
/// </summary>
public double VendorId { get; set; }
/// <summary>
/// PCI ID of the GPU device, if available; 0 otherwise.
/// </summary>
public double DeviceId { get; set; }
/// <summary>
/// Sub sys ID of the GPU, only available on Windows.
/// </summary>
public double SubSysId { get; set; }
/// <summary>
/// Revision of the GPU, only available on Windows.
/// </summary>
public double Revision { get; set; }
/// <summary>
/// String description of the GPU vendor, if the PCI ID is not available.
/// </summary>
public string VendorString { get; set; }
/// <summary>
/// String description of the GPU device, if the PCI ID is not available.
/// </summary>
public string DeviceString { get; set; }
/// <summary>
/// String description of the GPU driver vendor.
/// </summary>
public string DriverVendor { get; set; }
/// <summary>
/// String description of the GPU driver version.
/// </summary>
public string DriverVersion { get; set; }}
/// <summary>
/// Describes the width and height dimensions of an entity.
/// </summary>
internal class Size
{
/// <summary>
/// Width in pixels.
/// </summary>
public int Width { get; set; }
/// <summary>
/// Height in pixels.
/// </summary>
public int Height { get; set; }}
/// <summary>
/// Describes a supported video decoding profile with its associated minimum and
/// maximum resolutions.
/// </summary>
internal class VideoDecodeAcceleratorCapability
{
/// <summary>
/// Video codec profile that is supported, e.g. VP9 Profile 2.
/// </summary>
public string Profile { get; set; }
/// <summary>
/// Maximum video dimensions in pixels supported for this |profile|.
/// </summary>
public Size MaxResolution { get; set; }
/// <summary>
/// Minimum video dimensions in pixels supported for this |profile|.
/// </summary>
public Size MinResolution { get; set; }}
/// <summary>
/// Describes a supported video encoding profile with its associated maximum
/// resolution and maximum framerate.
/// </summary>
internal class VideoEncodeAcceleratorCapability
{
/// <summary>
/// Video codec profile that is supported, e.g H264 Main.
/// </summary>
public string Profile { get; set; }
/// <summary>
/// Maximum video dimensions in pixels supported for this |profile|.
/// </summary>
public Size MaxResolution { get; set; }
/// <summary>
/// Maximum encoding framerate in frames per second supported for this
/// |profile|, as fraction's numerator and denominator, e.g. 24/1 fps,
/// 24000/1001 fps, etc.
/// </summary>
public int MaxFramerateNumerator { get; set; }
/// <summary>
/// 
/// </summary>
public int MaxFramerateDenominator { get; set; }}
/// <summary>
/// YUV subsampling type of the pixels of a given image.
/// </summary>
internal enum SubsamplingFormat
{
[System.Runtime.Serialization.EnumMember(Value = "yuv420")]Yuv420,
[System.Runtime.Serialization.EnumMember(Value = "yuv422")]Yuv422,
[System.Runtime.Serialization.EnumMember(Value = "yuv444")]Yuv444}
/// <summary>
/// Image format of a given image.
/// </summary>
internal enum ImageType
{
[System.Runtime.Serialization.EnumMember(Value = "jpeg")]Jpeg,
[System.Runtime.Serialization.EnumMember(Value = "webp")]Webp,
[System.Runtime.Serialization.EnumMember(Value = "unknown")]Unknown}
/// <summary>
/// Describes a supported image decoding profile with its associated minimum and
/// maximum resolutions and subsampling.
/// </summary>
internal class ImageDecodeAcceleratorCapability
{
/// <summary>
/// Image coded, e.g. Jpeg.
/// </summary>
public ImageType ImageType { get; set; }
/// <summary>
/// Maximum supported dimensions of the image in pixels.
/// </summary>
public Size MaxDimensions { get; set; }
/// <summary>
/// Minimum supported dimensions of the image in pixels.
/// </summary>
public Size MinDimensions { get; set; }
/// <summary>
/// Optional array of supported subsampling formats, e.g. 4:2:0, if known.
/// </summary>
public SubsamplingFormat[] Subsamplings { get; set; }}
/// <summary>
/// Provides information about the GPU(s) on the system.
/// </summary>
internal class GPUInfo
{
/// <summary>
/// The graphics devices on the system. Element 0 is the primary GPU.
/// </summary>
public GPUDevice[] Devices { get; set; }
/// <summary>
/// An optional dictionary of additional GPU related attributes.
/// </summary>
public JsonElement? AuxAttributes { get; set; }
/// <summary>
/// An optional dictionary of graphics features and their status.
/// </summary>
public JsonElement? FeatureStatus { get; set; }
/// <summary>
/// An optional array of GPU driver bug workarounds.
/// </summary>
public string[] DriverBugWorkarounds { get; set; }
/// <summary>
/// Supported accelerated video decoding capabilities.
/// </summary>
public VideoDecodeAcceleratorCapability[] VideoDecoding { get; set; }
/// <summary>
/// Supported accelerated video encoding capabilities.
/// </summary>
public VideoEncodeAcceleratorCapability[] VideoEncoding { get; set; }
/// <summary>
/// Supported accelerated image decoding capabilities.
/// </summary>
public ImageDecodeAcceleratorCapability[] ImageDecoding { get; set; }}
/// <summary>
/// Represents process info.
/// </summary>
internal class ProcessInfo
{
/// <summary>
/// Specifies process type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Specifies process id.
/// </summary>
public int Id { get; set; }
/// <summary>
/// Specifies cumulative CPU usage in seconds across all threads of the
/// process since the process start.
/// </summary>
public double CpuTime { get; set; }}
/// <summary>
/// Returns information about the system.
/// </summary>
/// <remarks>
/// Will send the command <c>SystemInfo.getInfo</c>
/// </remarks>
internal class SystemInfoGetInfoRequest : IChromiumRequest<SystemInfoGetInfoResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "SystemInfo.getInfo";
}
/// <summary>
/// Response from <see cref="SystemInfoGetInfoRequest"/>
/// </summary>
internal class SystemInfoGetInfoResponse : IChromiumResponse
{
/// <summary>
/// Information about the GPUs on the system.
/// </summary>
public GPUInfo Gpu { get; set; }
/// <summary>
/// A platform-dependent description of the model of the machine. On Mac OS, this is, for
/// example, 'MacBookPro'. Will be the empty string if not supported.
/// </summary>
public string ModelName { get; set; }
/// <summary>
/// A platform-dependent description of the version of the machine. On Mac OS, this is, for
/// example, '10.1'. Will be the empty string if not supported.
/// </summary>
public string ModelVersion { get; set; }
/// <summary>
/// The command line string used to launch the browser. Will be the empty string if not
/// supported.
/// </summary>
public string CommandLine { get; set; }}
/// <summary>
/// Returns information about all running processes.
/// </summary>
/// <remarks>
/// Will send the command <c>SystemInfo.getProcessInfo</c>
/// </remarks>
internal class SystemInfoGetProcessInfoRequest : IChromiumRequest<SystemInfoGetProcessInfoResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "SystemInfo.getProcessInfo";
}
/// <summary>
/// Response from <see cref="SystemInfoGetProcessInfoRequest"/>
/// </summary>
internal class SystemInfoGetProcessInfoResponse : IChromiumResponse
{
/// <summary>
/// An array of process info blocks.
/// </summary>
public ProcessInfo[] ProcessInfo { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Target
{
/// <summary>
/// 
/// </summary>
internal class TargetInfo
{
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }
/// <summary>
/// 
/// </summary>
public string Type { get; set; }
/// <summary>
/// 
/// </summary>
public string Title { get; set; }
/// <summary>
/// 
/// </summary>
public string Url { get; set; }
/// <summary>
/// Whether the target has an attached client.
/// </summary>
public bool Attached { get; set; }
/// <summary>
/// Opener target Id
/// </summary>
public string OpenerId { get; set; }
/// <summary>
/// 
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// 
/// </summary>
internal class RemoteLocation
{
/// <summary>
/// 
/// </summary>
public string Host { get; set; }
/// <summary>
/// 
/// </summary>
public int Port { get; set; }}
/// <summary>
/// Activates (focuses) the target.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.activateTarget</c>
/// </remarks>
internal class TargetActivateTargetRequest : IChromiumRequest<TargetActivateTargetResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.activateTarget";
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// Response from <see cref="TargetActivateTargetRequest"/>
/// </summary>
internal class TargetActivateTargetResponse : IChromiumResponse
{
}
/// <summary>
/// Attaches to the target with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.attachToTarget</c>
/// </remarks>
internal class TargetAttachToTargetRequest : IChromiumRequest<TargetAttachToTargetResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.attachToTarget";
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }
/// <summary>
/// Enables "flat" access to the session via specifying sessionId attribute in the commands.
/// We plan to make this the default, deprecate non-flattened mode,
/// and eventually retire it. See crbug.com/991325.
/// </summary>
public bool Flatten { get; set; }}
/// <summary>
/// Response from <see cref="TargetAttachToTargetRequest"/>
/// </summary>
internal class TargetAttachToTargetResponse : IChromiumResponse
{
/// <summary>
/// Id assigned to the session.
/// </summary>
public string SessionId { get; set; }}
/// <summary>
/// Attaches to the browser target, only uses flat sessionId mode.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.attachToBrowserTarget</c>
/// </remarks>
internal class TargetAttachToBrowserTargetRequest : IChromiumRequest<TargetAttachToBrowserTargetResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.attachToBrowserTarget";
}
/// <summary>
/// Response from <see cref="TargetAttachToBrowserTargetRequest"/>
/// </summary>
internal class TargetAttachToBrowserTargetResponse : IChromiumResponse
{
/// <summary>
/// Id assigned to the session.
/// </summary>
public string SessionId { get; set; }}
/// <summary>
/// Closes the target. If the target is a page that gets closed too.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.closeTarget</c>
/// </remarks>
internal class TargetCloseTargetRequest : IChromiumRequest<TargetCloseTargetResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.closeTarget";
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// Response from <see cref="TargetCloseTargetRequest"/>
/// </summary>
internal class TargetCloseTargetResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public bool Success { get; set; }}
/// <summary>
/// Inject object to the target's main frame that provides a communication
/// channel with browser target.
/// 
/// Injected object will be available as `window[bindingName]`.
/// 
/// The object has the follwing API:
/// - `binding.send(json)` - a method to send messages over the remote debugging protocol
/// - `binding.onmessage = json =&gt; handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.exposeDevToolsProtocol</c>
/// </remarks>
internal class TargetExposeDevToolsProtocolRequest : IChromiumRequest<TargetExposeDevToolsProtocolResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.exposeDevToolsProtocol";
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }
/// <summary>
/// Binding name, 'cdp' if not specified.
/// </summary>
public string BindingName { get; set; }}
/// <summary>
/// Response from <see cref="TargetExposeDevToolsProtocolRequest"/>
/// </summary>
internal class TargetExposeDevToolsProtocolResponse : IChromiumResponse
{
}
/// <summary>
/// Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
/// one.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.createBrowserContext</c>
/// </remarks>
internal class TargetCreateBrowserContextRequest : IChromiumRequest<TargetCreateBrowserContextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.createBrowserContext";
}
/// <summary>
/// Response from <see cref="TargetCreateBrowserContextRequest"/>
/// </summary>
internal class TargetCreateBrowserContextResponse : IChromiumResponse
{
/// <summary>
/// The id of the context created.
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// Returns all browser contexts created with `Target.createBrowserContext` method.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.getBrowserContexts</c>
/// </remarks>
internal class TargetGetBrowserContextsRequest : IChromiumRequest<TargetGetBrowserContextsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.getBrowserContexts";
}
/// <summary>
/// Response from <see cref="TargetGetBrowserContextsRequest"/>
/// </summary>
internal class TargetGetBrowserContextsResponse : IChromiumResponse
{
/// <summary>
/// An array of browser context ids.
/// </summary>
public string[] BrowserContextIds { get; set; }}
/// <summary>
/// Creates a new page.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.createTarget</c>
/// </remarks>
internal class TargetCreateTargetRequest : IChromiumRequest<TargetCreateTargetResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.createTarget";
/// <summary>
/// The initial URL the page will be navigated to.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Frame width in DIP (headless chrome only).
/// </summary>
public int Width { get; set; }
/// <summary>
/// Frame height in DIP (headless chrome only).
/// </summary>
public int Height { get; set; }
/// <summary>
/// The browser context to create the page in.
/// </summary>
public string BrowserContextId { get; set; }
/// <summary>
/// Whether BeginFrames for this target will be controlled via DevTools (headless chrome only,
/// not supported on MacOS yet, false by default).
/// </summary>
public bool EnableBeginFrameControl { get; set; }
/// <summary>
/// Whether to create a new Window or Tab (chrome-only, false by default).
/// </summary>
public bool NewWindow { get; set; }
/// <summary>
/// Whether to create the target in background or foreground (chrome-only,
/// false by default).
/// </summary>
public bool Background { get; set; }}
/// <summary>
/// Response from <see cref="TargetCreateTargetRequest"/>
/// </summary>
internal class TargetCreateTargetResponse : IChromiumResponse
{
/// <summary>
/// The id of the page opened.
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// Detaches session with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.detachFromTarget</c>
/// </remarks>
internal class TargetDetachFromTargetRequest : IChromiumRequest<TargetDetachFromTargetResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.detachFromTarget";
/// <summary>
/// Session to detach.
/// </summary>
public string SessionId { get; set; }
/// <summary>
/// Deprecated.
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// Response from <see cref="TargetDetachFromTargetRequest"/>
/// </summary>
internal class TargetDetachFromTargetResponse : IChromiumResponse
{
}
/// <summary>
/// Deletes a BrowserContext. All the belonging pages will be closed without calling their
/// beforeunload hooks.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.disposeBrowserContext</c>
/// </remarks>
internal class TargetDisposeBrowserContextRequest : IChromiumRequest<TargetDisposeBrowserContextResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.disposeBrowserContext";
/// <summary>
/// 
/// </summary>
public string BrowserContextId { get; set; }}
/// <summary>
/// Response from <see cref="TargetDisposeBrowserContextRequest"/>
/// </summary>
internal class TargetDisposeBrowserContextResponse : IChromiumResponse
{
}
/// <summary>
/// Returns information about a target.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.getTargetInfo</c>
/// </remarks>
internal class TargetGetTargetInfoRequest : IChromiumRequest<TargetGetTargetInfoResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.getTargetInfo";
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// Response from <see cref="TargetGetTargetInfoRequest"/>
/// </summary>
internal class TargetGetTargetInfoResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public TargetInfo TargetInfo { get; set; }}
/// <summary>
/// Retrieves a list of available targets.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.getTargets</c>
/// </remarks>
internal class TargetGetTargetsRequest : IChromiumRequest<TargetGetTargetsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.getTargets";
}
/// <summary>
/// Response from <see cref="TargetGetTargetsRequest"/>
/// </summary>
internal class TargetGetTargetsResponse : IChromiumResponse
{
/// <summary>
/// The list of targets.
/// </summary>
public TargetInfo[] TargetInfos { get; set; }}
/// <summary>
/// Sends protocol message over session with given id.
/// Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
/// and crbug.com/991325.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.sendMessageToTarget</c>
/// </remarks>
internal class TargetSendMessageToTargetRequest : IChromiumRequest<TargetSendMessageToTargetResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.sendMessageToTarget";
/// <summary>
/// 
/// </summary>
public string Message { get; set; }
/// <summary>
/// Identifier of the session.
/// </summary>
public string SessionId { get; set; }
/// <summary>
/// Deprecated.
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// Response from <see cref="TargetSendMessageToTargetRequest"/>
/// </summary>
internal class TargetSendMessageToTargetResponse : IChromiumResponse
{
}
/// <summary>
/// Controls whether to automatically attach to new targets which are considered to be related to
/// this one. When turned on, attaches to all existing related targets as well. When turned off,
/// automatically detaches from all currently attached targets.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.setAutoAttach</c>
/// </remarks>
internal class TargetSetAutoAttachRequest : IChromiumRequest<TargetSetAutoAttachResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.setAutoAttach";
/// <summary>
/// Whether to auto-attach to related targets.
/// </summary>
public bool AutoAttach { get; set; }
/// <summary>
/// Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`
/// to run paused targets.
/// </summary>
public bool WaitForDebuggerOnStart { get; set; }
/// <summary>
/// Enables "flat" access to the session via specifying sessionId attribute in the commands.
/// We plan to make this the default, deprecate non-flattened mode,
/// and eventually retire it. See crbug.com/991325.
/// </summary>
public bool Flatten { get; set; }
/// <summary>
/// Auto-attach to the targets created via window.open from current target.
/// </summary>
public bool WindowOpen { get; set; }}
/// <summary>
/// Response from <see cref="TargetSetAutoAttachRequest"/>
/// </summary>
internal class TargetSetAutoAttachResponse : IChromiumResponse
{
}
/// <summary>
/// Controls whether to discover available targets and notify via
/// `targetCreated/targetInfoChanged/targetDestroyed` events.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.setDiscoverTargets</c>
/// </remarks>
internal class TargetSetDiscoverTargetsRequest : IChromiumRequest<TargetSetDiscoverTargetsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.setDiscoverTargets";
/// <summary>
/// Whether to discover available targets.
/// </summary>
public bool Discover { get; set; }}
/// <summary>
/// Response from <see cref="TargetSetDiscoverTargetsRequest"/>
/// </summary>
internal class TargetSetDiscoverTargetsResponse : IChromiumResponse
{
}
/// <summary>
/// Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
/// `true`.
/// </summary>
/// <remarks>
/// Will send the command <c>Target.setRemoteLocations</c>
/// </remarks>
internal class TargetSetRemoteLocationsRequest : IChromiumRequest<TargetSetRemoteLocationsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Target.setRemoteLocations";
/// <summary>
/// List of remote locations.
/// </summary>
public RemoteLocation[] Locations { get; set; }}
/// <summary>
/// Response from <see cref="TargetSetRemoteLocationsRequest"/>
/// </summary>
internal class TargetSetRemoteLocationsResponse : IChromiumResponse
{
}
/// <summary>
/// Issued when attached to target because of auto-attach or `attachToTarget` command.
/// </summary>
/// <remarks>
/// Matches on the event <c>Target.attachedToTarget</c>
/// </remarks>
internal class TargetAttachedToTargetChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Target.attachedToTarget";
/// <summary>
/// Identifier assigned to the session used to send/receive messages.
/// </summary>
public string SessionId { get; set; }
/// <summary>
/// 
/// </summary>
public TargetInfo TargetInfo { get; set; }
/// <summary>
/// 
/// </summary>
public bool WaitingForDebugger { get; set; }}
/// <summary>
/// Issued when detached from target for any reason (including `detachFromTarget` command). Can be
/// issued multiple times per target if multiple sessions have been attached to it.
/// </summary>
/// <remarks>
/// Matches on the event <c>Target.detachedFromTarget</c>
/// </remarks>
internal class TargetDetachedFromTargetChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Target.detachedFromTarget";
/// <summary>
/// Detached session identifier.
/// </summary>
public string SessionId { get; set; }
/// <summary>
/// Deprecated.
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// Notifies about a new protocol message received from the session (as reported in
/// `attachedToTarget` event).
/// </summary>
/// <remarks>
/// Matches on the event <c>Target.receivedMessageFromTarget</c>
/// </remarks>
internal class TargetReceivedMessageFromTargetChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Target.receivedMessageFromTarget";
/// <summary>
/// Identifier of a session which sends a message.
/// </summary>
public string SessionId { get; set; }
/// <summary>
/// 
/// </summary>
public string Message { get; set; }
/// <summary>
/// Deprecated.
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// Issued when a possible inspection target is created.
/// </summary>
/// <remarks>
/// Matches on the event <c>Target.targetCreated</c>
/// </remarks>
internal class TargetTargetCreatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Target.targetCreated";
/// <summary>
/// 
/// </summary>
public TargetInfo TargetInfo { get; set; }}
/// <summary>
/// Issued when a target is destroyed.
/// </summary>
/// <remarks>
/// Matches on the event <c>Target.targetDestroyed</c>
/// </remarks>
internal class TargetTargetDestroyedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Target.targetDestroyed";
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }}
/// <summary>
/// Issued when a target has crashed.
/// </summary>
/// <remarks>
/// Matches on the event <c>Target.targetCrashed</c>
/// </remarks>
internal class TargetTargetCrashedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Target.targetCrashed";
/// <summary>
/// 
/// </summary>
public string TargetId { get; set; }
/// <summary>
/// Termination status type.
/// </summary>
public string Status { get; set; }
/// <summary>
/// Termination error code.
/// </summary>
public int ErrorCode { get; set; }}
/// <summary>
/// Issued when some information about a target has changed. This only happens between
/// `targetCreated` and `targetDestroyed`.
/// </summary>
/// <remarks>
/// Matches on the event <c>Target.targetInfoChanged</c>
/// </remarks>
internal class TargetTargetInfoChangedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Target.targetInfoChanged";
/// <summary>
/// 
/// </summary>
public TargetInfo TargetInfo { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Tethering
{
/// <summary>
/// Request browser port binding.
/// </summary>
/// <remarks>
/// Will send the command <c>Tethering.bind</c>
/// </remarks>
internal class TetheringBindRequest : IChromiumRequest<TetheringBindResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Tethering.bind";
/// <summary>
/// Port number to bind.
/// </summary>
public int Port { get; set; }}
/// <summary>
/// Response from <see cref="TetheringBindRequest"/>
/// </summary>
internal class TetheringBindResponse : IChromiumResponse
{
}
/// <summary>
/// Request browser port unbinding.
/// </summary>
/// <remarks>
/// Will send the command <c>Tethering.unbind</c>
/// </remarks>
internal class TetheringUnbindRequest : IChromiumRequest<TetheringUnbindResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Tethering.unbind";
/// <summary>
/// Port number to unbind.
/// </summary>
public int Port { get; set; }}
/// <summary>
/// Response from <see cref="TetheringUnbindRequest"/>
/// </summary>
internal class TetheringUnbindResponse : IChromiumResponse
{
}
/// <summary>
/// Informs that port was successfully bound and got a specified connection id.
/// </summary>
/// <remarks>
/// Matches on the event <c>Tethering.accepted</c>
/// </remarks>
internal class TetheringAcceptedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Tethering.accepted";
/// <summary>
/// Port number that was successfully bound.
/// </summary>
public int Port { get; set; }
/// <summary>
/// Connection id to be used.
/// </summary>
public string ConnectionId { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Tracing
{
/// <summary>
/// Configuration for memory dump. Used only when "memory-infra" category is enabled.
/// </summary>
internal class MemoryDumpConfig
{
}
/// <summary>
/// 
/// </summary>
internal class TraceConfig
{
/// <summary>
/// Controls how the trace buffer stores data.
/// </summary>
public string RecordMode { get; set; }
/// <summary>
/// Turns on JavaScript stack sampling.
/// </summary>
public bool EnableSampling { get; set; }
/// <summary>
/// Turns on system tracing.
/// </summary>
public bool EnableSystrace { get; set; }
/// <summary>
/// Turns on argument filter.
/// </summary>
public bool EnableArgumentFilter { get; set; }
/// <summary>
/// Included category filters.
/// </summary>
public string[] IncludedCategories { get; set; }
/// <summary>
/// Excluded category filters.
/// </summary>
public string[] ExcludedCategories { get; set; }
/// <summary>
/// Configuration to synthesize the delays in tracing.
/// </summary>
public string[] SyntheticDelays { get; set; }
/// <summary>
/// Configuration for memory dump triggers. Used only when "memory-infra" category is enabled.
/// </summary>
public MemoryDumpConfig MemoryDumpConfig { get; set; }}
/// <summary>
/// Data format of a trace. Can be either the legacy JSON format or the
/// protocol buffer format. Note that the JSON format will be deprecated soon.
/// </summary>
internal enum StreamFormat
{
[System.Runtime.Serialization.EnumMember(Value = "json")]Json,
[System.Runtime.Serialization.EnumMember(Value = "proto")]Proto}
/// <summary>
/// Compression type to use for traces returned via streams.
/// </summary>
internal enum StreamCompression
{
[System.Runtime.Serialization.EnumMember(Value = "none")]None,
[System.Runtime.Serialization.EnumMember(Value = "gzip")]Gzip}
/// <summary>
/// Stop trace events collection.
/// </summary>
/// <remarks>
/// Will send the command <c>Tracing.end</c>
/// </remarks>
internal class TracingEndRequest : IChromiumRequest<TracingEndResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Tracing.end";
}
/// <summary>
/// Response from <see cref="TracingEndRequest"/>
/// </summary>
internal class TracingEndResponse : IChromiumResponse
{
}
/// <summary>
/// Gets supported tracing categories.
/// </summary>
/// <remarks>
/// Will send the command <c>Tracing.getCategories</c>
/// </remarks>
internal class TracingGetCategoriesRequest : IChromiumRequest<TracingGetCategoriesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Tracing.getCategories";
}
/// <summary>
/// Response from <see cref="TracingGetCategoriesRequest"/>
/// </summary>
internal class TracingGetCategoriesResponse : IChromiumResponse
{
/// <summary>
/// A list of supported tracing categories.
/// </summary>
public string[] Categories { get; set; }}
/// <summary>
/// Record a clock sync marker in the trace.
/// </summary>
/// <remarks>
/// Will send the command <c>Tracing.recordClockSyncMarker</c>
/// </remarks>
internal class TracingRecordClockSyncMarkerRequest : IChromiumRequest<TracingRecordClockSyncMarkerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Tracing.recordClockSyncMarker";
/// <summary>
/// The ID of this clock sync marker
/// </summary>
public string SyncId { get; set; }}
/// <summary>
/// Response from <see cref="TracingRecordClockSyncMarkerRequest"/>
/// </summary>
internal class TracingRecordClockSyncMarkerResponse : IChromiumResponse
{
}
/// <summary>
/// Request a global memory dump.
/// </summary>
/// <remarks>
/// Will send the command <c>Tracing.requestMemoryDump</c>
/// </remarks>
internal class TracingRequestMemoryDumpRequest : IChromiumRequest<TracingRequestMemoryDumpResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Tracing.requestMemoryDump";
/// <summary>
/// Enables more deterministic results by forcing garbage collection
/// </summary>
public bool Deterministic { get; set; }}
/// <summary>
/// Response from <see cref="TracingRequestMemoryDumpRequest"/>
/// </summary>
internal class TracingRequestMemoryDumpResponse : IChromiumResponse
{
/// <summary>
/// GUID of the resulting global memory dump.
/// </summary>
public string DumpGuid { get; set; }
/// <summary>
/// True iff the global memory dump succeeded.
/// </summary>
public bool Success { get; set; }}
/// <summary>
/// Start trace events collection.
/// </summary>
/// <remarks>
/// Will send the command <c>Tracing.start</c>
/// </remarks>
internal class TracingStartRequest : IChromiumRequest<TracingStartResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Tracing.start";
/// <summary>
/// Category/tag filter
/// </summary>
public string Categories { get; set; }
/// <summary>
/// Tracing options
/// </summary>
public string Options { get; set; }
/// <summary>
/// If set, the agent will issue bufferUsage events at this interval, specified in milliseconds
/// </summary>
public double BufferUsageReportingInterval { get; set; }
/// <summary>
/// Whether to report trace events as series of dataCollected events or to save trace to a
/// stream (defaults to `ReportEvents`).
/// </summary>
public string TransferMode { get; set; }
/// <summary>
/// Trace data format to use. This only applies when using `ReturnAsStream`
/// transfer mode (defaults to `json`).
/// </summary>
public StreamFormat StreamFormat { get; set; }
/// <summary>
/// Compression format to use. This only applies when using `ReturnAsStream`
/// transfer mode (defaults to `none`)
/// </summary>
public StreamCompression StreamCompression { get; set; }
/// <summary>
/// 
/// </summary>
public TraceConfig TraceConfig { get; set; }}
/// <summary>
/// Response from <see cref="TracingStartRequest"/>
/// </summary>
internal class TracingStartResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Tracing.bufferUsage</c>
/// </remarks>
internal class TracingBufferUsageChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Tracing.bufferUsage";
/// <summary>
/// A number in range [0..1] that indicates the used size of event buffer as a fraction of its
/// total size.
/// </summary>
public double PercentFull { get; set; }
/// <summary>
/// An approximate number of events in the trace log.
/// </summary>
public double EventCount { get; set; }
/// <summary>
/// A number in range [0..1] that indicates the used size of event buffer as a fraction of its
/// total size.
/// </summary>
public double Value { get; set; }}
/// <summary>
/// Contains an bucket of collected trace events. When tracing is stopped collected events will be
/// send as a sequence of dataCollected events followed by tracingComplete event.
/// </summary>
/// <remarks>
/// Matches on the event <c>Tracing.dataCollected</c>
/// </remarks>
internal class TracingDataCollectedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Tracing.dataCollected";
/// <summary>
/// 
/// </summary>
public JsonElement?[] Value { get; set; }}
/// <summary>
/// Signals that tracing is stopped and there is no trace buffers pending flush, all data were
/// delivered via dataCollected events.
/// </summary>
/// <remarks>
/// Matches on the event <c>Tracing.tracingComplete</c>
/// </remarks>
internal class TracingTracingCompleteChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Tracing.tracingComplete";
/// <summary>
/// Indicates whether some trace data is known to have been lost, e.g. because the trace ring
/// buffer wrapped around.
/// </summary>
public bool DataLossOccurred { get; set; }
/// <summary>
/// A handle of the stream that holds resulting trace data.
/// </summary>
public string Stream { get; set; }
/// <summary>
/// Trace data format of returned stream.
/// </summary>
public StreamFormat TraceFormat { get; set; }
/// <summary>
/// Compression format of returned stream.
/// </summary>
public StreamCompression StreamCompression { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Fetch
{
/// <summary>
/// Stages of the request to handle. Request will intercept before the request is
/// sent. Response will intercept after the response is received (but before response
/// body is received.
/// </summary>
internal enum RequestStage
{
[System.Runtime.Serialization.EnumMember(Value = "Request")]Request,
[System.Runtime.Serialization.EnumMember(Value = "Response")]Response}
/// <summary>
/// 
/// </summary>
internal class RequestPattern
{
/// <summary>
/// Wildcards ('*' -&gt; zero or more, '?' -&gt; exactly one) are allowed. Escape character is
/// backslash. Omitting is equivalent to "*".
/// </summary>
public string UrlPattern { get; set; }
/// <summary>
/// If set, only requests for matching resource types will be intercepted.
/// </summary>
public Network.ResourceType ResourceType { get; set; }
/// <summary>
/// Stage at wich to begin intercepting requests. Default is Request.
/// </summary>
public RequestStage RequestStage { get; set; }}
/// <summary>
/// Response HTTP header entry
/// </summary>
internal class HeaderEntry
{
/// <summary>
/// 
/// </summary>
public string Name { get; set; }
/// <summary>
/// 
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Authorization challenge for HTTP status code 401 or 407.
/// </summary>
internal class AuthChallenge
{
/// <summary>
/// Source of the authentication challenge.
/// </summary>
public string Source { get; set; }
/// <summary>
/// Origin of the challenger.
/// </summary>
public string Origin { get; set; }
/// <summary>
/// The authentication scheme used, such as basic or digest
/// </summary>
public string Scheme { get; set; }
/// <summary>
/// The realm of the challenge. May be empty.
/// </summary>
public string Realm { get; set; }}
/// <summary>
/// Response to an AuthChallenge.
/// </summary>
internal class AuthChallengeResponse
{
/// <summary>
/// The decision on what to do in response to the authorization challenge.  Default means
/// deferring to the default behavior of the net stack, which will likely either the Cancel
/// authentication or display a popup dialog box.
/// </summary>
public string Response { get; set; }
/// <summary>
/// The username to provide, possibly empty. Should only be set if response is
/// ProvideCredentials.
/// </summary>
public string Username { get; set; }
/// <summary>
/// The password to provide, possibly empty. Should only be set if response is
/// ProvideCredentials.
/// </summary>
public string Password { get; set; }}
/// <summary>
/// Disables the fetch domain.
/// </summary>
/// <remarks>
/// Will send the command <c>Fetch.disable</c>
/// </remarks>
internal class FetchDisableRequest : IChromiumRequest<FetchDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Fetch.disable";
}
/// <summary>
/// Response from <see cref="FetchDisableRequest"/>
/// </summary>
internal class FetchDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables issuing of requestPaused events. A request will be paused until client
/// calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
/// </summary>
/// <remarks>
/// Will send the command <c>Fetch.enable</c>
/// </remarks>
internal class FetchEnableRequest : IChromiumRequest<FetchEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Fetch.enable";
/// <summary>
/// If specified, only requests matching any of these patterns will produce
/// fetchRequested event and will be paused until clients response. If not set,
/// all requests will be affected.
/// </summary>
public RequestPattern[] Patterns { get; set; }
/// <summary>
/// If true, authRequired events will be issued and requests will be paused
/// expecting a call to continueWithAuth.
/// </summary>
public bool HandleAuthRequests { get; set; }}
/// <summary>
/// Response from <see cref="FetchEnableRequest"/>
/// </summary>
internal class FetchEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Causes the request to fail with specified reason.
/// </summary>
/// <remarks>
/// Will send the command <c>Fetch.failRequest</c>
/// </remarks>
internal class FetchFailRequestRequest : IChromiumRequest<FetchFailRequestResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Fetch.failRequest";
/// <summary>
/// An id the client received in requestPaused event.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Causes the request to fail with the given reason.
/// </summary>
public Network.ErrorReason ErrorReason { get; set; }}
/// <summary>
/// Response from <see cref="FetchFailRequestRequest"/>
/// </summary>
internal class FetchFailRequestResponse : IChromiumResponse
{
}
/// <summary>
/// Provides response to the request.
/// </summary>
/// <remarks>
/// Will send the command <c>Fetch.fulfillRequest</c>
/// </remarks>
internal class FetchFulfillRequestRequest : IChromiumRequest<FetchFulfillRequestResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Fetch.fulfillRequest";
/// <summary>
/// An id the client received in requestPaused event.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// An HTTP response code.
/// </summary>
public int ResponseCode { get; set; }
/// <summary>
/// Response headers.
/// </summary>
public HeaderEntry[] ResponseHeaders { get; set; }
/// <summary>
/// Alternative way of specifying response headers as a \0-separated
/// series of name: value pairs. Prefer the above method unless you
/// need to represent some non-UTF8 values that can't be transmitted
/// over the protocol as text.
/// </summary>
public byte[] BinaryResponseHeaders { get; set; }
/// <summary>
/// A response body.
/// </summary>
public byte[] Body { get; set; }
/// <summary>
/// A textual representation of responseCode.
/// If absent, a standard phrase matching responseCode is used.
/// </summary>
public string ResponsePhrase { get; set; }}
/// <summary>
/// Response from <see cref="FetchFulfillRequestRequest"/>
/// </summary>
internal class FetchFulfillRequestResponse : IChromiumResponse
{
}
/// <summary>
/// Continues the request, optionally modifying some of its parameters.
/// </summary>
/// <remarks>
/// Will send the command <c>Fetch.continueRequest</c>
/// </remarks>
internal class FetchContinueRequestRequest : IChromiumRequest<FetchContinueRequestResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Fetch.continueRequest";
/// <summary>
/// An id the client received in requestPaused event.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// If set, the request url will be modified in a way that's not observable by page.
/// </summary>
public string Url { get; set; }
/// <summary>
/// If set, the request method is overridden.
/// </summary>
public string Method { get; set; }
/// <summary>
/// If set, overrides the post data in the request.
/// </summary>
public string PostData { get; set; }
/// <summary>
/// If set, overrides the request headrts.
/// </summary>
public HeaderEntry[] Headers { get; set; }}
/// <summary>
/// Response from <see cref="FetchContinueRequestRequest"/>
/// </summary>
internal class FetchContinueRequestResponse : IChromiumResponse
{
}
/// <summary>
/// Continues a request supplying authChallengeResponse following authRequired event.
/// </summary>
/// <remarks>
/// Will send the command <c>Fetch.continueWithAuth</c>
/// </remarks>
internal class FetchContinueWithAuthRequest : IChromiumRequest<FetchContinueWithAuthResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Fetch.continueWithAuth";
/// <summary>
/// An id the client received in authRequired event.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// Response to  with an authChallenge.
/// </summary>
public AuthChallengeResponse AuthChallengeResponse { get; set; }}
/// <summary>
/// Response from <see cref="FetchContinueWithAuthRequest"/>
/// </summary>
internal class FetchContinueWithAuthResponse : IChromiumResponse
{
}
/// <summary>
/// Causes the body of the response to be received from the server and
/// returned as a single string. May only be issued for a request that
/// is paused in the Response stage and is mutually exclusive with
/// takeResponseBodyForInterceptionAsStream. Calling other methods that
/// affect the request or disabling fetch domain before body is received
/// results in an undefined behavior.
/// </summary>
/// <remarks>
/// Will send the command <c>Fetch.getResponseBody</c>
/// </remarks>
internal class FetchGetResponseBodyRequest : IChromiumRequest<FetchGetResponseBodyResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Fetch.getResponseBody";
/// <summary>
/// Identifier for the intercepted request to get body for.
/// </summary>
public string RequestId { get; set; }}
/// <summary>
/// Response from <see cref="FetchGetResponseBodyRequest"/>
/// </summary>
internal class FetchGetResponseBodyResponse : IChromiumResponse
{
/// <summary>
/// Response body.
/// </summary>
public string Body { get; set; }
/// <summary>
/// True, if content was sent as base64.
/// </summary>
public bool Base64Encoded { get; set; }}
/// <summary>
/// Returns a handle to the stream representing the response body.
/// The request must be paused in the HeadersReceived stage.
/// Note that after this command the request can't be continued
/// as is -- client either needs to cancel it or to provide the
/// response body.
/// The stream only supports sequential read, IO.read will fail if the position
/// is specified.
/// This method is mutually exclusive with getResponseBody.
/// Calling other methods that affect the request or disabling fetch
/// domain before body is received results in an undefined behavior.
/// </summary>
/// <remarks>
/// Will send the command <c>Fetch.takeResponseBodyAsStream</c>
/// </remarks>
internal class FetchTakeResponseBodyAsStreamRequest : IChromiumRequest<FetchTakeResponseBodyAsStreamResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Fetch.takeResponseBodyAsStream";
/// <summary>
/// 
/// </summary>
public string RequestId { get; set; }}
/// <summary>
/// Response from <see cref="FetchTakeResponseBodyAsStreamRequest"/>
/// </summary>
internal class FetchTakeResponseBodyAsStreamResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public string Stream { get; set; }}
/// <summary>
/// Issued when the domain is enabled and the request URL matches the
/// specified filter. The request is paused until the client responds
/// with one of continueRequest, failRequest or fulfillRequest.
/// The stage of the request can be determined by presence of responseErrorReason
/// and responseStatusCode -- the request is at the response stage if either
/// of these fields is present and in the request stage otherwise.
/// </summary>
/// <remarks>
/// Matches on the event <c>Fetch.requestPaused</c>
/// </remarks>
internal class FetchRequestPausedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Fetch.requestPaused";
/// <summary>
/// Each request the page makes will have a unique id.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// The details of the request.
/// </summary>
public Network.Request Request { get; set; }
/// <summary>
/// The id of the frame that initiated the request.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// How the requested resource will be used.
/// </summary>
public Network.ResourceType ResourceType { get; set; }
/// <summary>
/// Response error if intercepted at response stage.
/// </summary>
public Network.ErrorReason ResponseErrorReason { get; set; }
/// <summary>
/// Response code if intercepted at response stage.
/// </summary>
public int ResponseStatusCode { get; set; }
/// <summary>
/// Response headers if intercepted at the response stage.
/// </summary>
public HeaderEntry[] ResponseHeaders { get; set; }
/// <summary>
/// If the intercepted request had a corresponding Network.requestWillBeSent event fired for it,
/// then this networkId will be the same as the requestId present in the requestWillBeSent event.
/// </summary>
public string NetworkId { get; set; }}
/// <summary>
/// Issued when the domain is enabled with handleAuthRequests set to true.
/// The request is paused until client responds with continueWithAuth.
/// </summary>
/// <remarks>
/// Matches on the event <c>Fetch.authRequired</c>
/// </remarks>
internal class FetchAuthRequiredChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Fetch.authRequired";
/// <summary>
/// Each request the page makes will have a unique id.
/// </summary>
public string RequestId { get; set; }
/// <summary>
/// The details of the request.
/// </summary>
public Network.Request Request { get; set; }
/// <summary>
/// The id of the frame that initiated the request.
/// </summary>
public string FrameId { get; set; }
/// <summary>
/// How the requested resource will be used.
/// </summary>
public Network.ResourceType ResourceType { get; set; }
/// <summary>
/// Details of the Authorization Challenge encountered.
/// If this is set, client should respond with continueRequest that
/// contains AuthChallengeResponse.
/// </summary>
public AuthChallenge AuthChallenge { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.WebAudio
{
/// <summary>
/// Enum of BaseAudioContext types
/// </summary>
internal enum ContextType
{
[System.Runtime.Serialization.EnumMember(Value = "realtime")]Realtime,
[System.Runtime.Serialization.EnumMember(Value = "offline")]Offline}
/// <summary>
/// Enum of AudioContextState from the spec
/// </summary>
internal enum ContextState
{
[System.Runtime.Serialization.EnumMember(Value = "suspended")]Suspended,
[System.Runtime.Serialization.EnumMember(Value = "running")]Running,
[System.Runtime.Serialization.EnumMember(Value = "closed")]Closed}
/// <summary>
/// Enum of AudioNode::ChannelCountMode from the spec
/// </summary>
internal enum ChannelCountMode
{
[System.Runtime.Serialization.EnumMember(Value = "clamped-max")]ClampedMax,
[System.Runtime.Serialization.EnumMember(Value = "explicit")]Explicit,
[System.Runtime.Serialization.EnumMember(Value = "max")]Max}
/// <summary>
/// Enum of AudioNode::ChannelInterpretation from the spec
/// </summary>
internal enum ChannelInterpretation
{
[System.Runtime.Serialization.EnumMember(Value = "discrete")]Discrete,
[System.Runtime.Serialization.EnumMember(Value = "speakers")]Speakers}
/// <summary>
/// Enum of AudioParam::AutomationRate from the spec
/// </summary>
internal enum AutomationRate
{
[System.Runtime.Serialization.EnumMember(Value = "a-rate")]ARate,
[System.Runtime.Serialization.EnumMember(Value = "k-rate")]KRate}
/// <summary>
/// Fields in AudioContext that change in real-time.
/// </summary>
internal class ContextRealtimeData
{
/// <summary>
/// The current context time in second in BaseAudioContext.
/// </summary>
public double CurrentTime { get; set; }
/// <summary>
/// The time spent on rendering graph divided by render qunatum duration,
/// and multiplied by 100. 100 means the audio renderer reached the full
/// capacity and glitch may occur.
/// </summary>
public double RenderCapacity { get; set; }
/// <summary>
/// A running mean of callback interval.
/// </summary>
public double CallbackIntervalMean { get; set; }
/// <summary>
/// A running variance of callback interval.
/// </summary>
public double CallbackIntervalVariance { get; set; }}
/// <summary>
/// Protocol object for BaseAudioContext
/// </summary>
internal class BaseAudioContext
{
/// <summary>
/// 
/// </summary>
public string ContextId { get; set; }
/// <summary>
/// 
/// </summary>
public ContextType ContextType { get; set; }
/// <summary>
/// 
/// </summary>
public ContextState ContextState { get; set; }
/// <summary>
/// 
/// </summary>
public ContextRealtimeData RealtimeData { get; set; }
/// <summary>
/// Platform-dependent callback buffer size.
/// </summary>
public double CallbackBufferSize { get; set; }
/// <summary>
/// Number of output channels supported by audio hardware in use.
/// </summary>
public double MaxOutputChannelCount { get; set; }
/// <summary>
/// Context sample rate.
/// </summary>
public double SampleRate { get; set; }}
/// <summary>
/// Protocol object for AudioListner
/// </summary>
internal class AudioListener
{
/// <summary>
/// 
/// </summary>
public string ListenerId { get; set; }
/// <summary>
/// 
/// </summary>
public string ContextId { get; set; }}
/// <summary>
/// Protocol object for AudioNode
/// </summary>
internal class AudioNode
{
/// <summary>
/// 
/// </summary>
public string NodeId { get; set; }
/// <summary>
/// 
/// </summary>
public string ContextId { get; set; }
/// <summary>
/// 
/// </summary>
public string NodeType { get; set; }
/// <summary>
/// 
/// </summary>
public double NumberOfInputs { get; set; }
/// <summary>
/// 
/// </summary>
public double NumberOfOutputs { get; set; }
/// <summary>
/// 
/// </summary>
public double ChannelCount { get; set; }
/// <summary>
/// 
/// </summary>
public ChannelCountMode ChannelCountMode { get; set; }
/// <summary>
/// 
/// </summary>
public ChannelInterpretation ChannelInterpretation { get; set; }}
/// <summary>
/// Protocol object for AudioParam
/// </summary>
internal class AudioParam
{
/// <summary>
/// 
/// </summary>
public string ParamId { get; set; }
/// <summary>
/// 
/// </summary>
public string NodeId { get; set; }
/// <summary>
/// 
/// </summary>
public string ContextId { get; set; }
/// <summary>
/// 
/// </summary>
public string ParamType { get; set; }
/// <summary>
/// 
/// </summary>
public AutomationRate Rate { get; set; }
/// <summary>
/// 
/// </summary>
public double DefaultValue { get; set; }
/// <summary>
/// 
/// </summary>
public double MinValue { get; set; }
/// <summary>
/// 
/// </summary>
public double MaxValue { get; set; }}
/// <summary>
/// Enables the WebAudio domain and starts sending context lifetime events.
/// </summary>
/// <remarks>
/// Will send the command <c>WebAudio.enable</c>
/// </remarks>
internal class WebAudioEnableRequest : IChromiumRequest<WebAudioEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "WebAudio.enable";
}
/// <summary>
/// Response from <see cref="WebAudioEnableRequest"/>
/// </summary>
internal class WebAudioEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Disables the WebAudio domain.
/// </summary>
/// <remarks>
/// Will send the command <c>WebAudio.disable</c>
/// </remarks>
internal class WebAudioDisableRequest : IChromiumRequest<WebAudioDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "WebAudio.disable";
}
/// <summary>
/// Response from <see cref="WebAudioDisableRequest"/>
/// </summary>
internal class WebAudioDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Fetch the realtime data from the registered contexts.
/// </summary>
/// <remarks>
/// Will send the command <c>WebAudio.getRealtimeData</c>
/// </remarks>
internal class WebAudioGetRealtimeDataRequest : IChromiumRequest<WebAudioGetRealtimeDataResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "WebAudio.getRealtimeData";
/// <summary>
/// 
/// </summary>
public string ContextId { get; set; }}
/// <summary>
/// Response from <see cref="WebAudioGetRealtimeDataRequest"/>
/// </summary>
internal class WebAudioGetRealtimeDataResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public ContextRealtimeData RealtimeData { get; set; }}
/// <summary>
/// Notifies that a new BaseAudioContext has been created.
/// </summary>
/// <remarks>
/// Matches on the event <c>WebAudio.contextCreated</c>
/// </remarks>
internal class WebAudioContextCreatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "WebAudio.contextCreated";
/// <summary>
/// 
/// </summary>
public BaseAudioContext Context { get; set; }}
/// <summary>
/// Notifies that an existing BaseAudioContext will be destroyed.
/// </summary>
/// <remarks>
/// Matches on the event <c>WebAudio.contextWillBeDestroyed</c>
/// </remarks>
internal class WebAudioContextWillBeDestroyedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "WebAudio.contextWillBeDestroyed";
/// <summary>
/// 
/// </summary>
public string ContextId { get; set; }}
/// <summary>
/// Notifies that existing BaseAudioContext has changed some properties (id stays the same)..
/// </summary>
/// <remarks>
/// Matches on the event <c>WebAudio.contextChanged</c>
/// </remarks>
internal class WebAudioContextChangedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "WebAudio.contextChanged";
/// <summary>
/// 
/// </summary>
public BaseAudioContext Context { get; set; }}
/// <summary>
/// Notifies that the construction of an AudioListener has finished.
/// </summary>
/// <remarks>
/// Matches on the event <c>WebAudio.audioListenerCreated</c>
/// </remarks>
internal class WebAudioAudioListenerCreatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "WebAudio.audioListenerCreated";
/// <summary>
/// 
/// </summary>
public AudioListener Listener { get; set; }}
/// <summary>
/// Notifies that a new AudioListener has been created.
/// </summary>
/// <remarks>
/// Matches on the event <c>WebAudio.audioListenerWillBeDestroyed</c>
/// </remarks>
internal class WebAudioAudioListenerWillBeDestroyedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "WebAudio.audioListenerWillBeDestroyed";
/// <summary>
/// 
/// </summary>
public string ContextId { get; set; }
/// <summary>
/// 
/// </summary>
public string ListenerId { get; set; }}
/// <summary>
/// Notifies that a new AudioNode has been created.
/// </summary>
/// <remarks>
/// Matches on the event <c>WebAudio.audioNodeCreated</c>
/// </remarks>
internal class WebAudioAudioNodeCreatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "WebAudio.audioNodeCreated";
/// <summary>
/// 
/// </summary>
public AudioNode Node { get; set; }}
/// <summary>
/// Notifies that an existing AudioNode has been destroyed.
/// </summary>
/// <remarks>
/// Matches on the event <c>WebAudio.audioNodeWillBeDestroyed</c>
/// </remarks>
internal class WebAudioAudioNodeWillBeDestroyedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "WebAudio.audioNodeWillBeDestroyed";
/// <summary>
/// 
/// </summary>
public string ContextId { get; set; }
/// <summary>
/// 
/// </summary>
public string NodeId { get; set; }}
/// <summary>
/// Notifies that a new AudioParam has been created.
/// </summary>
/// <remarks>
/// Matches on the event <c>WebAudio.audioParamCreated</c>
/// </remarks>
internal class WebAudioAudioParamCreatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "WebAudio.audioParamCreated";
/// <summary>
/// 
/// </summary>
public AudioParam Param { get; set; }}
/// <summary>
/// Notifies that an existing AudioParam has been destroyed.
/// </summary>
/// <remarks>
/// Matches on the event <c>WebAudio.audioParamWillBeDestroyed</c>
/// </remarks>
internal class WebAudioAudioParamWillBeDestroyedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "WebAudio.audioParamWillBeDestroyed";
/// <summary>
/// 
/// </summary>
public string ContextId { get; set; }
/// <summary>
/// 
/// </summary>
public string NodeId { get; set; }
/// <summary>
/// 
/// </summary>
public string ParamId { get; set; }}
/// <summary>
/// Notifies that two AudioNodes are connected.
/// </summary>
/// <remarks>
/// Matches on the event <c>WebAudio.nodesConnected</c>
/// </remarks>
internal class WebAudioNodesConnectedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "WebAudio.nodesConnected";
/// <summary>
/// 
/// </summary>
public string ContextId { get; set; }
/// <summary>
/// 
/// </summary>
public string SourceId { get; set; }
/// <summary>
/// 
/// </summary>
public string DestinationId { get; set; }
/// <summary>
/// 
/// </summary>
public double SourceOutputIndex { get; set; }
/// <summary>
/// 
/// </summary>
public double DestinationInputIndex { get; set; }}
/// <summary>
/// Notifies that AudioNodes are disconnected. The destination can be null, and it means all the outgoing connections from the source are disconnected.
/// </summary>
/// <remarks>
/// Matches on the event <c>WebAudio.nodesDisconnected</c>
/// </remarks>
internal class WebAudioNodesDisconnectedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "WebAudio.nodesDisconnected";
/// <summary>
/// 
/// </summary>
public string ContextId { get; set; }
/// <summary>
/// 
/// </summary>
public string SourceId { get; set; }
/// <summary>
/// 
/// </summary>
public string DestinationId { get; set; }
/// <summary>
/// 
/// </summary>
public double SourceOutputIndex { get; set; }
/// <summary>
/// 
/// </summary>
public double DestinationInputIndex { get; set; }}
/// <summary>
/// Notifies that an AudioNode is connected to an AudioParam.
/// </summary>
/// <remarks>
/// Matches on the event <c>WebAudio.nodeParamConnected</c>
/// </remarks>
internal class WebAudioNodeParamConnectedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "WebAudio.nodeParamConnected";
/// <summary>
/// 
/// </summary>
public string ContextId { get; set; }
/// <summary>
/// 
/// </summary>
public string SourceId { get; set; }
/// <summary>
/// 
/// </summary>
public string DestinationId { get; set; }
/// <summary>
/// 
/// </summary>
public double SourceOutputIndex { get; set; }}
/// <summary>
/// Notifies that an AudioNode is disconnected to an AudioParam.
/// </summary>
/// <remarks>
/// Matches on the event <c>WebAudio.nodeParamDisconnected</c>
/// </remarks>
internal class WebAudioNodeParamDisconnectedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "WebAudio.nodeParamDisconnected";
/// <summary>
/// 
/// </summary>
public string ContextId { get; set; }
/// <summary>
/// 
/// </summary>
public string SourceId { get; set; }
/// <summary>
/// 
/// </summary>
public string DestinationId { get; set; }
/// <summary>
/// 
/// </summary>
public double SourceOutputIndex { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.WebAuthn
{
/// <summary>
/// 
/// </summary>
internal enum AuthenticatorProtocol
{
[System.Runtime.Serialization.EnumMember(Value = "u2f")]U2F,
[System.Runtime.Serialization.EnumMember(Value = "ctap2")]Ctap2}
/// <summary>
/// 
/// </summary>
internal enum AuthenticatorTransport
{
[System.Runtime.Serialization.EnumMember(Value = "usb")]Usb,
[System.Runtime.Serialization.EnumMember(Value = "nfc")]Nfc,
[System.Runtime.Serialization.EnumMember(Value = "ble")]Ble,
[System.Runtime.Serialization.EnumMember(Value = "cable")]Cable,
[System.Runtime.Serialization.EnumMember(Value = "internal")]Internal}
/// <summary>
/// 
/// </summary>
internal class VirtualAuthenticatorOptions
{
/// <summary>
/// 
/// </summary>
public AuthenticatorProtocol Protocol { get; set; }
/// <summary>
/// 
/// </summary>
public AuthenticatorTransport Transport { get; set; }
/// <summary>
/// Defaults to false.
/// </summary>
public bool HasResidentKey { get; set; }
/// <summary>
/// Defaults to false.
/// </summary>
public bool HasUserVerification { get; set; }
/// <summary>
/// If set to true, tests of user presence will succeed immediately.
/// Otherwise, they will not be resolved. Defaults to true.
/// </summary>
public bool AutomaticPresenceSimulation { get; set; }
/// <summary>
/// Sets whether User Verification succeeds or fails for an authenticator.
/// Defaults to false.
/// </summary>
public bool IsUserVerified { get; set; }}
/// <summary>
/// 
/// </summary>
internal class Credential
{
/// <summary>
/// 
/// </summary>
public byte[] CredentialId { get; set; }
/// <summary>
/// 
/// </summary>
public bool IsResidentCredential { get; set; }
/// <summary>
/// Relying Party ID the credential is scoped to. Must be set when adding a
/// credential.
/// </summary>
public string RpId { get; set; }
/// <summary>
/// The ECDSA P-256 private key in PKCS#8 format.
/// </summary>
public byte[] PrivateKey { get; set; }
/// <summary>
/// An opaque byte sequence with a maximum size of 64 bytes mapping the
/// credential to a specific user.
/// </summary>
public byte[] UserHandle { get; set; }
/// <summary>
/// Signature counter. This is incremented by one for each successful
/// assertion.
/// See https://w3c.github.io/webauthn/#signature-counter
/// </summary>
public int SignCount { get; set; }}
/// <summary>
/// Enable the WebAuthn domain and start intercepting credential storage and
/// retrieval with a virtual authenticator.
/// </summary>
/// <remarks>
/// Will send the command <c>WebAuthn.enable</c>
/// </remarks>
internal class WebAuthnEnableRequest : IChromiumRequest<WebAuthnEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "WebAuthn.enable";
}
/// <summary>
/// Response from <see cref="WebAuthnEnableRequest"/>
/// </summary>
internal class WebAuthnEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Disable the WebAuthn domain.
/// </summary>
/// <remarks>
/// Will send the command <c>WebAuthn.disable</c>
/// </remarks>
internal class WebAuthnDisableRequest : IChromiumRequest<WebAuthnDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "WebAuthn.disable";
}
/// <summary>
/// Response from <see cref="WebAuthnDisableRequest"/>
/// </summary>
internal class WebAuthnDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Creates and adds a virtual authenticator.
/// </summary>
/// <remarks>
/// Will send the command <c>WebAuthn.addVirtualAuthenticator</c>
/// </remarks>
internal class WebAuthnAddVirtualAuthenticatorRequest : IChromiumRequest<WebAuthnAddVirtualAuthenticatorResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "WebAuthn.addVirtualAuthenticator";
/// <summary>
/// 
/// </summary>
public VirtualAuthenticatorOptions Options { get; set; }}
/// <summary>
/// Response from <see cref="WebAuthnAddVirtualAuthenticatorRequest"/>
/// </summary>
internal class WebAuthnAddVirtualAuthenticatorResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public string AuthenticatorId { get; set; }}
/// <summary>
/// Removes the given authenticator.
/// </summary>
/// <remarks>
/// Will send the command <c>WebAuthn.removeVirtualAuthenticator</c>
/// </remarks>
internal class WebAuthnRemoveVirtualAuthenticatorRequest : IChromiumRequest<WebAuthnRemoveVirtualAuthenticatorResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "WebAuthn.removeVirtualAuthenticator";
/// <summary>
/// 
/// </summary>
public string AuthenticatorId { get; set; }}
/// <summary>
/// Response from <see cref="WebAuthnRemoveVirtualAuthenticatorRequest"/>
/// </summary>
internal class WebAuthnRemoveVirtualAuthenticatorResponse : IChromiumResponse
{
}
/// <summary>
/// Adds the credential to the specified authenticator.
/// </summary>
/// <remarks>
/// Will send the command <c>WebAuthn.addCredential</c>
/// </remarks>
internal class WebAuthnAddCredentialRequest : IChromiumRequest<WebAuthnAddCredentialResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "WebAuthn.addCredential";
/// <summary>
/// 
/// </summary>
public string AuthenticatorId { get; set; }
/// <summary>
/// 
/// </summary>
public Credential Credential { get; set; }}
/// <summary>
/// Response from <see cref="WebAuthnAddCredentialRequest"/>
/// </summary>
internal class WebAuthnAddCredentialResponse : IChromiumResponse
{
}
/// <summary>
/// Returns a single credential stored in the given virtual authenticator that
/// matches the credential ID.
/// </summary>
/// <remarks>
/// Will send the command <c>WebAuthn.getCredential</c>
/// </remarks>
internal class WebAuthnGetCredentialRequest : IChromiumRequest<WebAuthnGetCredentialResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "WebAuthn.getCredential";
/// <summary>
/// 
/// </summary>
public string AuthenticatorId { get; set; }
/// <summary>
/// 
/// </summary>
public byte[] CredentialId { get; set; }}
/// <summary>
/// Response from <see cref="WebAuthnGetCredentialRequest"/>
/// </summary>
internal class WebAuthnGetCredentialResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public Credential Credential { get; set; }}
/// <summary>
/// Returns all the credentials stored in the given virtual authenticator.
/// </summary>
/// <remarks>
/// Will send the command <c>WebAuthn.getCredentials</c>
/// </remarks>
internal class WebAuthnGetCredentialsRequest : IChromiumRequest<WebAuthnGetCredentialsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "WebAuthn.getCredentials";
/// <summary>
/// 
/// </summary>
public string AuthenticatorId { get; set; }}
/// <summary>
/// Response from <see cref="WebAuthnGetCredentialsRequest"/>
/// </summary>
internal class WebAuthnGetCredentialsResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public Credential[] Credentials { get; set; }}
/// <summary>
/// Removes a credential from the authenticator.
/// </summary>
/// <remarks>
/// Will send the command <c>WebAuthn.removeCredential</c>
/// </remarks>
internal class WebAuthnRemoveCredentialRequest : IChromiumRequest<WebAuthnRemoveCredentialResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "WebAuthn.removeCredential";
/// <summary>
/// 
/// </summary>
public string AuthenticatorId { get; set; }
/// <summary>
/// 
/// </summary>
public byte[] CredentialId { get; set; }}
/// <summary>
/// Response from <see cref="WebAuthnRemoveCredentialRequest"/>
/// </summary>
internal class WebAuthnRemoveCredentialResponse : IChromiumResponse
{
}
/// <summary>
/// Clears all the credentials from the specified device.
/// </summary>
/// <remarks>
/// Will send the command <c>WebAuthn.clearCredentials</c>
/// </remarks>
internal class WebAuthnClearCredentialsRequest : IChromiumRequest<WebAuthnClearCredentialsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "WebAuthn.clearCredentials";
/// <summary>
/// 
/// </summary>
public string AuthenticatorId { get; set; }}
/// <summary>
/// Response from <see cref="WebAuthnClearCredentialsRequest"/>
/// </summary>
internal class WebAuthnClearCredentialsResponse : IChromiumResponse
{
}
/// <summary>
/// Sets whether User Verification succeeds or fails for an authenticator.
/// The default is true.
/// </summary>
/// <remarks>
/// Will send the command <c>WebAuthn.setUserVerified</c>
/// </remarks>
internal class WebAuthnSetUserVerifiedRequest : IChromiumRequest<WebAuthnSetUserVerifiedResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "WebAuthn.setUserVerified";
/// <summary>
/// 
/// </summary>
public string AuthenticatorId { get; set; }
/// <summary>
/// 
/// </summary>
public bool IsUserVerified { get; set; }}
/// <summary>
/// Response from <see cref="WebAuthnSetUserVerifiedRequest"/>
/// </summary>
internal class WebAuthnSetUserVerifiedResponse : IChromiumResponse
{
}
}
namespace PlaywrightSharp.Chromium.Protocol.Media
{
/// <summary>
/// Player Property type
/// </summary>
internal class PlayerProperty
{
/// <summary>
/// 
/// </summary>
public string Name { get; set; }
/// <summary>
/// 
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Break out events into different types
/// </summary>
internal enum PlayerEventType
{
[System.Runtime.Serialization.EnumMember(Value = "playbackEvent")]PlaybackEvent,
[System.Runtime.Serialization.EnumMember(Value = "systemEvent")]SystemEvent,
[System.Runtime.Serialization.EnumMember(Value = "messageEvent")]MessageEvent}
/// <summary>
/// 
/// </summary>
internal class PlayerEvent
{
/// <summary>
/// 
/// </summary>
public PlayerEventType Type { get; set; }
/// <summary>
/// Events are timestamped relative to the start of the player creation
/// not relative to the start of playback.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// 
/// </summary>
public string Name { get; set; }
/// <summary>
/// 
/// </summary>
public string Value { get; set; }}
/// <summary>
/// Enables the Media domain
/// </summary>
/// <remarks>
/// Will send the command <c>Media.enable</c>
/// </remarks>
internal class MediaEnableRequest : IChromiumRequest<MediaEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Media.enable";
}
/// <summary>
/// Response from <see cref="MediaEnableRequest"/>
/// </summary>
internal class MediaEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Disables the Media domain.
/// </summary>
/// <remarks>
/// Will send the command <c>Media.disable</c>
/// </remarks>
internal class MediaDisableRequest : IChromiumRequest<MediaDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Media.disable";
}
/// <summary>
/// Response from <see cref="MediaDisableRequest"/>
/// </summary>
internal class MediaDisableResponse : IChromiumResponse
{
}
/// <summary>
/// This can be called multiple times, and can be used to set / override /
/// remove player properties. A null propValue indicates removal.
/// </summary>
/// <remarks>
/// Matches on the event <c>Media.playerPropertiesChanged</c>
/// </remarks>
internal class MediaPlayerPropertiesChangedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Media.playerPropertiesChanged";
/// <summary>
/// 
/// </summary>
public string PlayerId { get; set; }
/// <summary>
/// 
/// </summary>
public PlayerProperty[] Properties { get; set; }}
/// <summary>
/// Send events as a list, allowing them to be batched on the browser for less
/// congestion. If batched, events must ALWAYS be in chronological order.
/// </summary>
/// <remarks>
/// Matches on the event <c>Media.playerEventsAdded</c>
/// </remarks>
internal class MediaPlayerEventsAddedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Media.playerEventsAdded";
/// <summary>
/// 
/// </summary>
public string PlayerId { get; set; }
/// <summary>
/// 
/// </summary>
public PlayerEvent[] Events { get; set; }}
/// <summary>
/// Called whenever a player is created, or when a new agent joins and recieves
/// a list of active players. If an agent is restored, it will recieve the full
/// list of player ids and all events again.
/// </summary>
/// <remarks>
/// Matches on the event <c>Media.playersCreated</c>
/// </remarks>
internal class MediaPlayersCreatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Media.playersCreated";
/// <summary>
/// 
/// </summary>
public string[] Players { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Console
{
/// <summary>
/// Console message.
/// </summary>
internal class ConsoleMessage
{
/// <summary>
/// Message source.
/// </summary>
public string Source { get; set; }
/// <summary>
/// Message severity.
/// </summary>
public string Level { get; set; }
/// <summary>
/// Message text.
/// </summary>
public string Text { get; set; }
/// <summary>
/// URL of the message origin.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Line number in the resource that generated this message (1-based).
/// </summary>
public int Line { get; set; }
/// <summary>
/// Column number in the resource that generated this message (1-based).
/// </summary>
public int Column { get; set; }}
/// <summary>
/// Does nothing.
/// </summary>
/// <remarks>
/// Will send the command <c>Console.clearMessages</c>
/// </remarks>
internal class ConsoleClearMessagesRequest : IChromiumRequest<ConsoleClearMessagesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Console.clearMessages";
}
/// <summary>
/// Response from <see cref="ConsoleClearMessagesRequest"/>
/// </summary>
internal class ConsoleClearMessagesResponse : IChromiumResponse
{
}
/// <summary>
/// Disables console domain, prevents further console messages from being reported to the client.
/// </summary>
/// <remarks>
/// Will send the command <c>Console.disable</c>
/// </remarks>
internal class ConsoleDisableRequest : IChromiumRequest<ConsoleDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Console.disable";
}
/// <summary>
/// Response from <see cref="ConsoleDisableRequest"/>
/// </summary>
internal class ConsoleDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables console domain, sends the messages collected so far to the client by means of the
/// `messageAdded` notification.
/// </summary>
/// <remarks>
/// Will send the command <c>Console.enable</c>
/// </remarks>
internal class ConsoleEnableRequest : IChromiumRequest<ConsoleEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Console.enable";
}
/// <summary>
/// Response from <see cref="ConsoleEnableRequest"/>
/// </summary>
internal class ConsoleEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Issued when new console message is added.
/// </summary>
/// <remarks>
/// Matches on the event <c>Console.messageAdded</c>
/// </remarks>
internal class ConsoleMessageAddedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Console.messageAdded";
/// <summary>
/// Console message that has been added.
/// </summary>
public ConsoleMessage Message { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Debugger
{
/// <summary>
/// Location in the source code.
/// </summary>
internal class Location
{
/// <summary>
/// Script identifier as reported in the `Debugger.scriptParsed`.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// Line number in the script (0-based).
/// </summary>
public int LineNumber { get; set; }
/// <summary>
/// Column number in the script (0-based).
/// </summary>
public int ColumnNumber { get; set; }}
/// <summary>
/// Location in the source code.
/// </summary>
internal class ScriptPosition
{
/// <summary>
/// 
/// </summary>
public int LineNumber { get; set; }
/// <summary>
/// 
/// </summary>
public int ColumnNumber { get; set; }}
/// <summary>
/// JavaScript call frame. Array of call frames form the call stack.
/// </summary>
internal class CallFrame
{
/// <summary>
/// Call frame identifier. This identifier is only valid while the virtual machine is paused.
/// </summary>
public string CallFrameId { get; set; }
/// <summary>
/// Name of the JavaScript function called on this call frame.
/// </summary>
public string FunctionName { get; set; }
/// <summary>
/// Location in the source code.
/// </summary>
public Location FunctionLocation { get; set; }
/// <summary>
/// Location in the source code.
/// </summary>
public Location Location { get; set; }
/// <summary>
/// JavaScript script name or url.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Scope chain for this call frame.
/// </summary>
public Scope[] ScopeChain { get; set; }
/// <summary>
/// `this` object for this call frame.
/// </summary>
public Runtime.RemoteObject This { get; set; }
/// <summary>
/// The value being returned, if the function is at return point.
/// </summary>
public Runtime.RemoteObject ReturnValue { get; set; }}
/// <summary>
/// Scope description.
/// </summary>
internal class Scope
{
/// <summary>
/// Scope type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Object representing the scope. For `global` and `with` scopes it represents the actual
/// object; for the rest of the scopes, it is artificial transient object enumerating scope
/// variables as its properties.
/// </summary>
public Runtime.RemoteObject Object { get; set; }
/// <summary>
/// 
/// </summary>
public string Name { get; set; }
/// <summary>
/// Location in the source code where scope starts
/// </summary>
public Location StartLocation { get; set; }
/// <summary>
/// Location in the source code where scope ends
/// </summary>
public Location EndLocation { get; set; }}
/// <summary>
/// Search match for resource.
/// </summary>
internal class SearchMatch
{
/// <summary>
/// Line number in resource content.
/// </summary>
public double LineNumber { get; set; }
/// <summary>
/// Line with match content.
/// </summary>
public string LineContent { get; set; }}
/// <summary>
/// 
/// </summary>
internal class BreakLocation
{
/// <summary>
/// Script identifier as reported in the `Debugger.scriptParsed`.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// Line number in the script (0-based).
/// </summary>
public int LineNumber { get; set; }
/// <summary>
/// Column number in the script (0-based).
/// </summary>
public int ColumnNumber { get; set; }
/// <summary>
/// 
/// </summary>
public string Type { get; set; }}
/// <summary>
/// Continues execution until specific location is reached.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.continueToLocation</c>
/// </remarks>
internal class DebuggerContinueToLocationRequest : IChromiumRequest<DebuggerContinueToLocationResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.continueToLocation";
/// <summary>
/// Location to continue to.
/// </summary>
public Location Location { get; set; }
/// <summary>
/// 
/// </summary>
public string TargetCallFrames { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerContinueToLocationRequest"/>
/// </summary>
internal class DebuggerContinueToLocationResponse : IChromiumResponse
{
}
/// <summary>
/// Disables debugger for given page.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.disable</c>
/// </remarks>
internal class DebuggerDisableRequest : IChromiumRequest<DebuggerDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.disable";
}
/// <summary>
/// Response from <see cref="DebuggerDisableRequest"/>
/// </summary>
internal class DebuggerDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Enables debugger for the given page. Clients should not assume that the debugging has been
/// enabled until the result for this command is received.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.enable</c>
/// </remarks>
internal class DebuggerEnableRequest : IChromiumRequest<DebuggerEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.enable";
/// <summary>
/// The maximum size in bytes of collected scripts (not referenced by other heap objects)
/// the debugger can hold. Puts no limit if paramter is omitted.
/// </summary>
public double MaxScriptsCacheSize { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerEnableRequest"/>
/// </summary>
internal class DebuggerEnableResponse : IChromiumResponse
{
/// <summary>
/// Unique identifier of the debugger.
/// </summary>
public string DebuggerId { get; set; }}
/// <summary>
/// Evaluates expression on a given call frame.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.evaluateOnCallFrame</c>
/// </remarks>
internal class DebuggerEvaluateOnCallFrameRequest : IChromiumRequest<DebuggerEvaluateOnCallFrameResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.evaluateOnCallFrame";
/// <summary>
/// Call frame identifier to evaluate on.
/// </summary>
public string CallFrameId { get; set; }
/// <summary>
/// Expression to evaluate.
/// </summary>
public string Expression { get; set; }
/// <summary>
/// String object group name to put result into (allows rapid releasing resulting object handles
/// using `releaseObjectGroup`).
/// </summary>
public string ObjectGroup { get; set; }
/// <summary>
/// Specifies whether command line API should be available to the evaluated expression, defaults
/// to false.
/// </summary>
public bool IncludeCommandLineAPI { get; set; }
/// <summary>
/// In silent mode exceptions thrown during evaluation are not reported and do not pause
/// execution. Overrides `setPauseOnException` state.
/// </summary>
public bool Silent { get; set; }
/// <summary>
/// Whether the result is expected to be a JSON object that should be sent by value.
/// </summary>
public bool ReturnByValue { get; set; }
/// <summary>
/// Whether preview should be generated for the result.
/// </summary>
public bool GeneratePreview { get; set; }
/// <summary>
/// Whether to throw an exception if side effect cannot be ruled out during evaluation.
/// </summary>
public bool ThrowOnSideEffect { get; set; }
/// <summary>
/// Terminate execution after timing out (number of milliseconds).
/// </summary>
public double Timeout { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerEvaluateOnCallFrameRequest"/>
/// </summary>
internal class DebuggerEvaluateOnCallFrameResponse : IChromiumResponse
{
/// <summary>
/// Object wrapper for the evaluation result.
/// </summary>
public Runtime.RemoteObject Result { get; set; }
/// <summary>
/// Exception details.
/// </summary>
public Runtime.ExceptionDetails ExceptionDetails { get; set; }}
/// <summary>
/// Returns possible locations for breakpoint. scriptId in start and end range locations should be
/// the same.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.getPossibleBreakpoints</c>
/// </remarks>
internal class DebuggerGetPossibleBreakpointsRequest : IChromiumRequest<DebuggerGetPossibleBreakpointsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.getPossibleBreakpoints";
/// <summary>
/// Start of range to search possible breakpoint locations in.
/// </summary>
public Location Start { get; set; }
/// <summary>
/// End of range to search possible breakpoint locations in (excluding). When not specified, end
/// of scripts is used as end of range.
/// </summary>
public Location End { get; set; }
/// <summary>
/// Only consider locations which are in the same (non-nested) function as start.
/// </summary>
public bool RestrictToFunction { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerGetPossibleBreakpointsRequest"/>
/// </summary>
internal class DebuggerGetPossibleBreakpointsResponse : IChromiumResponse
{
/// <summary>
/// List of the possible breakpoint locations.
/// </summary>
public BreakLocation[] Locations { get; set; }}
/// <summary>
/// Returns source for the script with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.getScriptSource</c>
/// </remarks>
internal class DebuggerGetScriptSourceRequest : IChromiumRequest<DebuggerGetScriptSourceResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.getScriptSource";
/// <summary>
/// Id of the script to get source for.
/// </summary>
public string ScriptId { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerGetScriptSourceRequest"/>
/// </summary>
internal class DebuggerGetScriptSourceResponse : IChromiumResponse
{
/// <summary>
/// Script source (empty in case of Wasm bytecode).
/// </summary>
public string ScriptSource { get; set; }
/// <summary>
/// Wasm bytecode.
/// </summary>
public byte[] Bytecode { get; set; }}
/// <summary>
/// This command is deprecated. Use getScriptSource instead.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.getWasmBytecode</c>
/// </remarks>
internal class DebuggerGetWasmBytecodeRequest : IChromiumRequest<DebuggerGetWasmBytecodeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.getWasmBytecode";
/// <summary>
/// Id of the Wasm script to get source for.
/// </summary>
public string ScriptId { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerGetWasmBytecodeRequest"/>
/// </summary>
internal class DebuggerGetWasmBytecodeResponse : IChromiumResponse
{
/// <summary>
/// Script source.
/// </summary>
public byte[] Bytecode { get; set; }}
/// <summary>
/// Returns stack trace with given `stackTraceId`.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.getStackTrace</c>
/// </remarks>
internal class DebuggerGetStackTraceRequest : IChromiumRequest<DebuggerGetStackTraceResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.getStackTrace";
/// <summary>
/// 
/// </summary>
public Runtime.StackTraceId StackTraceId { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerGetStackTraceRequest"/>
/// </summary>
internal class DebuggerGetStackTraceResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public Runtime.StackTrace StackTrace { get; set; }}
/// <summary>
/// Stops on the next JavaScript statement.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.pause</c>
/// </remarks>
internal class DebuggerPauseRequest : IChromiumRequest<DebuggerPauseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.pause";
}
/// <summary>
/// Response from <see cref="DebuggerPauseRequest"/>
/// </summary>
internal class DebuggerPauseResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.pauseOnAsyncCall</c>
/// </remarks>
internal class DebuggerPauseOnAsyncCallRequest : IChromiumRequest<DebuggerPauseOnAsyncCallResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.pauseOnAsyncCall";
/// <summary>
/// Debugger will pause when async call with given stack trace is started.
/// </summary>
public Runtime.StackTraceId ParentStackTraceId { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerPauseOnAsyncCallRequest"/>
/// </summary>
internal class DebuggerPauseOnAsyncCallResponse : IChromiumResponse
{
}
/// <summary>
/// Removes JavaScript breakpoint.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.removeBreakpoint</c>
/// </remarks>
internal class DebuggerRemoveBreakpointRequest : IChromiumRequest<DebuggerRemoveBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.removeBreakpoint";
/// <summary>
/// 
/// </summary>
public string BreakpointId { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerRemoveBreakpointRequest"/>
/// </summary>
internal class DebuggerRemoveBreakpointResponse : IChromiumResponse
{
}
/// <summary>
/// Restarts particular call frame from the beginning.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.restartFrame</c>
/// </remarks>
internal class DebuggerRestartFrameRequest : IChromiumRequest<DebuggerRestartFrameResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.restartFrame";
/// <summary>
/// Call frame identifier to evaluate on.
/// </summary>
public string CallFrameId { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerRestartFrameRequest"/>
/// </summary>
internal class DebuggerRestartFrameResponse : IChromiumResponse
{
/// <summary>
/// New stack trace.
/// </summary>
public CallFrame[] CallFrames { get; set; }
/// <summary>
/// Async stack trace, if any.
/// </summary>
public Runtime.StackTrace AsyncStackTrace { get; set; }
/// <summary>
/// Async stack trace, if any.
/// </summary>
public Runtime.StackTraceId AsyncStackTraceId { get; set; }}
/// <summary>
/// Resumes JavaScript execution.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.resume</c>
/// </remarks>
internal class DebuggerResumeRequest : IChromiumRequest<DebuggerResumeResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.resume";
}
/// <summary>
/// Response from <see cref="DebuggerResumeRequest"/>
/// </summary>
internal class DebuggerResumeResponse : IChromiumResponse
{
}
/// <summary>
/// Searches for given string in script content.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.searchInContent</c>
/// </remarks>
internal class DebuggerSearchInContentRequest : IChromiumRequest<DebuggerSearchInContentResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.searchInContent";
/// <summary>
/// Id of the script to search in.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// String to search for.
/// </summary>
public string Query { get; set; }
/// <summary>
/// If true, search is case sensitive.
/// </summary>
public bool CaseSensitive { get; set; }
/// <summary>
/// If true, treats string parameter as regex.
/// </summary>
public bool IsRegex { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSearchInContentRequest"/>
/// </summary>
internal class DebuggerSearchInContentResponse : IChromiumResponse
{
/// <summary>
/// List of search matches.
/// </summary>
public SearchMatch[] Result { get; set; }}
/// <summary>
/// Enables or disables async call stacks tracking.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setAsyncCallStackDepth</c>
/// </remarks>
internal class DebuggerSetAsyncCallStackDepthRequest : IChromiumRequest<DebuggerSetAsyncCallStackDepthResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setAsyncCallStackDepth";
/// <summary>
/// Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
/// call stacks (default).
/// </summary>
public int MaxDepth { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetAsyncCallStackDepthRequest"/>
/// </summary>
internal class DebuggerSetAsyncCallStackDepthResponse : IChromiumResponse
{
}
/// <summary>
/// Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
/// scripts with url matching one of the patterns. VM will try to leave blackboxed script by
/// performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setBlackboxPatterns</c>
/// </remarks>
internal class DebuggerSetBlackboxPatternsRequest : IChromiumRequest<DebuggerSetBlackboxPatternsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setBlackboxPatterns";
/// <summary>
/// Array of regexps that will be used to check script url for blackbox state.
/// </summary>
public string[] Patterns { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetBlackboxPatternsRequest"/>
/// </summary>
internal class DebuggerSetBlackboxPatternsResponse : IChromiumResponse
{
}
/// <summary>
/// Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
/// scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
/// Positions array contains positions where blackbox state is changed. First interval isn't
/// blackboxed. Array should be sorted.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setBlackboxedRanges</c>
/// </remarks>
internal class DebuggerSetBlackboxedRangesRequest : IChromiumRequest<DebuggerSetBlackboxedRangesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setBlackboxedRanges";
/// <summary>
/// Id of the script.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// 
/// </summary>
public ScriptPosition[] Positions { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetBlackboxedRangesRequest"/>
/// </summary>
internal class DebuggerSetBlackboxedRangesResponse : IChromiumResponse
{
}
/// <summary>
/// Sets JavaScript breakpoint at a given location.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setBreakpoint</c>
/// </remarks>
internal class DebuggerSetBreakpointRequest : IChromiumRequest<DebuggerSetBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setBreakpoint";
/// <summary>
/// Location to set breakpoint in.
/// </summary>
public Location Location { get; set; }
/// <summary>
/// Expression to use as a breakpoint condition. When specified, debugger will only stop on the
/// breakpoint if this expression evaluates to true.
/// </summary>
public string Condition { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetBreakpointRequest"/>
/// </summary>
internal class DebuggerSetBreakpointResponse : IChromiumResponse
{
/// <summary>
/// Id of the created breakpoint for further reference.
/// </summary>
public string BreakpointId { get; set; }
/// <summary>
/// Location this breakpoint resolved into.
/// </summary>
public Location ActualLocation { get; set; }}
/// <summary>
/// Sets instrumentation breakpoint.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setInstrumentationBreakpoint</c>
/// </remarks>
internal class DebuggerSetInstrumentationBreakpointRequest : IChromiumRequest<DebuggerSetInstrumentationBreakpointResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setInstrumentationBreakpoint";
/// <summary>
/// Instrumentation name.
/// </summary>
public string Instrumentation { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetInstrumentationBreakpointRequest"/>
/// </summary>
internal class DebuggerSetInstrumentationBreakpointResponse : IChromiumResponse
{
/// <summary>
/// Id of the created breakpoint for further reference.
/// </summary>
public string BreakpointId { get; set; }}
/// <summary>
/// Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
/// command is issued, all existing parsed scripts will have breakpoints resolved and returned in
/// `locations` property. Further matching script parsing will result in subsequent
/// `breakpointResolved` events issued. This logical breakpoint will survive page reloads.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setBreakpointByUrl</c>
/// </remarks>
internal class DebuggerSetBreakpointByUrlRequest : IChromiumRequest<DebuggerSetBreakpointByUrlResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setBreakpointByUrl";
/// <summary>
/// Line number to set breakpoint at.
/// </summary>
public int LineNumber { get; set; }
/// <summary>
/// URL of the resources to set breakpoint on.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or
/// `urlRegex` must be specified.
/// </summary>
public string UrlRegex { get; set; }
/// <summary>
/// Script hash of the resources to set breakpoint on.
/// </summary>
public string ScriptHash { get; set; }
/// <summary>
/// Offset in the line to set breakpoint at.
/// </summary>
public int ColumnNumber { get; set; }
/// <summary>
/// Expression to use as a breakpoint condition. When specified, debugger will only stop on the
/// breakpoint if this expression evaluates to true.
/// </summary>
public string Condition { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetBreakpointByUrlRequest"/>
/// </summary>
internal class DebuggerSetBreakpointByUrlResponse : IChromiumResponse
{
/// <summary>
/// Id of the created breakpoint for further reference.
/// </summary>
public string BreakpointId { get; set; }
/// <summary>
/// List of the locations this breakpoint resolved into upon addition.
/// </summary>
public Location[] Locations { get; set; }}
/// <summary>
/// Sets JavaScript breakpoint before each call to the given function.
/// If another function was created from the same source as a given one,
/// calling it will also trigger the breakpoint.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setBreakpointOnFunctionCall</c>
/// </remarks>
internal class DebuggerSetBreakpointOnFunctionCallRequest : IChromiumRequest<DebuggerSetBreakpointOnFunctionCallResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setBreakpointOnFunctionCall";
/// <summary>
/// Function object id.
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// Expression to use as a breakpoint condition. When specified, debugger will
/// stop on the breakpoint if this expression evaluates to true.
/// </summary>
public string Condition { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetBreakpointOnFunctionCallRequest"/>
/// </summary>
internal class DebuggerSetBreakpointOnFunctionCallResponse : IChromiumResponse
{
/// <summary>
/// Id of the created breakpoint for further reference.
/// </summary>
public string BreakpointId { get; set; }}
/// <summary>
/// Activates / deactivates all breakpoints on the page.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setBreakpointsActive</c>
/// </remarks>
internal class DebuggerSetBreakpointsActiveRequest : IChromiumRequest<DebuggerSetBreakpointsActiveResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setBreakpointsActive";
/// <summary>
/// New value for breakpoints active state.
/// </summary>
public bool Active { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetBreakpointsActiveRequest"/>
/// </summary>
internal class DebuggerSetBreakpointsActiveResponse : IChromiumResponse
{
}
/// <summary>
/// Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or
/// no exceptions. Initial pause on exceptions state is `none`.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setPauseOnExceptions</c>
/// </remarks>
internal class DebuggerSetPauseOnExceptionsRequest : IChromiumRequest<DebuggerSetPauseOnExceptionsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setPauseOnExceptions";
/// <summary>
/// Pause on exceptions mode.
/// </summary>
public string State { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetPauseOnExceptionsRequest"/>
/// </summary>
internal class DebuggerSetPauseOnExceptionsResponse : IChromiumResponse
{
}
/// <summary>
/// Changes return value in top frame. Available only at return break position.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setReturnValue</c>
/// </remarks>
internal class DebuggerSetReturnValueRequest : IChromiumRequest<DebuggerSetReturnValueResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setReturnValue";
/// <summary>
/// New return value.
/// </summary>
public Runtime.CallArgument NewValue { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetReturnValueRequest"/>
/// </summary>
internal class DebuggerSetReturnValueResponse : IChromiumResponse
{
}
/// <summary>
/// Edits JavaScript source live.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setScriptSource</c>
/// </remarks>
internal class DebuggerSetScriptSourceRequest : IChromiumRequest<DebuggerSetScriptSourceResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setScriptSource";
/// <summary>
/// Id of the script to edit.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// New content of the script.
/// </summary>
public string ScriptSource { get; set; }
/// <summary>
/// If true the change will not actually be applied. Dry run may be used to get result
/// description without actually modifying the code.
/// </summary>
public bool DryRun { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetScriptSourceRequest"/>
/// </summary>
internal class DebuggerSetScriptSourceResponse : IChromiumResponse
{
/// <summary>
/// New stack trace in case editing has happened while VM was stopped.
/// </summary>
public CallFrame[] CallFrames { get; set; }
/// <summary>
/// Whether current call stack  was modified after applying the changes.
/// </summary>
public bool StackChanged { get; set; }
/// <summary>
/// Async stack trace, if any.
/// </summary>
public Runtime.StackTrace AsyncStackTrace { get; set; }
/// <summary>
/// Async stack trace, if any.
/// </summary>
public Runtime.StackTraceId AsyncStackTraceId { get; set; }
/// <summary>
/// Exception details if any.
/// </summary>
public Runtime.ExceptionDetails ExceptionDetails { get; set; }}
/// <summary>
/// Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setSkipAllPauses</c>
/// </remarks>
internal class DebuggerSetSkipAllPausesRequest : IChromiumRequest<DebuggerSetSkipAllPausesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setSkipAllPauses";
/// <summary>
/// New value for skip pauses state.
/// </summary>
public bool Skip { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetSkipAllPausesRequest"/>
/// </summary>
internal class DebuggerSetSkipAllPausesResponse : IChromiumResponse
{
}
/// <summary>
/// Changes value of variable in a callframe. Object-based scopes are not supported and must be
/// mutated manually.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.setVariableValue</c>
/// </remarks>
internal class DebuggerSetVariableValueRequest : IChromiumRequest<DebuggerSetVariableValueResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.setVariableValue";
/// <summary>
/// 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch'
/// scope types are allowed. Other scopes could be manipulated manually.
/// </summary>
public int ScopeNumber { get; set; }
/// <summary>
/// Variable name.
/// </summary>
public string VariableName { get; set; }
/// <summary>
/// New variable value.
/// </summary>
public Runtime.CallArgument NewValue { get; set; }
/// <summary>
/// Id of callframe that holds variable.
/// </summary>
public string CallFrameId { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerSetVariableValueRequest"/>
/// </summary>
internal class DebuggerSetVariableValueResponse : IChromiumResponse
{
}
/// <summary>
/// Steps into the function call.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.stepInto</c>
/// </remarks>
internal class DebuggerStepIntoRequest : IChromiumRequest<DebuggerStepIntoResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.stepInto";
/// <summary>
/// Debugger will pause on the execution of the first async task which was scheduled
/// before next pause.
/// </summary>
public bool BreakOnAsyncCall { get; set; }}
/// <summary>
/// Response from <see cref="DebuggerStepIntoRequest"/>
/// </summary>
internal class DebuggerStepIntoResponse : IChromiumResponse
{
}
/// <summary>
/// Steps out of the function call.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.stepOut</c>
/// </remarks>
internal class DebuggerStepOutRequest : IChromiumRequest<DebuggerStepOutResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.stepOut";
}
/// <summary>
/// Response from <see cref="DebuggerStepOutRequest"/>
/// </summary>
internal class DebuggerStepOutResponse : IChromiumResponse
{
}
/// <summary>
/// Steps over the statement.
/// </summary>
/// <remarks>
/// Will send the command <c>Debugger.stepOver</c>
/// </remarks>
internal class DebuggerStepOverRequest : IChromiumRequest<DebuggerStepOverResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Debugger.stepOver";
}
/// <summary>
/// Response from <see cref="DebuggerStepOverRequest"/>
/// </summary>
internal class DebuggerStepOverResponse : IChromiumResponse
{
}
/// <summary>
/// Fired when breakpoint is resolved to an actual script and location.
/// </summary>
/// <remarks>
/// Matches on the event <c>Debugger.breakpointResolved</c>
/// </remarks>
internal class DebuggerBreakpointResolvedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Debugger.breakpointResolved";
/// <summary>
/// Breakpoint unique identifier.
/// </summary>
public string BreakpointId { get; set; }
/// <summary>
/// Actual breakpoint location.
/// </summary>
public Location Location { get; set; }}
/// <summary>
/// Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
/// </summary>
/// <remarks>
/// Matches on the event <c>Debugger.paused</c>
/// </remarks>
internal class DebuggerPausedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Debugger.paused";
/// <summary>
/// Call stack the virtual machine stopped on.
/// </summary>
public CallFrame[] CallFrames { get; set; }
/// <summary>
/// Pause reason.
/// </summary>
public string Reason { get; set; }
/// <summary>
/// Object containing break-specific auxiliary properties.
/// </summary>
public JsonElement? Data { get; set; }
/// <summary>
/// Hit breakpoints IDs
/// </summary>
public string[] HitBreakpoints { get; set; }
/// <summary>
/// Async stack trace, if any.
/// </summary>
public Runtime.StackTrace AsyncStackTrace { get; set; }
/// <summary>
/// Async stack trace, if any.
/// </summary>
public Runtime.StackTraceId AsyncStackTraceId { get; set; }
/// <summary>
/// Never present, will be removed.
/// </summary>
public Runtime.StackTraceId AsyncCallStackTraceId { get; set; }}
/// <summary>
/// Fired when the virtual machine resumed execution.
/// </summary>
/// <remarks>
/// Matches on the event <c>Debugger.resumed</c>
/// </remarks>
internal class DebuggerResumedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Debugger.resumed";
}
/// <summary>
/// Fired when virtual machine fails to parse the script.
/// </summary>
/// <remarks>
/// Matches on the event <c>Debugger.scriptFailedToParse</c>
/// </remarks>
internal class DebuggerScriptFailedToParseChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Debugger.scriptFailedToParse";
/// <summary>
/// Identifier of the script parsed.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// URL or name of the script parsed (if any).
/// </summary>
public string Url { get; set; }
/// <summary>
/// Line offset of the script within the resource with given URL (for script tags).
/// </summary>
public int StartLine { get; set; }
/// <summary>
/// Column offset of the script within the resource with given URL.
/// </summary>
public int StartColumn { get; set; }
/// <summary>
/// Last line of the script.
/// </summary>
public int EndLine { get; set; }
/// <summary>
/// Length of the last line of the script.
/// </summary>
public int EndColumn { get; set; }
/// <summary>
/// Specifies script creation context.
/// </summary>
public int ExecutionContextId { get; set; }
/// <summary>
/// Content hash of the script.
/// </summary>
public string Hash { get; set; }
/// <summary>
/// Embedder-specific auxiliary data.
/// </summary>
public JsonElement? ExecutionContextAuxData { get; set; }
/// <summary>
/// URL of source map associated with script (if any).
/// </summary>
public string SourceMapURL { get; set; }
/// <summary>
/// True, if this script has sourceURL.
/// </summary>
public bool HasSourceURL { get; set; }
/// <summary>
/// True, if this script is ES6 module.
/// </summary>
public bool IsModule { get; set; }
/// <summary>
/// This script length.
/// </summary>
public int Length { get; set; }
/// <summary>
/// JavaScript top stack frame of where the script parsed event was triggered if available.
/// </summary>
public Runtime.StackTrace StackTrace { get; set; }}
/// <summary>
/// Fired when virtual machine parses script. This event is also fired for all known and uncollected
/// scripts upon enabling debugger.
/// </summary>
/// <remarks>
/// Matches on the event <c>Debugger.scriptParsed</c>
/// </remarks>
internal class DebuggerScriptParsedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Debugger.scriptParsed";
/// <summary>
/// Identifier of the script parsed.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// URL or name of the script parsed (if any).
/// </summary>
public string Url { get; set; }
/// <summary>
/// Line offset of the script within the resource with given URL (for script tags).
/// </summary>
public int StartLine { get; set; }
/// <summary>
/// Column offset of the script within the resource with given URL.
/// </summary>
public int StartColumn { get; set; }
/// <summary>
/// Last line of the script.
/// </summary>
public int EndLine { get; set; }
/// <summary>
/// Length of the last line of the script.
/// </summary>
public int EndColumn { get; set; }
/// <summary>
/// Specifies script creation context.
/// </summary>
public int ExecutionContextId { get; set; }
/// <summary>
/// Content hash of the script.
/// </summary>
public string Hash { get; set; }
/// <summary>
/// Embedder-specific auxiliary data.
/// </summary>
public JsonElement? ExecutionContextAuxData { get; set; }
/// <summary>
/// True, if this script is generated as a result of the live edit operation.
/// </summary>
public bool IsLiveEdit { get; set; }
/// <summary>
/// URL of source map associated with script (if any).
/// </summary>
public string SourceMapURL { get; set; }
/// <summary>
/// True, if this script has sourceURL.
/// </summary>
public bool HasSourceURL { get; set; }
/// <summary>
/// True, if this script is ES6 module.
/// </summary>
public bool IsModule { get; set; }
/// <summary>
/// This script length.
/// </summary>
public int Length { get; set; }
/// <summary>
/// JavaScript top stack frame of where the script parsed event was triggered if available.
/// </summary>
public Runtime.StackTrace StackTrace { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.HeapProfiler
{
/// <summary>
/// Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
/// </summary>
internal class SamplingHeapProfileNode
{
/// <summary>
/// Function location.
/// </summary>
public Runtime.CallFrame CallFrame { get; set; }
/// <summary>
/// Allocations size in bytes for the node excluding children.
/// </summary>
public double SelfSize { get; set; }
/// <summary>
/// Node id. Ids are unique across all profiles collected between startSampling and stopSampling.
/// </summary>
public int Id { get; set; }
/// <summary>
/// Child nodes.
/// </summary>
public SamplingHeapProfileNode[] Children { get; set; }}
/// <summary>
/// A single sample from a sampling profile.
/// </summary>
internal class SamplingHeapProfileSample
{
/// <summary>
/// Allocation size in bytes attributed to the sample.
/// </summary>
public double Size { get; set; }
/// <summary>
/// Id of the corresponding profile tree node.
/// </summary>
public int NodeId { get; set; }
/// <summary>
/// Time-ordered sample ordinal number. It is unique across all profiles retrieved
/// between startSampling and stopSampling.
/// </summary>
public double Ordinal { get; set; }}
/// <summary>
/// Sampling profile.
/// </summary>
internal class SamplingHeapProfile
{
/// <summary>
/// 
/// </summary>
public SamplingHeapProfileNode Head { get; set; }
/// <summary>
/// 
/// </summary>
public SamplingHeapProfileSample[] Samples { get; set; }}
/// <summary>
/// Enables console to refer to the node with given id via $x (see Command Line API for more details
/// $x functions).
/// </summary>
/// <remarks>
/// Will send the command <c>HeapProfiler.addInspectedHeapObject</c>
/// </remarks>
internal class HeapProfilerAddInspectedHeapObjectRequest : IChromiumRequest<HeapProfilerAddInspectedHeapObjectResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeapProfiler.addInspectedHeapObject";
/// <summary>
/// Heap snapshot object id to be accessible by means of $x command line API.
/// </summary>
public string HeapObjectId { get; set; }}
/// <summary>
/// Response from <see cref="HeapProfilerAddInspectedHeapObjectRequest"/>
/// </summary>
internal class HeapProfilerAddInspectedHeapObjectResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>HeapProfiler.collectGarbage</c>
/// </remarks>
internal class HeapProfilerCollectGarbageRequest : IChromiumRequest<HeapProfilerCollectGarbageResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeapProfiler.collectGarbage";
}
/// <summary>
/// Response from <see cref="HeapProfilerCollectGarbageRequest"/>
/// </summary>
internal class HeapProfilerCollectGarbageResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>HeapProfiler.disable</c>
/// </remarks>
internal class HeapProfilerDisableRequest : IChromiumRequest<HeapProfilerDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeapProfiler.disable";
}
/// <summary>
/// Response from <see cref="HeapProfilerDisableRequest"/>
/// </summary>
internal class HeapProfilerDisableResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>HeapProfiler.enable</c>
/// </remarks>
internal class HeapProfilerEnableRequest : IChromiumRequest<HeapProfilerEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeapProfiler.enable";
}
/// <summary>
/// Response from <see cref="HeapProfilerEnableRequest"/>
/// </summary>
internal class HeapProfilerEnableResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>HeapProfiler.getHeapObjectId</c>
/// </remarks>
internal class HeapProfilerGetHeapObjectIdRequest : IChromiumRequest<HeapProfilerGetHeapObjectIdResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeapProfiler.getHeapObjectId";
/// <summary>
/// Identifier of the object to get heap object id for.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="HeapProfilerGetHeapObjectIdRequest"/>
/// </summary>
internal class HeapProfilerGetHeapObjectIdResponse : IChromiumResponse
{
/// <summary>
/// Id of the heap snapshot object corresponding to the passed remote object id.
/// </summary>
public string HeapSnapshotObjectId { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>HeapProfiler.getObjectByHeapObjectId</c>
/// </remarks>
internal class HeapProfilerGetObjectByHeapObjectIdRequest : IChromiumRequest<HeapProfilerGetObjectByHeapObjectIdResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeapProfiler.getObjectByHeapObjectId";
/// <summary>
/// 
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// Symbolic group name that can be used to release multiple objects.
/// </summary>
public string ObjectGroup { get; set; }}
/// <summary>
/// Response from <see cref="HeapProfilerGetObjectByHeapObjectIdRequest"/>
/// </summary>
internal class HeapProfilerGetObjectByHeapObjectIdResponse : IChromiumResponse
{
/// <summary>
/// Evaluation result.
/// </summary>
public Runtime.RemoteObject Result { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>HeapProfiler.getSamplingProfile</c>
/// </remarks>
internal class HeapProfilerGetSamplingProfileRequest : IChromiumRequest<HeapProfilerGetSamplingProfileResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeapProfiler.getSamplingProfile";
}
/// <summary>
/// Response from <see cref="HeapProfilerGetSamplingProfileRequest"/>
/// </summary>
internal class HeapProfilerGetSamplingProfileResponse : IChromiumResponse
{
/// <summary>
/// Return the sampling profile being collected.
/// </summary>
public SamplingHeapProfile Profile { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>HeapProfiler.startSampling</c>
/// </remarks>
internal class HeapProfilerStartSamplingRequest : IChromiumRequest<HeapProfilerStartSamplingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeapProfiler.startSampling";
/// <summary>
/// Average sample interval in bytes. Poisson distribution is used for the intervals. The
/// default value is 32768 bytes.
/// </summary>
public double SamplingInterval { get; set; }}
/// <summary>
/// Response from <see cref="HeapProfilerStartSamplingRequest"/>
/// </summary>
internal class HeapProfilerStartSamplingResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>HeapProfiler.startTrackingHeapObjects</c>
/// </remarks>
internal class HeapProfilerStartTrackingHeapObjectsRequest : IChromiumRequest<HeapProfilerStartTrackingHeapObjectsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeapProfiler.startTrackingHeapObjects";
/// <summary>
/// 
/// </summary>
public bool TrackAllocations { get; set; }}
/// <summary>
/// Response from <see cref="HeapProfilerStartTrackingHeapObjectsRequest"/>
/// </summary>
internal class HeapProfilerStartTrackingHeapObjectsResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>HeapProfiler.stopSampling</c>
/// </remarks>
internal class HeapProfilerStopSamplingRequest : IChromiumRequest<HeapProfilerStopSamplingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeapProfiler.stopSampling";
}
/// <summary>
/// Response from <see cref="HeapProfilerStopSamplingRequest"/>
/// </summary>
internal class HeapProfilerStopSamplingResponse : IChromiumResponse
{
/// <summary>
/// Recorded sampling heap profile.
/// </summary>
public SamplingHeapProfile Profile { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>HeapProfiler.stopTrackingHeapObjects</c>
/// </remarks>
internal class HeapProfilerStopTrackingHeapObjectsRequest : IChromiumRequest<HeapProfilerStopTrackingHeapObjectsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeapProfiler.stopTrackingHeapObjects";
/// <summary>
/// If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken
/// when the tracking is stopped.
/// </summary>
public bool ReportProgress { get; set; }
/// <summary>
/// 
/// </summary>
public bool TreatGlobalObjectsAsRoots { get; set; }}
/// <summary>
/// Response from <see cref="HeapProfilerStopTrackingHeapObjectsRequest"/>
/// </summary>
internal class HeapProfilerStopTrackingHeapObjectsResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>HeapProfiler.takeHeapSnapshot</c>
/// </remarks>
internal class HeapProfilerTakeHeapSnapshotRequest : IChromiumRequest<HeapProfilerTakeHeapSnapshotResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "HeapProfiler.takeHeapSnapshot";
/// <summary>
/// If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
/// </summary>
public bool ReportProgress { get; set; }
/// <summary>
/// If true, a raw snapshot without artifical roots will be generated
/// </summary>
public bool TreatGlobalObjectsAsRoots { get; set; }}
/// <summary>
/// Response from <see cref="HeapProfilerTakeHeapSnapshotRequest"/>
/// </summary>
internal class HeapProfilerTakeHeapSnapshotResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>HeapProfiler.addHeapSnapshotChunk</c>
/// </remarks>
internal class HeapProfilerAddHeapSnapshotChunkChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "HeapProfiler.addHeapSnapshotChunk";
/// <summary>
/// 
/// </summary>
public string Chunk { get; set; }}
/// <summary>
/// If heap objects tracking has been started then backend may send update for one or more fragments
/// </summary>
/// <remarks>
/// Matches on the event <c>HeapProfiler.heapStatsUpdate</c>
/// </remarks>
internal class HeapProfilerHeapStatsUpdateChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "HeapProfiler.heapStatsUpdate";
/// <summary>
/// An array of triplets. Each triplet describes a fragment. The first integer is the fragment
/// index, the second integer is a total count of objects for the fragment, the third integer is
/// a total size of the objects for the fragment.
/// </summary>
public int[] StatsUpdate { get; set; }}
/// <summary>
/// If heap objects tracking has been started then backend regularly sends a current value for last
/// seen object id and corresponding timestamp. If the were changes in the heap since last event
/// then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
/// </summary>
/// <remarks>
/// Matches on the event <c>HeapProfiler.lastSeenObjectId</c>
/// </remarks>
internal class HeapProfilerLastSeenObjectIdChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "HeapProfiler.lastSeenObjectId";
/// <summary>
/// 
/// </summary>
public int LastSeenObjectId { get; set; }
/// <summary>
/// 
/// </summary>
public double Timestamp { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>HeapProfiler.reportHeapSnapshotProgress</c>
/// </remarks>
internal class HeapProfilerReportHeapSnapshotProgressChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "HeapProfiler.reportHeapSnapshotProgress";
/// <summary>
/// 
/// </summary>
public int Done { get; set; }
/// <summary>
/// 
/// </summary>
public int Total { get; set; }
/// <summary>
/// 
/// </summary>
public bool Finished { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>HeapProfiler.resetProfiles</c>
/// </remarks>
internal class HeapProfilerResetProfilesChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "HeapProfiler.resetProfiles";
}
}
namespace PlaywrightSharp.Chromium.Protocol.Profiler
{
/// <summary>
/// Profile node. Holds callsite information, execution statistics and child nodes.
/// </summary>
internal class ProfileNode
{
/// <summary>
/// Unique id of the node.
/// </summary>
public int Id { get; set; }
/// <summary>
/// Function location.
/// </summary>
public Runtime.CallFrame CallFrame { get; set; }
/// <summary>
/// Number of samples where this node was on top of the call stack.
/// </summary>
public int HitCount { get; set; }
/// <summary>
/// Child node ids.
/// </summary>
public int[] Children { get; set; }
/// <summary>
/// The reason of being not optimized. The function may be deoptimized or marked as don't
/// optimize.
/// </summary>
public string DeoptReason { get; set; }
/// <summary>
/// An array of source position ticks.
/// </summary>
public PositionTickInfo[] PositionTicks { get; set; }}
/// <summary>
/// Profile.
/// </summary>
internal class Profile
{
/// <summary>
/// The list of profile nodes. First item is the root node.
/// </summary>
public ProfileNode[] Nodes { get; set; }
/// <summary>
/// Profiling start timestamp in microseconds.
/// </summary>
public double StartTime { get; set; }
/// <summary>
/// Profiling end timestamp in microseconds.
/// </summary>
public double EndTime { get; set; }
/// <summary>
/// Ids of samples top nodes.
/// </summary>
public int[] Samples { get; set; }
/// <summary>
/// Time intervals between adjacent samples in microseconds. The first delta is relative to the
/// profile startTime.
/// </summary>
public int[] TimeDeltas { get; set; }}
/// <summary>
/// Specifies a number of samples attributed to a certain source position.
/// </summary>
internal class PositionTickInfo
{
/// <summary>
/// Source line number (1-based).
/// </summary>
public int Line { get; set; }
/// <summary>
/// Number of samples attributed to the source line.
/// </summary>
public int Ticks { get; set; }}
/// <summary>
/// Coverage data for a source range.
/// </summary>
internal class CoverageRange
{
/// <summary>
/// JavaScript script source offset for the range start.
/// </summary>
public int StartOffset { get; set; }
/// <summary>
/// JavaScript script source offset for the range end.
/// </summary>
public int EndOffset { get; set; }
/// <summary>
/// Collected execution count of the source range.
/// </summary>
public int Count { get; set; }}
/// <summary>
/// Coverage data for a JavaScript function.
/// </summary>
internal class FunctionCoverage
{
/// <summary>
/// JavaScript function name.
/// </summary>
public string FunctionName { get; set; }
/// <summary>
/// Source ranges inside the function with coverage data.
/// </summary>
public CoverageRange[] Ranges { get; set; }
/// <summary>
/// Whether coverage data for this function has block granularity.
/// </summary>
public bool IsBlockCoverage { get; set; }}
/// <summary>
/// Coverage data for a JavaScript script.
/// </summary>
internal class ScriptCoverage
{
/// <summary>
/// JavaScript script id.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// JavaScript script name or url.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Functions contained in the script that has coverage data.
/// </summary>
public FunctionCoverage[] Functions { get; set; }}
/// <summary>
/// Describes a type collected during runtime.
/// </summary>
internal class TypeObject
{
/// <summary>
/// Name of a type collected with type profiling.
/// </summary>
public string Name { get; set; }}
/// <summary>
/// Source offset and types for a parameter or return value.
/// </summary>
internal class TypeProfileEntry
{
/// <summary>
/// Source offset of the parameter or end of function for return values.
/// </summary>
public int Offset { get; set; }
/// <summary>
/// The types for this parameter or return value.
/// </summary>
public TypeObject[] Types { get; set; }}
/// <summary>
/// Type profile data collected during runtime for a JavaScript script.
/// </summary>
internal class ScriptTypeProfile
{
/// <summary>
/// JavaScript script id.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// JavaScript script name or url.
/// </summary>
public string Url { get; set; }
/// <summary>
/// Type profile entries for parameters and return values of the functions in the script.
/// </summary>
public TypeProfileEntry[] Entries { get; set; }}
/// <summary>
/// Collected counter information.
/// </summary>
internal class CounterInfo
{
/// <summary>
/// Counter name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Counter value.
/// </summary>
public int Value { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.disable</c>
/// </remarks>
internal class ProfilerDisableRequest : IChromiumRequest<ProfilerDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.disable";
}
/// <summary>
/// Response from <see cref="ProfilerDisableRequest"/>
/// </summary>
internal class ProfilerDisableResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.enable</c>
/// </remarks>
internal class ProfilerEnableRequest : IChromiumRequest<ProfilerEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.enable";
}
/// <summary>
/// Response from <see cref="ProfilerEnableRequest"/>
/// </summary>
internal class ProfilerEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Collect coverage data for the current isolate. The coverage data may be incomplete due to
/// garbage collection.
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.getBestEffortCoverage</c>
/// </remarks>
internal class ProfilerGetBestEffortCoverageRequest : IChromiumRequest<ProfilerGetBestEffortCoverageResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.getBestEffortCoverage";
}
/// <summary>
/// Response from <see cref="ProfilerGetBestEffortCoverageRequest"/>
/// </summary>
internal class ProfilerGetBestEffortCoverageResponse : IChromiumResponse
{
/// <summary>
/// Coverage data for the current isolate.
/// </summary>
public ScriptCoverage[] Result { get; set; }}
/// <summary>
/// Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.setSamplingInterval</c>
/// </remarks>
internal class ProfilerSetSamplingIntervalRequest : IChromiumRequest<ProfilerSetSamplingIntervalResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.setSamplingInterval";
/// <summary>
/// New sampling interval in microseconds.
/// </summary>
public int Interval { get; set; }}
/// <summary>
/// Response from <see cref="ProfilerSetSamplingIntervalRequest"/>
/// </summary>
internal class ProfilerSetSamplingIntervalResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.start</c>
/// </remarks>
internal class ProfilerStartRequest : IChromiumRequest<ProfilerStartResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.start";
}
/// <summary>
/// Response from <see cref="ProfilerStartRequest"/>
/// </summary>
internal class ProfilerStartResponse : IChromiumResponse
{
}
/// <summary>
/// Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
/// coverage may be incomplete. Enabling prevents running optimized code and resets execution
/// counters.
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.startPreciseCoverage</c>
/// </remarks>
internal class ProfilerStartPreciseCoverageRequest : IChromiumRequest<ProfilerStartPreciseCoverageResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.startPreciseCoverage";
/// <summary>
/// Collect accurate call counts beyond simple 'covered' or 'not covered'.
/// </summary>
public bool CallCount { get; set; }
/// <summary>
/// Collect block-based coverage.
/// </summary>
public bool Detailed { get; set; }}
/// <summary>
/// Response from <see cref="ProfilerStartPreciseCoverageRequest"/>
/// </summary>
internal class ProfilerStartPreciseCoverageResponse : IChromiumResponse
{
/// <summary>
/// Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
/// </summary>
public double Timestamp { get; set; }}
/// <summary>
/// Enable type profile.
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.startTypeProfile</c>
/// </remarks>
internal class ProfilerStartTypeProfileRequest : IChromiumRequest<ProfilerStartTypeProfileResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.startTypeProfile";
}
/// <summary>
/// Response from <see cref="ProfilerStartTypeProfileRequest"/>
/// </summary>
internal class ProfilerStartTypeProfileResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.stop</c>
/// </remarks>
internal class ProfilerStopRequest : IChromiumRequest<ProfilerStopResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.stop";
}
/// <summary>
/// Response from <see cref="ProfilerStopRequest"/>
/// </summary>
internal class ProfilerStopResponse : IChromiumResponse
{
/// <summary>
/// Recorded profile.
/// </summary>
public Profile Profile { get; set; }}
/// <summary>
/// Disable precise code coverage. Disabling releases unnecessary execution count records and allows
/// executing optimized code.
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.stopPreciseCoverage</c>
/// </remarks>
internal class ProfilerStopPreciseCoverageRequest : IChromiumRequest<ProfilerStopPreciseCoverageResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.stopPreciseCoverage";
}
/// <summary>
/// Response from <see cref="ProfilerStopPreciseCoverageRequest"/>
/// </summary>
internal class ProfilerStopPreciseCoverageResponse : IChromiumResponse
{
}
/// <summary>
/// Disable type profile. Disabling releases type profile data collected so far.
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.stopTypeProfile</c>
/// </remarks>
internal class ProfilerStopTypeProfileRequest : IChromiumRequest<ProfilerStopTypeProfileResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.stopTypeProfile";
}
/// <summary>
/// Response from <see cref="ProfilerStopTypeProfileRequest"/>
/// </summary>
internal class ProfilerStopTypeProfileResponse : IChromiumResponse
{
}
/// <summary>
/// Collect coverage data for the current isolate, and resets execution counters. Precise code
/// coverage needs to have started.
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.takePreciseCoverage</c>
/// </remarks>
internal class ProfilerTakePreciseCoverageRequest : IChromiumRequest<ProfilerTakePreciseCoverageResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.takePreciseCoverage";
}
/// <summary>
/// Response from <see cref="ProfilerTakePreciseCoverageRequest"/>
/// </summary>
internal class ProfilerTakePreciseCoverageResponse : IChromiumResponse
{
/// <summary>
/// Coverage data for the current isolate.
/// </summary>
public ScriptCoverage[] Result { get; set; }
/// <summary>
/// Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
/// </summary>
public double Timestamp { get; set; }}
/// <summary>
/// Collect type profile.
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.takeTypeProfile</c>
/// </remarks>
internal class ProfilerTakeTypeProfileRequest : IChromiumRequest<ProfilerTakeTypeProfileResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.takeTypeProfile";
}
/// <summary>
/// Response from <see cref="ProfilerTakeTypeProfileRequest"/>
/// </summary>
internal class ProfilerTakeTypeProfileResponse : IChromiumResponse
{
/// <summary>
/// Type profile for all scripts since startTypeProfile() was turned on.
/// </summary>
public ScriptTypeProfile[] Result { get; set; }}
/// <summary>
/// Enable run time call stats collection.
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.enableRuntimeCallStats</c>
/// </remarks>
internal class ProfilerEnableRuntimeCallStatsRequest : IChromiumRequest<ProfilerEnableRuntimeCallStatsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.enableRuntimeCallStats";
}
/// <summary>
/// Response from <see cref="ProfilerEnableRuntimeCallStatsRequest"/>
/// </summary>
internal class ProfilerEnableRuntimeCallStatsResponse : IChromiumResponse
{
}
/// <summary>
/// Disable run time call stats collection.
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.disableRuntimeCallStats</c>
/// </remarks>
internal class ProfilerDisableRuntimeCallStatsRequest : IChromiumRequest<ProfilerDisableRuntimeCallStatsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.disableRuntimeCallStats";
}
/// <summary>
/// Response from <see cref="ProfilerDisableRuntimeCallStatsRequest"/>
/// </summary>
internal class ProfilerDisableRuntimeCallStatsResponse : IChromiumResponse
{
}
/// <summary>
/// Retrieve run time call stats.
/// </summary>
/// <remarks>
/// Will send the command <c>Profiler.getRuntimeCallStats</c>
/// </remarks>
internal class ProfilerGetRuntimeCallStatsRequest : IChromiumRequest<ProfilerGetRuntimeCallStatsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Profiler.getRuntimeCallStats";
}
/// <summary>
/// Response from <see cref="ProfilerGetRuntimeCallStatsRequest"/>
/// </summary>
internal class ProfilerGetRuntimeCallStatsResponse : IChromiumResponse
{
/// <summary>
/// Collected counter information.
/// </summary>
public CounterInfo[] Result { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Matches on the event <c>Profiler.consoleProfileFinished</c>
/// </remarks>
internal class ProfilerConsoleProfileFinishedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Profiler.consoleProfileFinished";
/// <summary>
/// 
/// </summary>
public string Id { get; set; }
/// <summary>
/// Location of console.profileEnd().
/// </summary>
public Debugger.Location Location { get; set; }
/// <summary>
/// 
/// </summary>
public Profile Profile { get; set; }
/// <summary>
/// Profile title passed as an argument to console.profile().
/// </summary>
public string Title { get; set; }}
/// <summary>
/// Sent when new profile recording is started using console.profile() call.
/// </summary>
/// <remarks>
/// Matches on the event <c>Profiler.consoleProfileStarted</c>
/// </remarks>
internal class ProfilerConsoleProfileStartedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Profiler.consoleProfileStarted";
/// <summary>
/// 
/// </summary>
public string Id { get; set; }
/// <summary>
/// Location of console.profile().
/// </summary>
public Debugger.Location Location { get; set; }
/// <summary>
/// Profile title passed as an argument to console.profile().
/// </summary>
public string Title { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Runtime
{
/// <summary>
/// Mirror object referencing original JavaScript object.
/// </summary>
internal class RemoteObject
{
/// <summary>
/// Object type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Object subtype hint. Specified for `object` type values only.
/// </summary>
public string Subtype { get; set; }
/// <summary>
/// Object class (constructor) name. Specified for `object` type values only.
/// </summary>
public string ClassName { get; set; }
/// <summary>
/// Remote object value in case of primitive values or JSON values (if it was requested).
/// </summary>
public JsonElement? Value { get; set; }
/// <summary>
/// Primitive value which can not be JSON-stringified does not have `value`, but gets this
/// property.
/// </summary>
public string UnserializableValue { get; set; }
/// <summary>
/// String representation of the object.
/// </summary>
public string Description { get; set; }
/// <summary>
/// Unique object identifier (for non-primitive values).
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// Preview containing abbreviated property values. Specified for `object` type values only.
/// </summary>
public ObjectPreview Preview { get; set; }
/// <summary>
/// 
/// </summary>
public CustomPreview CustomPreview { get; set; }}
/// <summary>
/// 
/// </summary>
internal class CustomPreview
{
/// <summary>
/// The JSON-stringified result of formatter.header(object, config) call.
/// It contains json ML array that represents RemoteObject.
/// </summary>
public string Header { get; set; }
/// <summary>
/// If formatter returns true as a result of formatter.hasBody call then bodyGetterId will
/// contain RemoteObjectId for the function that returns result of formatter.body(object, config) call.
/// The result value is json ML array.
/// </summary>
public string BodyGetterId { get; set; }}
/// <summary>
/// Object containing abbreviated remote object value.
/// </summary>
internal class ObjectPreview
{
/// <summary>
/// Object type.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Object subtype hint. Specified for `object` type values only.
/// </summary>
public string Subtype { get; set; }
/// <summary>
/// String representation of the object.
/// </summary>
public string Description { get; set; }
/// <summary>
/// True iff some of the properties or entries of the original object did not fit.
/// </summary>
public bool Overflow { get; set; }
/// <summary>
/// List of the properties.
/// </summary>
public PropertyPreview[] Properties { get; set; }
/// <summary>
/// List of the entries. Specified for `map` and `set` subtype values only.
/// </summary>
public EntryPreview[] Entries { get; set; }}
/// <summary>
/// 
/// </summary>
internal class PropertyPreview
{
/// <summary>
/// Property name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Object type. Accessor means that the property itself is an accessor property.
/// </summary>
public string Type { get; set; }
/// <summary>
/// User-friendly property value string.
/// </summary>
public string Value { get; set; }
/// <summary>
/// Nested value preview.
/// </summary>
public ObjectPreview ValuePreview { get; set; }
/// <summary>
/// Object subtype hint. Specified for `object` type values only.
/// </summary>
public string Subtype { get; set; }}
/// <summary>
/// 
/// </summary>
internal class EntryPreview
{
/// <summary>
/// Preview of the key. Specified for map-like collection entries.
/// </summary>
public ObjectPreview Key { get; set; }
/// <summary>
/// Preview of the value.
/// </summary>
public ObjectPreview Value { get; set; }}
/// <summary>
/// Object property descriptor.
/// </summary>
internal class PropertyDescriptor
{
/// <summary>
/// Property name or symbol description.
/// </summary>
public string Name { get; set; }
/// <summary>
/// The value associated with the property.
/// </summary>
public RemoteObject Value { get; set; }
/// <summary>
/// True if the value associated with the property may be changed (data descriptors only).
/// </summary>
public bool Writable { get; set; }
/// <summary>
/// A function which serves as a getter for the property, or `undefined` if there is no getter
/// (accessor descriptors only).
/// </summary>
public RemoteObject Get { get; set; }
/// <summary>
/// A function which serves as a setter for the property, or `undefined` if there is no setter
/// (accessor descriptors only).
/// </summary>
public RemoteObject Set { get; set; }
/// <summary>
/// True if the type of this property descriptor may be changed and if the property may be
/// deleted from the corresponding object.
/// </summary>
public bool Configurable { get; set; }
/// <summary>
/// True if this property shows up during enumeration of the properties on the corresponding
/// object.
/// </summary>
public bool Enumerable { get; set; }
/// <summary>
/// True if the result was thrown during the evaluation.
/// </summary>
public bool WasThrown { get; set; }
/// <summary>
/// True if the property is owned for the object.
/// </summary>
public bool IsOwn { get; set; }
/// <summary>
/// Property symbol object, if the property is of the `symbol` type.
/// </summary>
public RemoteObject Symbol { get; set; }}
/// <summary>
/// Object internal property descriptor. This property isn't normally visible in JavaScript code.
/// </summary>
internal class InternalPropertyDescriptor
{
/// <summary>
/// Conventional property name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// The value associated with the property.
/// </summary>
public RemoteObject Value { get; set; }}
/// <summary>
/// Object private field descriptor.
/// </summary>
internal class PrivatePropertyDescriptor
{
/// <summary>
/// Private property name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// The value associated with the private property.
/// </summary>
public RemoteObject Value { get; set; }
/// <summary>
/// A function which serves as a getter for the private property,
/// or `undefined` if there is no getter (accessor descriptors only).
/// </summary>
public RemoteObject Get { get; set; }
/// <summary>
/// A function which serves as a setter for the private property,
/// or `undefined` if there is no setter (accessor descriptors only).
/// </summary>
public RemoteObject Set { get; set; }}
/// <summary>
/// Represents function call argument. Either remote object id `objectId`, primitive `value`,
/// unserializable primitive value or neither of (for undefined) them should be specified.
/// </summary>
internal class CallArgument
{
/// <summary>
/// Primitive value or serializable javascript object.
/// </summary>
public JsonElement? Value { get; set; }
/// <summary>
/// Primitive value which can not be JSON-stringified.
/// </summary>
public string UnserializableValue { get; set; }
/// <summary>
/// Remote object handle.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Description of an isolated world.
/// </summary>
internal class ExecutionContextDescription
{
/// <summary>
/// Unique id of the execution context. It can be used to specify in which execution context
/// script evaluation should be performed.
/// </summary>
public int Id { get; set; }
/// <summary>
/// Execution context origin.
/// </summary>
public string Origin { get; set; }
/// <summary>
/// Human readable name describing given context.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Embedder-specific auxiliary data.
/// </summary>
public JsonElement? AuxData { get; set; }}
/// <summary>
/// Detailed information about exception (or error) that was thrown during script compilation or
/// execution.
/// </summary>
internal class ExceptionDetails
{
/// <summary>
/// Exception id.
/// </summary>
public int ExceptionId { get; set; }
/// <summary>
/// Exception text, which should be used together with exception object when available.
/// </summary>
public string Text { get; set; }
/// <summary>
/// Line number of the exception location (0-based).
/// </summary>
public int LineNumber { get; set; }
/// <summary>
/// Column number of the exception location (0-based).
/// </summary>
public int ColumnNumber { get; set; }
/// <summary>
/// Script ID of the exception location.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// URL of the exception location, to be used when the script was not reported.
/// </summary>
public string Url { get; set; }
/// <summary>
/// JavaScript stack trace if available.
/// </summary>
public StackTrace StackTrace { get; set; }
/// <summary>
/// Exception object if available.
/// </summary>
public RemoteObject Exception { get; set; }
/// <summary>
/// Identifier of the context where exception happened.
/// </summary>
public int ExecutionContextId { get; set; }}
/// <summary>
/// Stack entry for runtime errors and assertions.
/// </summary>
internal class CallFrame
{
/// <summary>
/// JavaScript function name.
/// </summary>
public string FunctionName { get; set; }
/// <summary>
/// JavaScript script id.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// JavaScript script name or url.
/// </summary>
public string Url { get; set; }
/// <summary>
/// JavaScript script line number (0-based).
/// </summary>
public int LineNumber { get; set; }
/// <summary>
/// JavaScript script column number (0-based).
/// </summary>
public int ColumnNumber { get; set; }}
/// <summary>
/// Call frames for assertions or error messages.
/// </summary>
internal class StackTrace
{
/// <summary>
/// String label of this stack trace. For async traces this may be a name of the function that
/// initiated the async call.
/// </summary>
public string Description { get; set; }
/// <summary>
/// JavaScript function name.
/// </summary>
public CallFrame[] CallFrames { get; set; }
/// <summary>
/// Asynchronous JavaScript stack trace that preceded this stack, if available.
/// </summary>
public StackTrace Parent { get; set; }
/// <summary>
/// Asynchronous JavaScript stack trace that preceded this stack, if available.
/// </summary>
public StackTraceId ParentId { get; set; }}
/// <summary>
/// If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This
/// allows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.
/// </summary>
internal class StackTraceId
{
/// <summary>
/// 
/// </summary>
public string Id { get; set; }
/// <summary>
/// 
/// </summary>
public string DebuggerId { get; set; }}
/// <summary>
/// Add handler to promise with given promise object id.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.awaitPromise</c>
/// </remarks>
internal class RuntimeAwaitPromiseRequest : IChromiumRequest<RuntimeAwaitPromiseResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.awaitPromise";
/// <summary>
/// Identifier of the promise.
/// </summary>
public string PromiseObjectId { get; set; }
/// <summary>
/// Whether the result is expected to be a JSON object that should be sent by value.
/// </summary>
public bool ReturnByValue { get; set; }
/// <summary>
/// Whether preview should be generated for the result.
/// </summary>
public bool GeneratePreview { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeAwaitPromiseRequest"/>
/// </summary>
internal class RuntimeAwaitPromiseResponse : IChromiumResponse
{
/// <summary>
/// Promise result. Will contain rejected value if promise was rejected.
/// </summary>
public RemoteObject Result { get; set; }
/// <summary>
/// Exception details if stack strace is available.
/// </summary>
public ExceptionDetails ExceptionDetails { get; set; }}
/// <summary>
/// Calls function with given declaration on the given object. Object group of the result is
/// inherited from the target object.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.callFunctionOn</c>
/// </remarks>
internal class RuntimeCallFunctionOnRequest : IChromiumRequest<RuntimeCallFunctionOnResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.callFunctionOn";
/// <summary>
/// Declaration of the function to call.
/// </summary>
public string FunctionDeclaration { get; set; }
/// <summary>
/// Identifier of the object to call function on. Either objectId or executionContextId should
/// be specified.
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// Call arguments. All call arguments must belong to the same JavaScript world as the target
/// object.
/// </summary>
public CallArgument[] Arguments { get; set; }
/// <summary>
/// In silent mode exceptions thrown during evaluation are not reported and do not pause
/// execution. Overrides `setPauseOnException` state.
/// </summary>
public bool Silent { get; set; }
/// <summary>
/// Whether the result is expected to be a JSON object which should be sent by value.
/// </summary>
public bool ReturnByValue { get; set; }
/// <summary>
/// Whether preview should be generated for the result.
/// </summary>
public bool GeneratePreview { get; set; }
/// <summary>
/// Whether execution should be treated as initiated by user in the UI.
/// </summary>
public bool UserGesture { get; set; }
/// <summary>
/// Whether execution should `await` for resulting value and return once awaited promise is
/// resolved.
/// </summary>
public bool AwaitPromise { get; set; }
/// <summary>
/// Specifies execution context which global object will be used to call function on. Either
/// executionContextId or objectId should be specified.
/// </summary>
public int ExecutionContextId { get; set; }
/// <summary>
/// Symbolic group name that can be used to release multiple objects. If objectGroup is not
/// specified and objectId is, objectGroup will be inherited from object.
/// </summary>
public string ObjectGroup { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeCallFunctionOnRequest"/>
/// </summary>
internal class RuntimeCallFunctionOnResponse : IChromiumResponse
{
/// <summary>
/// Call result.
/// </summary>
public RemoteObject Result { get; set; }
/// <summary>
/// Exception details.
/// </summary>
public ExceptionDetails ExceptionDetails { get; set; }}
/// <summary>
/// Compiles expression.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.compileScript</c>
/// </remarks>
internal class RuntimeCompileScriptRequest : IChromiumRequest<RuntimeCompileScriptResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.compileScript";
/// <summary>
/// Expression to compile.
/// </summary>
public string Expression { get; set; }
/// <summary>
/// Source url to be set for the script.
/// </summary>
public string SourceURL { get; set; }
/// <summary>
/// Specifies whether the compiled script should be persisted.
/// </summary>
public bool PersistScript { get; set; }
/// <summary>
/// Specifies in which execution context to perform script run. If the parameter is omitted the
/// evaluation will be performed in the context of the inspected page.
/// </summary>
public int ExecutionContextId { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeCompileScriptRequest"/>
/// </summary>
internal class RuntimeCompileScriptResponse : IChromiumResponse
{
/// <summary>
/// Id of the script.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// Exception details.
/// </summary>
public ExceptionDetails ExceptionDetails { get; set; }}
/// <summary>
/// Disables reporting of execution contexts creation.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.disable</c>
/// </remarks>
internal class RuntimeDisableRequest : IChromiumRequest<RuntimeDisableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.disable";
}
/// <summary>
/// Response from <see cref="RuntimeDisableRequest"/>
/// </summary>
internal class RuntimeDisableResponse : IChromiumResponse
{
}
/// <summary>
/// Discards collected exceptions and console API calls.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.discardConsoleEntries</c>
/// </remarks>
internal class RuntimeDiscardConsoleEntriesRequest : IChromiumRequest<RuntimeDiscardConsoleEntriesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.discardConsoleEntries";
}
/// <summary>
/// Response from <see cref="RuntimeDiscardConsoleEntriesRequest"/>
/// </summary>
internal class RuntimeDiscardConsoleEntriesResponse : IChromiumResponse
{
}
/// <summary>
/// Enables reporting of execution contexts creation by means of `executionContextCreated` event.
/// When the reporting gets enabled the event will be sent immediately for each existing execution
/// context.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.enable</c>
/// </remarks>
internal class RuntimeEnableRequest : IChromiumRequest<RuntimeEnableResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.enable";
}
/// <summary>
/// Response from <see cref="RuntimeEnableRequest"/>
/// </summary>
internal class RuntimeEnableResponse : IChromiumResponse
{
}
/// <summary>
/// Evaluates expression on global object.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.evaluate</c>
/// </remarks>
internal class RuntimeEvaluateRequest : IChromiumRequest<RuntimeEvaluateResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.evaluate";
/// <summary>
/// Expression to evaluate.
/// </summary>
public string Expression { get; set; }
/// <summary>
/// Symbolic group name that can be used to release multiple objects.
/// </summary>
public string ObjectGroup { get; set; }
/// <summary>
/// Determines whether Command Line API should be available during the evaluation.
/// </summary>
public bool IncludeCommandLineAPI { get; set; }
/// <summary>
/// In silent mode exceptions thrown during evaluation are not reported and do not pause
/// execution. Overrides `setPauseOnException` state.
/// </summary>
public bool Silent { get; set; }
/// <summary>
/// Specifies in which execution context to perform evaluation. If the parameter is omitted the
/// evaluation will be performed in the context of the inspected page.
/// </summary>
public int ContextId { get; set; }
/// <summary>
/// Whether the result is expected to be a JSON object that should be sent by value.
/// </summary>
public bool ReturnByValue { get; set; }
/// <summary>
/// Whether preview should be generated for the result.
/// </summary>
public bool GeneratePreview { get; set; }
/// <summary>
/// Whether execution should be treated as initiated by user in the UI.
/// </summary>
public bool UserGesture { get; set; }
/// <summary>
/// Whether execution should `await` for resulting value and return once awaited promise is
/// resolved.
/// </summary>
public bool AwaitPromise { get; set; }
/// <summary>
/// Whether to throw an exception if side effect cannot be ruled out during evaluation.
/// This implies `disableBreaks` below.
/// </summary>
public bool ThrowOnSideEffect { get; set; }
/// <summary>
/// Terminate execution after timing out (number of milliseconds).
/// </summary>
public double Timeout { get; set; }
/// <summary>
/// Disable breakpoints during execution.
/// </summary>
public bool DisableBreaks { get; set; }
/// <summary>
/// Reserved flag for future REPL mode support. Setting this flag has currently no effect.
/// </summary>
public bool ReplMode { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeEvaluateRequest"/>
/// </summary>
internal class RuntimeEvaluateResponse : IChromiumResponse
{
/// <summary>
/// Evaluation result.
/// </summary>
public RemoteObject Result { get; set; }
/// <summary>
/// Exception details.
/// </summary>
public ExceptionDetails ExceptionDetails { get; set; }}
/// <summary>
/// Returns the isolate id.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.getIsolateId</c>
/// </remarks>
internal class RuntimeGetIsolateIdRequest : IChromiumRequest<RuntimeGetIsolateIdResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.getIsolateId";
}
/// <summary>
/// Response from <see cref="RuntimeGetIsolateIdRequest"/>
/// </summary>
internal class RuntimeGetIsolateIdResponse : IChromiumResponse
{
/// <summary>
/// The isolate id.
/// </summary>
public string Id { get; set; }}
/// <summary>
/// Returns the JavaScript heap usage.
/// It is the total usage of the corresponding isolate not scoped to a particular Runtime.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.getHeapUsage</c>
/// </remarks>
internal class RuntimeGetHeapUsageRequest : IChromiumRequest<RuntimeGetHeapUsageResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.getHeapUsage";
}
/// <summary>
/// Response from <see cref="RuntimeGetHeapUsageRequest"/>
/// </summary>
internal class RuntimeGetHeapUsageResponse : IChromiumResponse
{
/// <summary>
/// Used heap size in bytes.
/// </summary>
public double UsedSize { get; set; }
/// <summary>
/// Allocated heap size in bytes.
/// </summary>
public double TotalSize { get; set; }}
/// <summary>
/// Returns properties of a given object. Object group of the result is inherited from the target
/// object.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.getProperties</c>
/// </remarks>
internal class RuntimeGetPropertiesRequest : IChromiumRequest<RuntimeGetPropertiesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.getProperties";
/// <summary>
/// Identifier of the object to return properties for.
/// </summary>
public string ObjectId { get; set; }
/// <summary>
/// If true, returns properties belonging only to the element itself, not to its prototype
/// chain.
/// </summary>
public bool OwnProperties { get; set; }
/// <summary>
/// If true, returns accessor properties (with getter/setter) only; internal properties are not
/// returned either.
/// </summary>
public bool AccessorPropertiesOnly { get; set; }
/// <summary>
/// Whether preview should be generated for the results.
/// </summary>
public bool GeneratePreview { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeGetPropertiesRequest"/>
/// </summary>
internal class RuntimeGetPropertiesResponse : IChromiumResponse
{
/// <summary>
/// Object properties.
/// </summary>
public PropertyDescriptor[] Result { get; set; }
/// <summary>
/// Internal object properties (only of the element itself).
/// </summary>
public InternalPropertyDescriptor[] InternalProperties { get; set; }
/// <summary>
/// Object private properties.
/// </summary>
public PrivatePropertyDescriptor[] PrivateProperties { get; set; }
/// <summary>
/// Exception details.
/// </summary>
public ExceptionDetails ExceptionDetails { get; set; }}
/// <summary>
/// Returns all let, const and class variables from global scope.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.globalLexicalScopeNames</c>
/// </remarks>
internal class RuntimeGlobalLexicalScopeNamesRequest : IChromiumRequest<RuntimeGlobalLexicalScopeNamesResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.globalLexicalScopeNames";
/// <summary>
/// Specifies in which execution context to lookup global scope variables.
/// </summary>
public int ExecutionContextId { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeGlobalLexicalScopeNamesRequest"/>
/// </summary>
internal class RuntimeGlobalLexicalScopeNamesResponse : IChromiumResponse
{
/// <summary>
/// 
/// </summary>
public string[] Names { get; set; }}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.queryObjects</c>
/// </remarks>
internal class RuntimeQueryObjectsRequest : IChromiumRequest<RuntimeQueryObjectsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.queryObjects";
/// <summary>
/// Identifier of the prototype to return objects for.
/// </summary>
public string PrototypeObjectId { get; set; }
/// <summary>
/// Symbolic group name that can be used to release the results.
/// </summary>
public string ObjectGroup { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeQueryObjectsRequest"/>
/// </summary>
internal class RuntimeQueryObjectsResponse : IChromiumResponse
{
/// <summary>
/// Array with objects.
/// </summary>
public RemoteObject Objects { get; set; }}
/// <summary>
/// Releases remote object with given id.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.releaseObject</c>
/// </remarks>
internal class RuntimeReleaseObjectRequest : IChromiumRequest<RuntimeReleaseObjectResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.releaseObject";
/// <summary>
/// Identifier of the object to release.
/// </summary>
public string ObjectId { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeReleaseObjectRequest"/>
/// </summary>
internal class RuntimeReleaseObjectResponse : IChromiumResponse
{
}
/// <summary>
/// Releases all remote objects that belong to a given group.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.releaseObjectGroup</c>
/// </remarks>
internal class RuntimeReleaseObjectGroupRequest : IChromiumRequest<RuntimeReleaseObjectGroupResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.releaseObjectGroup";
/// <summary>
/// Symbolic object group name.
/// </summary>
public string ObjectGroup { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeReleaseObjectGroupRequest"/>
/// </summary>
internal class RuntimeReleaseObjectGroupResponse : IChromiumResponse
{
}
/// <summary>
/// Tells inspected instance to run if it was waiting for debugger to attach.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.runIfWaitingForDebugger</c>
/// </remarks>
internal class RuntimeRunIfWaitingForDebuggerRequest : IChromiumRequest<RuntimeRunIfWaitingForDebuggerResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.runIfWaitingForDebugger";
}
/// <summary>
/// Response from <see cref="RuntimeRunIfWaitingForDebuggerRequest"/>
/// </summary>
internal class RuntimeRunIfWaitingForDebuggerResponse : IChromiumResponse
{
}
/// <summary>
/// Runs script with given id in a given context.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.runScript</c>
/// </remarks>
internal class RuntimeRunScriptRequest : IChromiumRequest<RuntimeRunScriptResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.runScript";
/// <summary>
/// Id of the script to run.
/// </summary>
public string ScriptId { get; set; }
/// <summary>
/// Specifies in which execution context to perform script run. If the parameter is omitted the
/// evaluation will be performed in the context of the inspected page.
/// </summary>
public int ExecutionContextId { get; set; }
/// <summary>
/// Symbolic group name that can be used to release multiple objects.
/// </summary>
public string ObjectGroup { get; set; }
/// <summary>
/// In silent mode exceptions thrown during evaluation are not reported and do not pause
/// execution. Overrides `setPauseOnException` state.
/// </summary>
public bool Silent { get; set; }
/// <summary>
/// Determines whether Command Line API should be available during the evaluation.
/// </summary>
public bool IncludeCommandLineAPI { get; set; }
/// <summary>
/// Whether the result is expected to be a JSON object which should be sent by value.
/// </summary>
public bool ReturnByValue { get; set; }
/// <summary>
/// Whether preview should be generated for the result.
/// </summary>
public bool GeneratePreview { get; set; }
/// <summary>
/// Whether execution should `await` for resulting value and return once awaited promise is
/// resolved.
/// </summary>
public bool AwaitPromise { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeRunScriptRequest"/>
/// </summary>
internal class RuntimeRunScriptResponse : IChromiumResponse
{
/// <summary>
/// Run result.
/// </summary>
public RemoteObject Result { get; set; }
/// <summary>
/// Exception details.
/// </summary>
public ExceptionDetails ExceptionDetails { get; set; }}
/// <summary>
/// Enables or disables async call stacks tracking.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.setAsyncCallStackDepth</c>
/// </remarks>
internal class RuntimeSetAsyncCallStackDepthRequest : IChromiumRequest<RuntimeSetAsyncCallStackDepthResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.setAsyncCallStackDepth";
/// <summary>
/// Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
/// call stacks (default).
/// </summary>
public int MaxDepth { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeSetAsyncCallStackDepthRequest"/>
/// </summary>
internal class RuntimeSetAsyncCallStackDepthResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.setCustomObjectFormatterEnabled</c>
/// </remarks>
internal class RuntimeSetCustomObjectFormatterEnabledRequest : IChromiumRequest<RuntimeSetCustomObjectFormatterEnabledResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.setCustomObjectFormatterEnabled";
/// <summary>
/// 
/// </summary>
public bool Enabled { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeSetCustomObjectFormatterEnabledRequest"/>
/// </summary>
internal class RuntimeSetCustomObjectFormatterEnabledResponse : IChromiumResponse
{
}
/// <summary>
/// 
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.setMaxCallStackSizeToCapture</c>
/// </remarks>
internal class RuntimeSetMaxCallStackSizeToCaptureRequest : IChromiumRequest<RuntimeSetMaxCallStackSizeToCaptureResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.setMaxCallStackSizeToCapture";
/// <summary>
/// 
/// </summary>
public int Size { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeSetMaxCallStackSizeToCaptureRequest"/>
/// </summary>
internal class RuntimeSetMaxCallStackSizeToCaptureResponse : IChromiumResponse
{
}
/// <summary>
/// Terminate current or next JavaScript execution.
/// Will cancel the termination when the outer-most script execution ends.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.terminateExecution</c>
/// </remarks>
internal class RuntimeTerminateExecutionRequest : IChromiumRequest<RuntimeTerminateExecutionResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.terminateExecution";
}
/// <summary>
/// Response from <see cref="RuntimeTerminateExecutionRequest"/>
/// </summary>
internal class RuntimeTerminateExecutionResponse : IChromiumResponse
{
}
/// <summary>
/// If executionContextId is empty, adds binding with the given name on the
/// global objects of all inspected contexts, including those created later,
/// bindings survive reloads.
/// If executionContextId is specified, adds binding only on global object of
/// given execution context.
/// Binding function takes exactly one argument, this argument should be string,
/// in case of any other input, function throws an exception.
/// Each binding function call produces Runtime.bindingCalled notification.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.addBinding</c>
/// </remarks>
internal class RuntimeAddBindingRequest : IChromiumRequest<RuntimeAddBindingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.addBinding";
/// <summary>
/// 
/// </summary>
public string Name { get; set; }
/// <summary>
/// 
/// </summary>
public int ExecutionContextId { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeAddBindingRequest"/>
/// </summary>
internal class RuntimeAddBindingResponse : IChromiumResponse
{
}
/// <summary>
/// This method does not remove binding function from global object but
/// unsubscribes current runtime agent from Runtime.bindingCalled notifications.
/// </summary>
/// <remarks>
/// Will send the command <c>Runtime.removeBinding</c>
/// </remarks>
internal class RuntimeRemoveBindingRequest : IChromiumRequest<RuntimeRemoveBindingResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Runtime.removeBinding";
/// <summary>
/// 
/// </summary>
public string Name { get; set; }}
/// <summary>
/// Response from <see cref="RuntimeRemoveBindingRequest"/>
/// </summary>
internal class RuntimeRemoveBindingResponse : IChromiumResponse
{
}
/// <summary>
/// Notification is issued every time when binding is called.
/// </summary>
/// <remarks>
/// Matches on the event <c>Runtime.bindingCalled</c>
/// </remarks>
internal class RuntimeBindingCalledChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Runtime.bindingCalled";
/// <summary>
/// 
/// </summary>
public string Name { get; set; }
/// <summary>
/// 
/// </summary>
public string Payload { get; set; }
/// <summary>
/// Identifier of the context where the call was made.
/// </summary>
public int ExecutionContextId { get; set; }}
/// <summary>
/// Issued when console API was called.
/// </summary>
/// <remarks>
/// Matches on the event <c>Runtime.consoleAPICalled</c>
/// </remarks>
internal class RuntimeConsoleAPICalledChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Runtime.consoleAPICalled";
/// <summary>
/// Type of the call.
/// </summary>
public string Type { get; set; }
/// <summary>
/// Call arguments.
/// </summary>
public RemoteObject[] Args { get; set; }
/// <summary>
/// Identifier of the context where the call was made.
/// </summary>
public int ExecutionContextId { get; set; }
/// <summary>
/// Call timestamp.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// Stack trace captured when the call was made. The async stack chain is automatically reported for
/// the following call types: `assert`, `error`, `trace`, `warning`. For other types the async call
/// chain can be retrieved using `Debugger.getStackTrace` and `stackTrace.parentId` field.
/// </summary>
public StackTrace StackTrace { get; set; }
/// <summary>
/// Console context descriptor for calls on non-default console context (not console.*):
/// 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call
/// on named context.
/// </summary>
public string Context { get; set; }}
/// <summary>
/// Issued when unhandled exception was revoked.
/// </summary>
/// <remarks>
/// Matches on the event <c>Runtime.exceptionRevoked</c>
/// </remarks>
internal class RuntimeExceptionRevokedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Runtime.exceptionRevoked";
/// <summary>
/// Reason describing why exception was revoked.
/// </summary>
public string Reason { get; set; }
/// <summary>
/// The id of revoked exception, as reported in `exceptionThrown`.
/// </summary>
public int ExceptionId { get; set; }}
/// <summary>
/// Issued when exception was thrown and unhandled.
/// </summary>
/// <remarks>
/// Matches on the event <c>Runtime.exceptionThrown</c>
/// </remarks>
internal class RuntimeExceptionThrownChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Runtime.exceptionThrown";
/// <summary>
/// Timestamp of the exception.
/// </summary>
public double Timestamp { get; set; }
/// <summary>
/// 
/// </summary>
public ExceptionDetails ExceptionDetails { get; set; }}
/// <summary>
/// Issued when new execution context is created.
/// </summary>
/// <remarks>
/// Matches on the event <c>Runtime.executionContextCreated</c>
/// </remarks>
internal class RuntimeExecutionContextCreatedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Runtime.executionContextCreated";
/// <summary>
/// A newly created execution context.
/// </summary>
public ExecutionContextDescription Context { get; set; }}
/// <summary>
/// Issued when execution context is destroyed.
/// </summary>
/// <remarks>
/// Matches on the event <c>Runtime.executionContextDestroyed</c>
/// </remarks>
internal class RuntimeExecutionContextDestroyedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Runtime.executionContextDestroyed";
/// <summary>
/// Id of the destroyed context
/// </summary>
public int ExecutionContextId { get; set; }}
/// <summary>
/// Issued when all executionContexts were cleared in browser
/// </summary>
/// <remarks>
/// Matches on the event <c>Runtime.executionContextsCleared</c>
/// </remarks>
internal class RuntimeExecutionContextsClearedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Runtime.executionContextsCleared";
}
/// <summary>
/// Issued when object should be inspected (for example, as a result of inspect() command line API
/// call).
/// </summary>
/// <remarks>
/// Matches on the event <c>Runtime.inspectRequested</c>
/// </remarks>
internal class RuntimeInspectRequestedChromiumEvent : IChromiumEvent
{
public string InternalName { get; } = "Runtime.inspectRequested";
/// <summary>
/// 
/// </summary>
public RemoteObject Object { get; set; }
/// <summary>
/// 
/// </summary>
public JsonElement? Hints { get; set; }}
}
namespace PlaywrightSharp.Chromium.Protocol.Schema
{
/// <summary>
/// Description of the protocol domain.
/// </summary>
internal class Domain
{
/// <summary>
/// Domain name.
/// </summary>
public string Name { get; set; }
/// <summary>
/// Domain version.
/// </summary>
public string Version { get; set; }}
/// <summary>
/// Returns supported domains.
/// </summary>
/// <remarks>
/// Will send the command <c>Schema.getDomains</c>
/// </remarks>
internal class SchemaGetDomainsRequest : IChromiumRequest<SchemaGetDomainsResponse>
{
[System.Text.Json.Serialization.JsonIgnore]
public string Command { get; } = "Schema.getDomains";
}
/// <summary>
/// Response from <see cref="SchemaGetDomainsRequest"/>
/// </summary>
internal class SchemaGetDomainsResponse : IChromiumResponse
{
/// <summary>
/// List of supported domains.
/// </summary>
public Domain[] Domains { get; set; }}
}
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
