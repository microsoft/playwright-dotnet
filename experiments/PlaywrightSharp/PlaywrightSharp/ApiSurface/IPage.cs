/*
 * MIT License
 *
 * Copyright (c) Microsoft Corporation.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *
 * ------------------------------------------------------------------------------ 
 * <auto-generated> 
 * This code was generated by a tool at:
 * /utils/doclint/generateDotnetApi.js
 * 
 * Changes to this file may cause incorrect behavior and will be lost if 
 * the code is regenerated. 
 * </auto-generated> 
 * ------------------------------------------------------------------------------
 */
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Runtime.Serialization;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace PlaywrightSharp
{
    /// <summary>
	/// <seealso cref="[EventEmitter]"/>
	/// Page provides methods to interact with a single tab in a <see cref="IBrowser"/>, or an <a href="https://developer.chrome.com/extensions/background_pages">extension background page</a> in
	/// Chromium. One <see cref="IBrowser"/> instance might have multiple <see cref="IPage"/> instances.
	/// This example creates a page, navigates it to a URL, and then saves a screenshot:
	/// The Page class emits various events (described below) which can be handled using any of Node's native 
	/// <a href="https://nodejs.org/api/events.html#events_class_eventemitter">`EventEmitter`</a> methods, such as `on`, `once` or
	/// `removeListener`.
	/// This example logs a message for a single page `load` event:
	/// To unsubscribe from events use the `removeListener` method:
	/// </summary>
	public interface IPage
	{
		event EventHandler<IPage> OnClose;
		event EventHandler<IConsoleMessage> OnConsole;
		event EventHandler<IPage> OnCrash;
		event EventHandler<IDialog> OnDialog;
		event EventHandler<IPage> DOMContentLoaded;
		event EventHandler<IDownload> OnDownload;
		event EventHandler<IFileChooser> FileChooser;
		event EventHandler<IFrame> FrameAttached;
		event EventHandler<IFrame> FrameDetached;
		event EventHandler<IFrame> FrameNavigated;
		event EventHandler<IPage> OnLoad;
		event EventHandler<Error> PageError;
		event EventHandler<IPage> PopUp;
		event EventHandler<IRequest> OnRequest;
		event EventHandler<IRequest> OnRequestfailed;
		event EventHandler<IRequest> OnRequestfinished;
		event EventHandler<IResponse> OnResponse;
		event EventHandler<IWebSocket> OnWebsocket;
		event EventHandler<IWorker> OnWorker;
		/// <summary>
		/// The method finds an element matching the specified selector within the page. If no elements match the selector, the return
		/// value resolves to `null`.
		/// Shortcut for main frame's <see cref="IFrame.QuerySelectorAsync"/>.
		/// </summary>
		Task<IElementHandle> QuerySelectorAsync(string selector);
		/// <summary>
		/// The method finds all elements matching the specified selector within the page. If no elements match the selector, the return
		/// value resolves to `[]`.
		/// Shortcut for main frame's <see cref="IFrame.QuerySelectorAllAsync"/>.
		/// </summary>
		Task<dynamic> QuerySelectorAllAsync(string selector);
		/// <summary>
		/// The method finds an element matching the specified selector within the page and passes it as a first argument to {PARAM}.
		/// If no elements match the selector, the method throws an error. Returns the value of {PARAM}.
		/// If {PARAM} returns a [Promise], then <see cref="IPage.EvalOnSelectorAsync"/> would wait for the promise to resolve and return
		/// its value.
		/// Examples:
		/// Shortcut for main frame's <see cref="IFrame.EvalOnSelectorAsync"/>.
		/// </summary>
		Task<T> EvalOnSelectorAsync<T>(string selector, EvaluationArgument arg);
		/// <summary>
		/// The method finds all elements matching the specified selector within the page and passes an array of matched elements as
		/// a first argument to {PARAM}. Returns the result of {PARAM} invocation.
		/// If {PARAM} returns a [Promise], then <see cref="IPage.EvalOnSelectorAllAsync"/> would wait for the promise to resolve and
		/// return its value.
		/// Examples:
		/// </summary>
		Task<T> EvalOnSelectorAllAsync<T>(string selector, EvaluationArgument arg);
		IAccessibility Accessibility { get; set; }
		/// <summary>
		/// Adds a script which would be evaluated in one of the following scenarios:
		/// <list>
		/// <item><description>Whenever the page is navigated.</description></item>
		/// <item><description>Whenever the child frame is attached or navigated. In this case, the script is evaluated in the context of the newly attached frame.</description>
		/// </item>
		/// </list>
		/// The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend the
		/// JavaScript environment, e.g. to seed `Math.random`.
		/// An example of overriding `Math.random` before the page loads:
		/// </summary>
		Task AddInitScriptAsync();
		/// <summary>
		/// Adds a `<script>` tag into the page with the desired url or content. Returns the added tag when the script's onload fires or when the script content was injected into frame.
		/// Shortcut for main frame's <see cref="IFrame.AddScriptTagAsync"/>.
		/// </summary>
		Task<IElementHandle> AddScriptTagAsync(string content, string path, string type, string url);
		/// <summary>
		/// Adds a `<link rel="stylesheet">` tag into the page with the desired url or a `<style type="text/css">` tag with the content. Returns the added tag when the stylesheet's onload fires or when the CSS content was injected into frame.
		/// Shortcut for main frame's <see cref="IFrame.AddStyleTagAsync"/>.
		/// </summary>
		Task<IElementHandle> AddStyleTagAsync(string content, string path, string url);
		/// <summary>
		/// Brings page to front (activates tab).
		/// </summary>
		Task BringToFrontAsync();
		/// <summary>
		/// This method checks an element matching {PARAM} by performing the following steps:
		/// <list>
		/// <item><description>Find an element match matching {PARAM}. If there is none, wait until a matching element is attached to the DOM.</description>
		/// </item>
		/// <item><description>Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already checked, this method returns immediately.</description>
		/// </item>
		/// <item><description>Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless {OPTION}
		/// option is set. If the element is detached during the checks, the whole action is retried.</description>
		/// </item>
		/// <item><description>Scroll the element into view if needed.</description></item>
		/// <item><description>Use <see cref="IPage.Mouse"/> to click in the center of the element.</description></item>
		/// <item><description>Wait for initiated navigations to either succeed or fail, unless {OPTION} option is set.</description>
		/// </item>
		/// <item><description>Ensure that the element is now checked. If not, this method rejects.</description></item>
		/// </list>
		/// When all steps combined have not finished during the specified {OPTION}, this method rejects with a <see cref="ITimeoutError"/>.
		/// Passing zero timeout disables this.
		/// Shortcut for main frame's <see cref="IFrame.CheckAsync"/>.
		/// </summary>
		Task CheckAsync(string selector, bool force, bool noWaitAfter, float timeout);
		/// <summary>
		/// This method clicks an element matching {PARAM} by performing the following steps:
		/// <list>
		/// <item><description>Find an element match matching {PARAM}. If there is none, wait until a matching element is attached to the DOM.</description>
		/// </item>
		/// <item><description>Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless {OPTION}
		/// option is set. If the element is detached during the checks, the whole action is retried.</description>
		/// </item>
		/// <item><description>Scroll the element into view if needed.</description></item>
		/// <item><description>Use <see cref="IPage.Mouse"/> to click in the center of the element, or the specified {OPTION}.
		/// </description></item>
		/// <item><description>Wait for initiated navigations to either succeed or fail, unless {OPTION} option is set.</description>
		/// </item>
		/// </list>
		/// When all steps combined have not finished during the specified {OPTION}, this method rejects with a <see cref="ITimeoutError"/>.
		/// Passing zero timeout disables this.
		/// Shortcut for main frame's <see cref="IFrame.ClickAsync"/>.
		/// </summary>
		Task ClickAsync(string selector, Button button, int clickCount, float delay, bool force, Modifiers[] modifiers, bool noWaitAfter, PagePosition position, float timeout);
		/// <summary>
		/// If {OPTION} is `false`, does not run any unload handlers and waits for the page to be closed. If {OPTION} is `true` the method
		/// will run unload handlers, but will **not** wait for the page to close.
		/// By default, `page.close()` **does not** run `beforeunload` handlers.
		/// </summary>
		Task CloseAsync(bool runBeforeUnload);
		/// <summary>
		/// Gets the full HTML contents of the page, including the doctype.
		/// </summary>
		Task<string> GetContentAsync();
		/// <summary>
		/// Get the browser context that the page belongs to.
		/// </summary>
		IBrowserContext GetContext();
		/// <summary>
		/// This method double clicks an element matching {PARAM} by performing the following steps:
		/// <list>
		/// <item><description>Find an element match matching {PARAM}. If there is none, wait until a matching element is attached to the DOM.</description>
		/// </item>
		/// <item><description>Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless {OPTION}
		/// option is set. If the element is detached during the checks, the whole action is retried.</description>
		/// </item>
		/// <item><description>Scroll the element into view if needed.</description></item>
		/// <item><description>Use <see cref="IPage.Mouse"/> to double click in the center of the element, or the specified {OPTION}.
		/// </description></item>
		/// <item><description>Wait for initiated navigations to either succeed or fail, unless {OPTION} option is set. Note that if the first click of the `dblclick()` triggers a navigation event, this method will reject.</description>
		/// </item>
		/// </list>
		/// When all steps combined have not finished during the specified {OPTION}, this method rejects with a <see cref="ITimeoutError"/>.
		/// Passing zero timeout disables this.
		/// Shortcut for main frame's <see cref="IFrame.DblclickAsync"/>.
		/// </summary>
		Task DblclickAsync(string selector, Button button, float delay, bool force, Modifiers[] modifiers, bool noWaitAfter, PagePosition position, float timeout);
		/// <summary>
		/// The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click`
		/// is dispatched. This is equivalend to calling <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click">element.click()</a>.
		/// Under the hood, it creates an instance of an event based on the given {PARAM}, initializes it with {PARAM} properties and
		/// dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.
		/// Since {PARAM} is event-specific, please refer to the events documentation for the lists of initial properties:
		/// <list>
		/// <item><description><a href="https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent">DragEvent</a>
		/// </description></item>
		/// <item><description><a href="https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent">FocusEvent</a>
		/// </description></item>
		/// <item><description><a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent">KeyboardEvent</a>
		/// </description></item>
		/// <item><description><a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent">MouseEvent</a>
		/// </description></item>
		/// <item><description><a href="https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent">PointerEvent</a>
		/// </description></item>
		/// <item><description><a href="https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent">TouchEvent</a>
		/// </description></item>
		/// <item><description><a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/Event">Event</a></description>
		/// </item>
		/// </list>
		/// You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:
		/// </summary>
		Task DispatchEventAsync(string selector, string type, EvaluationArgument eventInit, float timeout);
		Task EmulateMediaAsync();
		/// <summary>
		/// Returns the value of the {PARAM} invocation.
		/// If the function passed to the <see cref="IPage.EvaluateAsync"/> returns a [Promise], then <see cref="IPage.EvaluateAsync"/> would
		/// wait for the promise to resolve and return its value.
		/// If the function passed to the <see cref="IPage.EvaluateAsync"/> returns a non-[Serializable] value, then <see cref="IPage.EvaluateAsync"/> resolves
		/// to `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`:
		/// `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.
		/// Passing argument to {PARAM}:
		/// A string can also be passed in instead of a function:
		/// <see cref="IElementHandle"/> instances can be passed as an argument to the <see cref="IPage.EvaluateAsync"/>:
		/// Shortcut for main frame's <see cref="IFrame.EvaluateAsync"/>.
		/// </summary>
		Task<T> EvaluateAsync<T>(EvaluationArgument arg);
		/// <summary>
		/// Returns the value of the {PARAM} invocation as in-page object (JSHandle).
		/// The only difference between <see cref="IPage.EvaluateAsync"/> and <see cref="IPage.EvaluateHandleAsync"/> is that 
		/// <see cref="IPage.EvaluateHandleAsync"/> returns in-page object (JSHandle).
		/// If the function passed to the <see cref="IPage.EvaluateHandleAsync"/> returns a [Promise], then <see cref="IPage.EvaluateHandleAsync"/> would
		/// wait for the promise to resolve and return its value.
		/// A string can also be passed in instead of a function:
		/// <see cref="IJSHandle"/> instances can be passed as an argument to the <see cref="IPage.EvaluateHandleAsync"/>:
		/// </summary>
		Task<IJSHandle> EvaluateHandleAsync(EvaluationArgument arg);
		/// <summary>
		/// The method adds a function called {PARAM} on the `window` object of every frame in this page. When called, the function executes
		/// {PARAM} and returns a [Promise] which resolves to the return value of {PARAM}. If the {PARAM} returns a [Promise], it will be awaited.
		/// The first argument of the {PARAM} function contains information about the caller: `{ browserContext: BrowserContext, page:
		/// Page, frame: Frame }`.
		/// See <see cref="IBrowserContext.ExposeBindingAsync"/> for the context-wide version.
		/// An example of exposing page URL to all frames in a page:
		/// An example of passing an element handle:
		/// </summary>
		Task ExposeBindingAsync(string name, Action callback, bool handle);
		/// <summary>
		/// The method adds a function called {PARAM} on the `window` object of every frame in the page. When called, the function executes
		/// {PARAM} and returns a [Promise] which resolves to the return value of {PARAM}.
		/// If the {PARAM} returns a [Promise], it will be awaited.
		/// See <see cref="IBrowserContext.ExposeFunctionAsync"/> for context-wide exposed function.
		/// An example of adding an `sha1` function to the page:
		/// </summary>
		Task ExposeFunctionAsync(string name, Action callback);
		/// <summary>
		/// This method waits for an element matching {PARAM}, waits for <a href="./actionability.md">actionability</a> checks, focuses
		/// the element, fills it and triggers an `input` event after filling. If the element matching {PARAM} is not an `
		/// <input>`, `<textarea>` or `[contenteditable]` element, this method throws an error. Note that you can pass an empty string to clear the input field.
		/// To send fine-grained keyboard events, use <see cref="IPage.TypeAsync"/>.
		/// Shortcut for main frame's <see cref="IFrame.FillAsync"/>
		/// </summary>
		Task FillAsync(string selector, string value, bool noWaitAfter, float timeout);
		/// <summary>
		/// This method fetches an element with {PARAM} and focuses it. If there's no element matching {PARAM}, the method waits until
		/// a matching element appears in the DOM.
		/// Shortcut for main frame's <see cref="IFrame.FocusAsync"/>.
		/// </summary>
		Task FocusAsync(string selector, float timeout);
		/// <summary>
		/// Returns frame matching the specified criteria. Either `name` or `url` must be specified.
		/// </summary>
		IFrame GetFrame();
		/// <summary>
		/// An array of all frames attached to the page.
		/// </summary>
		dynamic GetFrames();
		/// <summary>
		/// Returns element attribute value.
		/// </summary>
		Task<string> GetAttributeAsync(string selector, string name, float timeout);
		/// <summary>
		/// Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last
		/// redirect. If can not go back, returns `null`.
		/// Navigate to the previous page in history.
		/// </summary>
		Task<IResponse> GoBackAsync(float timeout, WaitUntil waitUntil);
		/// <summary>
		/// Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last
		/// redirect. If can not go forward, returns `null`.
		/// Navigate to the next page in history.
		/// </summary>
		Task<IResponse> GoForwardAsync(float timeout, WaitUntil waitUntil);
		/// <summary>
		/// Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last
		/// redirect.
		/// `page.goto` will throw an error if:
		/// <list>
		/// <item><description>there's an SSL error (e.g. in case of self-signed certificates).</description></item>
		/// <item><description>target URL is invalid.</description></item>
		/// <item><description>the {OPTION} is exceeded during navigation.</description></item>
		/// <item><description>the remote server does not respond or is unreachable.</description></item>
		/// <item><description>the main resource failed to load.</description></item>
		/// </list>
		/// `page.goto` will not throw an error when any valid HTTP status code is returned by the remote server, including 404 "Not
		/// Found" and 500 "Internal Server Error".  The status code for such responses can be retrieved by calling 
		/// <see cref="IResponse.Status"/>.
		/// Shortcut for main frame's <see cref="IFrame.GotoAsync"/>
		/// </summary>
		Task<IResponse> GotoAsync(string url, string referer, float timeout, WaitUntil waitUntil);
		/// <summary>
		/// This method hovers over an element matching {PARAM} by performing the following steps:
		/// <list>
		/// <item><description>Find an element match matching {PARAM}. If there is none, wait until a matching element is attached to the DOM.</description>
		/// </item>
		/// <item><description>Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless {OPTION}
		/// option is set. If the element is detached during the checks, the whole action is retried.</description>
		/// </item>
		/// <item><description>Scroll the element into view if needed.</description></item>
		/// <item><description>Use <see cref="IPage.Mouse"/> to hover over the center of the element, or the specified {OPTION}.
		/// </description></item>
		/// <item><description>Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.</description>
		/// </item>
		/// </list>
		/// When all steps combined have not finished during the specified {OPTION}, this method rejects with a <see cref="ITimeoutError"/>.
		/// Passing zero timeout disables this.
		/// Shortcut for main frame's <see cref="IFrame.HoverAsync"/>.
		/// </summary>
		Task HoverAsync(string selector, bool force, Modifiers[] modifiers, PagePosition position, float timeout);
		/// <summary>
		/// Returns `element.innerHTML`.
		/// </summary>
		Task<string> InnerHTMLAsync(string selector, float timeout);
		/// <summary>
		/// Returns `element.innerText`.
		/// </summary>
		Task<string> InnerTextAsync(string selector, float timeout);
		/// <summary>
		/// Returns whether the element is checked. Throws if the element is not a checkbox or radio input.
		/// </summary>
		Task<bool> IsCheckedAsync(string selector, float timeout);
		/// <summary>
		/// Indicates that the page has been closed.
		/// </summary>
		bool IsClosed();
		/// <summary>
		/// Returns whether the element is disabled, the opposite of <a href="./actionability.md#enabled">enabled</a>.
		/// </summary>
		Task<bool> IsDisabledAsync(string selector, float timeout);
		/// <summary>
		/// Returns whether the element is <a href="./actionability.md#editable">editable</a>.
		/// </summary>
		Task<bool> IsEditableAsync(string selector, float timeout);
		/// <summary>
		/// Returns whether the element is <a href="./actionability.md#enabled">enabled</a>.
		/// </summary>
		Task<bool> IsEnabledAsync(string selector, float timeout);
		/// <summary>
		/// Returns whether the element is hidden, the opposite of <a href="./actionability.md#visible">visible</a>.
		/// </summary>
		Task<bool> IsHiddenAsync(string selector, float timeout);
		/// <summary>
		/// Returns whether the element is <a href="./actionability.md#visible">visible</a>.
		/// </summary>
		Task<bool> IsVisibleAsync(string selector, float timeout);
		IKeyboard Keyboard { get; set; }
		/// <summary>
		/// The page's main frame. Page is guaranteed to have a main frame which persists during navigations.
		/// </summary>
		IFrame GetMainFrame();
		IMouse Mouse { get; set; }
		/// <summary>
		/// Returns the opener for popup pages and `null` for others. If the opener has been closed already the returns `null`.
		/// </summary>
		Task<IPage> GetOpenerAsync();
		/// <summary>
		/// Returns the PDF buffer.
		/// `page.pdf()` generates a pdf of the page with `print` css media. To generate a pdf with `screen` media, call 
		/// <see cref="IPage.EmulateMediaAsync"/> before calling `page.pdf()`:
		/// The {OPTION}, {OPTION}, and {OPTION} options accept values labeled with units. Unlabeled values are treated as pixels.
		/// A few examples:
		/// <list>
		/// <item><description>`page.pdf({width: 100})` - prints with width set to 100 pixels</description></item>
		/// <item><description>`page.pdf({width: '100px'})` - prints with width set to 100 pixels</description></item>
		/// <item><description>`page.pdf({width: '10cm'})` - prints with width set to 10 centimeters.</description>
		/// </item>
		/// </list>
		/// All possible units are:
		/// <list>
		/// <item><description>`px` - pixel</description></item>
		/// <item><description>`in` - inch</description></item>
		/// <item><description>`cm` - centimeter</description></item>
		/// <item><description>`mm` - millimeter</description></item>
		/// </list>
		/// The {OPTION} options are:
		/// <list>
		/// <item><description>`Letter`: 8.5in x 11in</description></item>
		/// <item><description>`Legal`: 8.5in x 14in</description></item>
		/// <item><description>`Tabloid`: 11in x 17in</description></item>
		/// <item><description>`Ledger`: 17in x 11in</description></item>
		/// <item><description>`A0`: 33.1in x 46.8in</description></item>
		/// <item><description>`A1`: 23.4in x 33.1in</description></item>
		/// <item><description>`A2`: 16.54in x 23.4in</description></item>
		/// <item><description>`A3`: 11.7in x 16.54in</description></item>
		/// <item><description>`A4`: 8.27in x 11.7in</description></item>
		/// <item><description>`A5`: 5.83in x 8.27in</description></item>
		/// <item><description>`A6`: 4.13in x 5.83in</description></item>
		/// </summary>
		Task<byte[]> PdfAsync(bool displayHeaderFooter, string footerTemplate, string format, string headerTemplate, string height, bool landscape, PageMargin margin, string pageRanges, string path, bool preferCSSPageSize, bool printBackground, float scale, string width);
		/// <summary>
		/// Focuses the element, and then uses <see cref="IKeyboard.DownAsync"/> and <see cref="IKeyboard.UpAsync"/>.
		/// {PARAM} can specify the intended <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key">keyboardEvent.key</a> value
		/// or a single character to generate the text for. A superset of the {PARAM} values can be found <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values">here</a>.
		/// Examples of the keys are:
		/// `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`,
		/// `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
		/// Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.
		/// Holding down `Shift` will type the text that corresponds to the {PARAM} in the upper case.
		/// If {PARAM} is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective texts.
		/// Shortcuts such as `key: "Control+o"` or `key: "Control+Shift+T"` are supported as well. When speficied with the modifier,
		/// modifier is pressed and being held while the subsequent key is being pressed.
		/// </summary>
		Task PressAsync(string selector, string key, float delay, bool noWaitAfter, float timeout);
		/// <summary>
		/// Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last
		/// redirect.
		/// </summary>
		Task<IResponse> ReloadAsync(float timeout, WaitUntil waitUntil);
		/// <summary>
		/// Routing provides the capability to modify network requests that are made by a page.
		/// Once routing is enabled, every request matching the url pattern will stall unless it's continued, fulfilled or aborted.
		/// An example of a na√Øve handler that aborts all image requests:
		/// or the same snippet using a regex pattern instead:
		/// Page routes take precedence over browser context routes (set up with <see cref="IBrowserContext.RouteAsync"/>) when request
		/// matches both handlers.
		/// </summary>
		Task RouteAsync(Union url, Action handler);
		/// <summary>
		/// Returns the buffer with the captured screenshot.
		/// </summary>
		Task<byte[]> ScreenshotAsync(PageClip clip, bool fullPage, bool omitBackground, string path, int quality, float timeout, Type type);
		/// <summary>
		/// Returns the array of option values that have been successfully selected.
		/// Triggers a `change` and `input` event once all the provided options have been selected. If there's no `
		/// <select>` element matching {PARAM}, the method throws an error.
		/// Will wait until all specified options are present in the `<select>` element.
		/// Shortcut for main frame's <see cref="IFrame.SelectOptionAsync"/>
		/// </summary>
		Task<dynamic> SelectOptionAsync(string selector, bool noWaitAfter, float timeout);
		Task SetContentAsync(string html, float timeout, WaitUntil waitUntil);
		/// <summary>
		/// This setting will change the default maximum navigation time for the following methods and related shortcuts:
		/// <list>
		/// <item><description><see cref="IPage.GoBackAsync"/></description></item>
		/// <item><description><see cref="IPage.GoForwardAsync"/></description></item>
		/// <item><description><see cref="IPage.GotoAsync"/></description></item>
		/// <item><description><see cref="IPage.ReloadAsync"/></description></item>
		/// <item><description><see cref="IPage.SetContentAsync"/></description></item>
		/// <item><description><see cref="IPage.WaitForNavigationAsync"/></description></item>
		/// </summary>
		void SetDefaultNavigationTimeout(float timeout);
		/// <summary>
		/// This setting will change the default maximum time for all the methods accepting {PARAM} option.
		/// </summary>
		void SetDefaultTimeout(float timeout);
		/// <summary>
		/// The extra HTTP headers will be sent with every request the page initiates.
		/// </summary>
		Task SetExtraHTTPHeadersAsync(IEnumerable<KeyValuePair<string, string>> headers);
		/// <summary>
		/// This method expects {PARAM} to point to an <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input">input element</a>.
		/// Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they are
		/// resolved relative to the the current working directory. For empty array, clears the selected files.
		/// </summary>
		Task SetInputFilesAsync(string selector, string[] files, bool noWaitAfter, float timeout);
		/// <summary>
		/// In the case of multiple pages in a single browser, each page can have its own viewport size. However, 
		/// <see cref="IBrowser.NewContextAsync"/> allows to set viewport size (and more) for all pages in the context at once.
		/// `page.setViewportSize` will resize the page. A lot of websites don't expect phones to change size, so you should set the
		/// viewport size before navigating to the page.
		/// </summary>
		Task SetViewportSizeAsync(PageViewportSize viewportSize);
		/// <summary>
		/// This method taps an element matching {PARAM} by performing the following steps:
		/// <list>
		/// <item><description>Find an element match matching {PARAM}. If there is none, wait until a matching element is attached to the DOM.</description>
		/// </item>
		/// <item><description>Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless {OPTION}
		/// option is set. If the element is detached during the checks, the whole action is retried.</description>
		/// </item>
		/// <item><description>Scroll the element into view if needed.</description></item>
		/// <item><description>Use <see cref="IPage.Touchscreen"/> to tap the center of the element, or the specified {OPTION}.
		/// </description></item>
		/// <item><description>Wait for initiated navigations to either succeed or fail, unless {OPTION} option is set.</description>
		/// </item>
		/// </list>
		/// When all steps combined have not finished during the specified {OPTION}, this method rejects with a <see cref="ITimeoutError"/>.
		/// Passing zero timeout disables this.
		/// Shortcut for main frame's <see cref="IFrame.TapAsync"/>.
		/// </summary>
		Task TapAsync(string selector, bool force, Modifiers[] modifiers, bool noWaitAfter, PagePosition position, float timeout);
		/// <summary>
		/// Returns `element.textContent`.
		/// </summary>
		Task<string> TextContentAsync(string selector, float timeout);
		/// <summary>
		/// Returns the page's title. Shortcut for main frame's <see cref="IFrame.TitleAsync"/>.
		/// </summary>
		Task<string> GetTitleAsync();
		ITouchscreen Touchscreen { get; set; }
		/// <summary>
		/// Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `page.type` can be used to send
		/// fine-grained keyboard events. To fill values in form fields, use <see cref="IPage.FillAsync"/>.
		/// To press a special key, like `Control` or `ArrowDown`, use <see cref="IKeyboard.PressAsync"/>.
		/// Shortcut for main frame's <see cref="IFrame.TypeAsync"/>.
		/// </summary>
		Task TypeAsync(string selector, string text, float delay, bool noWaitAfter, float timeout);
		/// <summary>
		/// This method unchecks an element matching {PARAM} by performing the following steps:
		/// <list>
		/// <item><description>Find an element match matching {PARAM}. If there is none, wait until a matching element is attached to the DOM.</description>
		/// </item>
		/// <item><description>Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already unchecked, this method returns immediately.</description>
		/// </item>
		/// <item><description>Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless {OPTION}
		/// option is set. If the element is detached during the checks, the whole action is retried.</description>
		/// </item>
		/// <item><description>Scroll the element into view if needed.</description></item>
		/// <item><description>Use <see cref="IPage.Mouse"/> to click in the center of the element.</description></item>
		/// <item><description>Wait for initiated navigations to either succeed or fail, unless {OPTION} option is set.</description>
		/// </item>
		/// <item><description>Ensure that the element is now unchecked. If not, this method rejects.</description>
		/// </item>
		/// </list>
		/// When all steps combined have not finished during the specified {OPTION}, this method rejects with a <see cref="ITimeoutError"/>.
		/// Passing zero timeout disables this.
		/// Shortcut for main frame's <see cref="IFrame.UncheckAsync"/>.
		/// </summary>
		Task UncheckAsync(string selector, bool force, bool noWaitAfter, float timeout);
		/// <summary>
		/// Removes a route created with <see cref="IPage.RouteAsync"/>. When {PARAM} is not specified, removes all routes for the {PARAM}.
		/// </summary>
		Task UnrouteAsync(Union url, Action handler);
		/// <summary>
		/// Shortcut for main frame's <see cref="IFrame.Url"/>.
		/// </summary>
		string GetUrl();
		/// <summary>
		/// Video object associated with this page.
		/// </summary>
		IVideo GetVideo();
		PageViewportSizeResult GetViewportSize();
		/// <summary>
		/// Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy value.
		/// Will throw an error if the page is closed before the event is fired. Returns the event data value.
		/// </summary>
		Task<any> WaitForEventAsync(string @event);
		/// <summary>
		/// Returns when the {PARAM} returns a truthy value. It resolves to a JSHandle of the truthy value.
		/// The <see cref="IPage.WaitForFunctionAsync"/> can be used to observe viewport size change:
		/// To pass an argument to the predicate of <see cref="IPage.WaitForFunctionAsync"/> function:
		/// Shortcut for main frame's <see cref="IFrame.WaitForFunctionAsync"/>.
		/// </summary>
		Task<IJSHandle> WaitForFunctionAsync(EvaluationArgument arg, Polling polling, float timeout);
		/// <summary>
		/// Returns when the required load state has been reached.
		/// This resolves when the page reaches a required load state, `load` by default. The navigation must have been committed when
		/// this method is called. If current document has already reached the required state, resolves immediately.
		/// Shortcut for main frame's <see cref="IFrame.WaitForLoadStateAsync"/>.
		/// </summary>
		Task WaitForLoadStateAsync(State state, float timeout);
		/// <summary>
		/// Waits for the main frame navigation and returns the main resource response. In case of multiple redirects, the navigation
		/// will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to History
		/// API usage, the navigation will resolve with `null`.
		/// This resolves when the page navigates to a new URL or reloads. It is useful for when you run code which will indirectly cause
		/// the page to navigate. e.g. The click target has an `onclick` handler that triggers navigation from a `setTimeout`. Consider
		/// this example:
		/// Shortcut for main frame's <see cref="IFrame.WaitForNavigationAsync"/>.
		/// </summary>
		Task<IResponse> WaitForNavigationAsync(float timeout, Union url, WaitUntil waitUntil);
		/// <summary>
		/// Waits for the matching request and returns it.
		/// </summary>
		Task<IRequest> WaitForRequestAsync(Union urlOrPredicate, float timeout);
		/// <summary>
		/// Returns the matched response.
		/// </summary>
		Task<IResponse> WaitForResponseAsync(Union urlOrPredicate, float timeout);
		/// <summary>
		/// Returns when element specified by selector satisfies {OPTION} option. Returns `null` if waiting for `hidden` or `detached`.
		/// Wait for the {PARAM} to satisfy {OPTION} option (either appear/disappear from dom, or become visible/hidden). If at the moment
		/// of calling the method {PARAM} already satisfies the condition, the method will return immediately. If the selector doesn't
		/// satisfy the condition for the {OPTION} milliseconds, the function will throw.
		/// This method works across navigations:
		/// </summary>
		Task<IElementHandle> WaitForSelectorAsync(string selector, State state, float timeout);
		/// <summary>
		/// Waits for the given {PARAM} in milliseconds.
		/// Note that `page.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going to be
		/// flaky. Use signals such as network events, selectors becoming visible and others instead.
		/// Shortcut for main frame's <see cref="IFrame.WaitForTimeoutAsync"/>.
		/// </summary>
		Task WaitForTimeoutAsync(float timeout);
		/// <summary>
		/// This method returns all of the dedicated <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">WebWorkers</a> associated
		/// with the page.
		/// </summary>
		dynamic GetWorkers();
	}
}